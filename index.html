<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> 创想
boom boom boom - Bubble World</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: linear-gradient(135deg, #1a3a5c 0%, #0d2137 100%);
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
            user-select: none;
        }
        
        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        /* 通用屏幕样式 */
        .screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.5s;
        }
        
        .screen.hidden { display: none; }
        
        /* 开始界面 - 使用背景图片 */
        #start-screen {
            background: url('images/背景.png') center center / cover no-repeat;
            overflow: hidden;
        }
        
        /* 移除黑色遮罩，保持背景原始亮度 */
        
        .logo-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 30px;
            animation: floatLogo 3s ease-in-out infinite;
        }
        
        @keyframes floatLogo {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }
        
        .kuikly-logo {
            width: 180px;
            height: 180px;
            position: relative;
            margin-bottom: 20px;
            display: none; /* 隐藏酷比logo，因为背景已经有角色 */
        }
        
        /* 酷比头部 */
        .kuikly-head {
            width: 180px;
            height: 150px;
            background: linear-gradient(180deg, #ff6b81 0%, #ee5a6f 100%);
            border-radius: 50% 50% 45% 45%;
            position: relative;
            box-shadow: 0 10px 30px rgba(255, 107, 129, 0.4);
        }
        
        /* 耳朵 */
        .kuikly-ear {
            width: 70px;
            height: 70px;
            background: linear-gradient(180deg, #ff6b81 0%, #ee5a6f 100%);
            border-radius: 50%;
            position: absolute;
            top: -20px;
            box-shadow: 0 5px 15px rgba(255, 107, 129, 0.3);
        }
        
        .kuikly-ear.left { left: 5px; }
        .kuikly-ear.right { right: 5px; }
        
        /* 脸部 */
        .kuikly-face {
            width: 130px;
            height: 110px;
            background: linear-gradient(180deg, #ffe4e8 0%, #ffd4da 100%);
            border-radius: 50%;
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        /* 眼睛 */
        .kuikly-eye {
            width: 12px;
            height: 45px;
            background: linear-gradient(180deg, #5c2a3a 0%, #3d1a28 100%);
            border-radius: 6px;
            position: absolute;
            top: 35px;
        }
        
        .kuikly-eye.left { left: 35px; }
        .kuikly-eye.right { right: 35px; }
        
        .kuikly-eye::after {
            content: '';
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        /* 腮红 */
        .kuikly-blush {
            width: 25px;
            height: 18px;
            background: rgba(255, 150, 170, 0.6);
            border-radius: 50%;
            position: absolute;
            top: 65px;
        }
        
        .kuikly-blush.left { left: 12px; }
        .kuikly-blush.right { right: 12px; }
        
        /* 嘴巴 */
        .kuikly-mouth {
            width: 30px;
            height: 12px;
            border: 3px solid #8b5a6a;
            border-top: none;
            border-radius: 0 0 20px 20px;
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .game-logo {
            display: none; /* 隐藏标题，背景图已有 */
        }
        
        .game-subtitle {
            display: none; /* 隐藏副标题，背景图已有 */
        }
        
        /* 隐藏装饰泡泡，因为背景已经很丰富 */
        .bubble {
            display: none;
        }
        
        .menu-btn {
            background: linear-gradient(180deg, #ff6b81 0%, #ee5a6f 100%);
            border: 4px solid #ffffff;
            border-radius: 50px;
            padding: 20px 70px;
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
            font-size: 20px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            margin: 15px;
            box-shadow: 
                0 8px 0 #c44569,
                0 0 30px rgba(255, 107, 129, 0.6),
                inset 0 2px 10px rgba(255, 255, 255, 0.3);
            transition: all 0.15s;
            position: relative;
            z-index: 10;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .menu-btn:hover {
            transform: translateY(-4px) scale(1.05);
            background: linear-gradient(180deg, #ff8fa3 0%, #ff6b81 100%);
            box-shadow: 
                0 12px 0 #c44569,
                0 0 50px rgba(255, 107, 129, 0.8),
                inset 0 2px 10px rgba(255, 255, 255, 0.4);
        }
        
        .menu-btn:active {
            transform: translateY(4px);
            box-shadow: 
                0 4px 0 #c44569,
                0 0 20px rgba(255, 107, 129, 0.4);
        }
        
        /* 关卡选择界面 */
        #level-select-screen {
            background: url('images/背景.png') center center / cover no-repeat;
            position: relative;
        }
        
        /* 背景虚化遮罩层 */
        #level-select-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(20, 10, 40, 0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            z-index: 0;
        }
        
        /* 确保内容在遮罩层之上 */
        #level-select-screen > * {
            position: relative;
            z-index: 1;
        }
        
        .level-select-title {
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
            font-size: 56px;
            font-weight: bold;
            color: #ffe066;
            text-shadow: 
                0 4px 0 #cc66ff,
                0 8px 0 #9933cc,
                0 0 50px rgba(255, 224, 102, 0.6),
                0 0 100px rgba(180, 100, 220, 0.4);
            margin-bottom: 50px;
            padding: 20px 80px;
            background: linear-gradient(180deg, rgba(180, 100, 220, 0.9) 0%, rgba(120, 50, 180, 0.9) 100%);
            border-radius: 40px;
            border: 5px solid rgba(255, 255, 255, 0.8);
            box-shadow: 
                0 8px 0 rgba(80, 30, 120, 0.8),
                0 0 60px rgba(180, 100, 220, 0.5),
                inset 0 3px 15px rgba(255, 255, 255, 0.3);
            letter-spacing: 12px;
            animation: titleGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes titleGlow {
            from { 
                box-shadow: 
                    0 8px 0 rgba(80, 30, 120, 0.8),
                    0 0 60px rgba(180, 100, 220, 0.5),
                    inset 0 3px 15px rgba(255, 255, 255, 0.3);
            }
            to { 
                box-shadow: 
                    0 8px 0 rgba(80, 30, 120, 0.8),
                    0 0 80px rgba(180, 100, 220, 0.7),
                    inset 0 3px 15px rgba(255, 255, 255, 0.4);
            }
        }
        
        .level-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 35px 45px;
            max-width: 900px;
            padding: 30px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 30px;
            border: 2px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(5px);
        }
        
        /* 六边形关卡卡片 */
        .level-card {
            position: relative;
            width: 200px;
            height: 220px;
            cursor: pointer;
            transition: all 0.3s ease;
            filter: drop-shadow(0 10px 20px rgba(0, 0, 0, 0.4));
        }
        
        .level-card:hover {
            transform: translateY(-12px) scale(1.08);
            filter: drop-shadow(0 20px 35px rgba(100, 50, 180, 0.5));
        }
        
        .level-card:active {
            transform: translateY(-6px) scale(1.04);
        }
        
        /* 六边形容器 - 正六边形比例 (宽:高 = 2:√3 ≈ 1:0.866) */
        .hex-container {
            position: relative;
            width: 150px;
            height: 173px;  /* 150 * √3 / 2 * 2 ≈ 173 */
            margin: 0 auto;
        }
        
        /* 六边形外框 - 正六边形 (尖角朝上) */
        .hex-border {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #9966dd 0%, #6633aa 100%);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .level-card:hover .hex-border {
            background: linear-gradient(180deg, #bb88ff 0%, #8855cc 100%);
        }
        
        /* 六边形内部 - 正六边形 */
        .hex-inner {
            width: 90%;
            height: 90%;
            background: linear-gradient(180deg, #f0f8ff 0%, #d8ecf8 50%, #c0e0f0 100%);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .level-card:hover .hex-inner {
            background: linear-gradient(180deg, #ffffff 0%, #e8f4fc 50%, #d0e8f8 100%);
        }
        
        .level-icon {
            font-size: 72px;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.2));
            transition: transform 0.3s ease;
        }
        
        .level-card:hover .level-icon {
            transform: scale(1.1);
        }
        
        /* 星星评分 - 已隐藏 */
        .level-stars {
            display: none;
        }
        
        .star {
            font-size: 26px;
            color: #ffd700;
            text-shadow: 
                0 2px 0 #cc9900,
                0 0 15px rgba(255, 215, 0, 0.6);
            transition: transform 0.2s ease;
        }
        
        .level-card:hover .star {
            animation: starPop 0.3s ease forwards;
        }
        
        .level-card:hover .star:nth-child(1) { animation-delay: 0s; }
        .level-card:hover .star:nth-child(2) { animation-delay: 0.1s; }
        .level-card:hover .star:nth-child(3) { animation-delay: 0.2s; }
        
        @keyframes starPop {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1.1); }
        }
        
        .star.empty {
            color: #555;
            text-shadow: none;
            opacity: 0.4;
        }
        
        /* 关卡名称 */
        .level-name {
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
            font-size: 18px;
            font-weight: bold;
            color: #ffffff;
            text-shadow: 
                0 2px 6px rgba(0, 0, 0, 0.6),
                0 0 15px rgba(180, 100, 220, 0.4);
            margin-top: 12px;
            letter-spacing: 3px;
            text-align: center;
        }
        
        .level-desc {
            display: none;
        }
        
        /* 锁定状态 */
        .level-card.locked {
            cursor: not-allowed;
            opacity: 0.85;
        }
        
        .level-card.locked:hover {
            transform: none;
            filter: drop-shadow(0 10px 20px rgba(0, 0, 0, 0.4));
        }
        
        .level-card.locked .hex-border {
            background: linear-gradient(180deg, #555555 0%, #333333 100%);
        }
        
        .level-card.locked .hex-inner {
            background: linear-gradient(180deg, #444444 0%, #2a2a2a 50%, #1a1a1a 100%);
        }
        
        .level-card.locked .level-icon {
            display: none;
        }
        
        .lock-icon {
            display: none;
            font-size: 55px;
            color: #777;
            filter: drop-shadow(0 3px 5px rgba(0, 0, 0, 0.4));
        }
        
        .level-card.locked .lock-icon {
            display: block;
        }
        
        .level-card.locked .star {
            color: #444;
            text-shadow: none;
        }
        
        .level-card.locked .level-name {
            color: #888;
            text-shadow: none;
        }
        
        .back-btn {
            margin-top: 30px;
            padding: 18px 60px;
            font-size: 18px;
        }
        
        .controls-info {
            position: absolute;
            bottom: 40px;
            display: flex;
            gap: 80px;
            color: #ffffff;
            font-size: 13px;
            z-index: 10;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.85);
            padding: 15px 25px;
            border-radius: 15px;
            border: 3px solid #ff6b81;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(5px);
        }
        
        .control-group h4 {
            color: #ff6b81;
            margin-bottom: 10px;
            font-size: 14px;
            font-weight: bold;
        }
        
        .control-group div {
            color: #333;
        }
        
        .key {
            display: inline-block;
            background: linear-gradient(180deg, #ff6b81 0%, #c44569 100%);
            border: 2px solid #ffffff;
            border-radius: 8px;
            padding: 5px 12px;
            margin: 2px;
            font-family: monospace;
            font-weight: bold;
            color: white;
            box-shadow: 0 3px 0 #833471;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.3);
        }
        
        /* 音量控制按钮 */
        .sound-btn {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 44px;
            height: 44px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00aaff;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            color: white;
            z-index: 1000;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .sound-btn:hover {
            background: rgba(0, 170, 255, 0.3);
            transform: scale(1.1);
        }
        
        .sound-btn.muted {
            border-color: #ff4444;
            opacity: 0.6;
        }
        
        /* 加载提示 */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 20, 40, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: opacity 0.5s;
        }
        
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 20px;
            color: #00d4ff;
            margin-bottom: 30px;
        }
        
        .loading-bar {
            width: 300px;
            height: 20px;
            background: #1a2a4a;
            border: 2px solid #00aaff;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #00aaff, #00ffaa);
            width: 0%;
            transition: width 0.3s;
        }
        
        .loading-percent {
            margin-top: 15px;
            color: #88ccff;
            font-size: 14px;
        }
        
        /* 角色选择界面 */
        #select-screen {
            background: rgba(10, 20, 40, 0.95);
        }
        
        .select-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 28px;
            color: #00d4ff;
            margin-bottom: 40px;
            text-shadow: 0 0 20px #00aaff;
        }
        
        .select-panels {
            display: flex;
            gap: 80px;
        }
        
        .player-panel {
            width: 300px;
            background: rgba(30, 50, 80, 0.6);
            border: 3px solid #334466;
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            transition: all 0.3s;
        }
        
        .player-panel.ready {
            border-color: #00ff88;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.4);
            background: rgba(0, 80, 60, 0.4);
        }
        
        .panel-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 18px;
            margin-bottom: 20px;
        }
        
        .color-preview {
            width: 120px;
            height: 120px;
            margin: 20px auto;
            border-radius: 50%;
            border: 4px solid white;
            box-shadow: 0 0 20px currentColor;
            transition: all 0.3s;
        }
        
        .color-selector {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 20px 0;
        }
        
        .color-dot {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .color-dot.active {
            border-color: white;
            transform: scale(1.3);
            box-shadow: 0 0 10px white;
        }
        
        .ready-status {
            font-family: 'Press Start 2P', cursive;
            font-size: 20px;
            margin-top: 20px;
            color: #666;
        }
        
        .player-panel.ready .ready-status {
            color: #00ff88;
            animation: blink 0.5s infinite alternate;
        }
        
        @keyframes blink {
            from { opacity: 0.7; }
            to { opacity: 1; }
        }
        
        .panel-controls {
            margin-top: 20px;
            color: #aaa;
            font-size: 12px;
            line-height: 2;
        }
        
        #countdown {
            position: absolute;
            font-family: 'Press Start 2P', cursive;
            font-size: 120px;
            color: white;
            text-shadow: 0 0 50px #ff4444;
            display: none;
        }
        
        /* 游戏UI */
        #game-ui {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            display: none;
            z-index: 50;
        }
        
        .timer-bar {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00aaff;
            border-radius: 30px;
            padding: 10px 30px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .timer-icon { font-size: 24px; }
        
        .timer-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 24px;
            color: #ffdd00;
        }
        
        .back-menu-btn {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff6b81;
            border-radius: 25px;
            padding: 14px 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 11px;
            color: white;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.2s;
        }
        
        .back-menu-btn:hover {
            background: rgba(255, 107, 129, 0.8);
            transform: scale(1.05);
        }
        
        .top-right-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 15px;
            align-items: center;
            pointer-events: auto;
        }
        
        .game-sound-btn {
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00aaff;
            border-radius: 50%;
            cursor: pointer;
            font-size: 22px;
            color: white;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .game-sound-btn:hover {
            background: rgba(0, 170, 255, 0.3);
            transform: scale(1.1);
        }
        
        .player-hud {
            position: absolute;
            width: 288px;
            height: 228px;
            border-radius: 18px;
            left: 10px;
            display: flex;
            padding: 12px;
            border: none;
            box-sizing: border-box;
            background: url('images/UI背景.png') center center / 100% 100% no-repeat;
        }
        
        .hud-p1 { 
            top: 80px; 
        }
        .hud-p2 { 
            top: 330px; 
        }
        .hud-ai1 { 
            top: 580px; 
        }
        .hud-ai2 { 
            top: 830px; 
        }
        
        .hud-avatar-container {
            position: relative;
            width: 120px;
            height: 100%;
            flex-shrink: 0;
        }
        
        .hud-player-label {
            position: absolute;
            top: -2px;
            left: -2px;
            font-family: 'Arial Black', sans-serif;
            font-size: 26px;
            font-weight: 900;
            color: white;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000;
            z-index: 10;
        }
        
        .hud-avatar-box {
            width: 120px;
            height: 156px;
            border-radius: 14px;
            background: rgba(255, 255, 255, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.8);
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .hud-avatar {
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center top;
        }
        
        .hud-avatar-name {
            position: absolute;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            color: white;
            font-size: 13px;
            padding: 4px 12px;
            border-radius: 10px;
            white-space: nowrap;
        }
        
        .hud-content {
            display: flex;
            flex-direction: column;
            padding: 0;
            width: 100%;
            height: 100%;
        }
        
        .hud-name {
            display: none;
        }
        
        .hud-stats {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding-left: 8px;
            justify-content: center;
            height: 100%;
        }
        
        .stat-row {
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 20px;
            padding: 3px 10px 3px 5px;
            gap: 6px;
        }
        
        .stat-icon {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .stat-icon img {
            width: 24px;
            height: 24px;
            object-fit: contain;
        }
        
        .stat-number {
            font-family: 'Arial Black', sans-serif;
            font-size: 18px;
            font-weight: 900;
            color: #1e3a5f;
            text-shadow: 1px 1px 0 rgba(255, 255, 255, 0.5);
            min-width: 20px;
            text-align: right;
        }
        
        .stat {
            display: none;
        }
        
        .stat-value {
            display: none;
        }
        
        .stat-inactive {
            opacity: 0.3;
            filter: grayscale(80%);
        }
        
        .stat-max .stat-number {
            color: #ffd700;
        }
        
        .hud-dead {
            opacity: 0.4;
            filter: grayscale(100%);
        }
        
        /* 游戏结束界面 */
        #gameover-screen {
            background: rgba(0, 0, 0, 0.85);
        }
        
        .result-box {
            background: white;
            border-radius: 20px;
            padding: 50px 80px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            border: 3px solid #ffd700;
        }
        
        .result-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 20px;
            color: #5c3317;
            margin-bottom: 20px;
        }
        
        .winner-name {
            font-family: 'Press Start 2P', cursive;
            font-size: 28px;
            color: #ffd700;
            margin-bottom: 30px;
            text-shadow: 2px 2px 0 #8b4513;
        }
    </style>
</head>
<body>
    <button class="sound-btn" id="sound-btn" onclick="toggleSound()" title="开关音效">🔊</button>
    
    <!-- 加载提示 -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-text">加载模型中...</div>
        <div class="loading-bar">
            <div class="loading-progress" id="loading-progress"></div>
        </div>
        <div class="loading-percent" id="loading-percent">0%</div>
    </div>
    
    <div id="game-container">
        <!-- 开始界面 -->
        <div id="start-screen" class="screen">
            <!-- 装饰泡泡 -->
            <div class="bubble"></div>
            <div class="bubble"></div>
            <div class="bubble"></div>
            <div class="bubble"></div>
            <div class="bubble"></div>
            <div class="bubble"></div>
            
            <div class="logo-container">
                <!-- 酷比Logo -->
                <div class="kuikly-logo">
                    <div class="kuikly-head">
                        <div class="kuikly-ear left"></div>
                        <div class="kuikly-ear right"></div>
                        <div class="kuikly-face">
                            <div class="kuikly-eye left"></div>
                            <div class="kuikly-eye right"></div>
                            <div class="kuikly-blush left"></div>
                            <div class="kuikly-blush right"></div>
                            <div class="kuikly-mouth"></div>
                        </div>
                    </div>
                </div>
                
                <div class="game-logo"> 创想
boom boom boom</div>
                <div class="game-subtitle">BUBBLE FIGHTER</div>
            </div>
            
            <button class="menu-btn" onclick="selectMode('single')">🎮 单人模式</button>
            <button class="menu-btn" onclick="selectMode('double')">👥 双人模式</button>
            
            <div class="controls-info">
                <div class="control-group">
                    <h4>玩家1</h4>
                    <div><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> 移动</div>
                    <div><span class="key">空格</span> 放炸弹</div>
                </div>
                <div class="control-group">
                    <h4>玩家2</h4>
                    <div><span class="key">↑</span><span class="key">←</span><span class="key">↓</span><span class="key">→</span> 移动</div>
                    <div><span class="key">Enter</span> 放炸弹</div>
                </div>
            </div>
        </div>
        
        <!-- 关卡选择界面 -->
        <div id="level-select-screen" class="screen hidden">
            <div class="level-select-title">关卡选择</div>
            <div class="level-grid">
                <div class="level-card" onclick="selectLevel('fairy')">
                    <div class="hex-container">
                        <div class="hex-border">
                            <div class="hex-inner">
                                <div class="level-icon">🏰</div>
                                <div class="lock-icon">🔒</div>
                            </div>
                        </div>
                    </div>
                    <div class="level-stars">
                        <span class="star">★</span>
                        <span class="star">★</span>
                        <span class="star">★</span>
                    </div>
                    <div class="level-name">童话城堡</div>
                </div>
                <div class="level-card" onclick="selectLevel('forest')">
                    <div class="hex-container">
                        <div class="hex-border">
                            <div class="hex-inner">
                                <div class="level-icon">🌲</div>
                                <div class="lock-icon">🔒</div>
                            </div>
                        </div>
                    </div>
                    <div class="level-stars">
                        <span class="star">★</span>
                        <span class="star">★</span>
                        <span class="star">★</span>
                    </div>
                    <div class="level-name">神秘森林</div>
                </div>
                <div class="level-card" onclick="selectLevel('ocean')">
                    <div class="hex-container">
                        <div class="hex-border">
                            <div class="hex-inner">
                                <div class="level-icon">🌊</div>
                                <div class="lock-icon">🔒</div>
                            </div>
                        </div>
                    </div>
                    <div class="level-stars">
                        <span class="star">★</span>
                        <span class="star">★</span>
                        <span class="star">★</span>
                    </div>
                    <div class="level-name">海底世界</div>
                </div>
                <div class="level-card" onclick="selectLevel('city')">
                    <div class="hex-container">
                        <div class="hex-border">
                            <div class="hex-inner">
                                <div class="level-icon">🏙️</div>
                                <div class="lock-icon">🔒</div>
                            </div>
                        </div>
                    </div>
                    <div class="level-stars">
                        <span class="star">★</span>
                        <span class="star">★</span>
                        <span class="star">★</span>
                    </div>
                    <div class="level-name">都市街区</div>
                </div>
                <div class="level-card" onclick="selectLevel('park')">
                    <div class="hex-container">
                        <div class="hex-border">
                            <div class="hex-inner">
                                <div class="level-icon">🎡</div>
                                <div class="lock-icon">🔒</div>
                            </div>
                        </div>
                    </div>
                    <div class="level-stars">
                        <span class="star">★</span>
                        <span class="star">★</span>
                        <span class="star">★</span>
                    </div>
                    <div class="level-name">欢乐公园</div>
                </div>
                <div class="level-card" onclick="selectLevel('desert')">
                    <div class="hex-container">
                        <div class="hex-border">
                            <div class="hex-inner">
                                <div class="level-icon">🏜️</div>
                                <div class="lock-icon">🔒</div>
                            </div>
                        </div>
                    </div>
                    <div class="level-stars">
                        <span class="star">★</span>
                        <span class="star">★</span>
                        <span class="star">★</span>
                    </div>
                    <div class="level-name">沙漠绿洲</div>
                </div>
            </div>
            <button class="menu-btn back-btn" onclick="backToStart()">返回</button>
        </div>
        
        <!-- 角色选择界面 -->
        <div id="select-screen" class="screen hidden">
            <div class="select-title">选择你的酷比</div>
            
            <div class="select-panels">
                <div class="player-panel" id="panel-p1">
                    <div class="panel-title" id="title-p1" style="color: #00aaff;">玩家 1</div>
                    <div class="color-preview" id="preview-p1"></div>
                    <div class="color-selector" id="colors-p1"></div>
                    <div class="ready-status" id="status-p1">等待中...</div>
                    <div class="panel-controls">
                        <span class="key">A</span><span class="key">D</span> 切换颜色<br>
                        <span class="key">空格</span> 确认
                    </div>
                </div>
                
                <div class="player-panel" id="panel-p2">
                    <div class="panel-title" id="title-p2" style="color: #ff6699;">玩家 2</div>
                    <div class="color-preview" id="preview-p2"></div>
                    <div class="color-selector" id="colors-p2"></div>
                    <div class="ready-status" id="status-p2">等待中...</div>
                    <div class="panel-controls">
                        <span class="key">←</span><span class="key">→</span> 切换颜色<br>
                        <span class="key">Enter</span> 确认
                    </div>
                </div>
            </div>
            
            <div id="countdown">3</div>
        </div>
        
        <!-- 游戏UI -->
        <div id="game-ui">
            <div class="timer-bar">
                <span class="timer-icon">⏱️</span>
                <span class="timer-text" id="timer">03:00</span>
            </div>
            
            <div class="top-right-controls">
                <button class="game-sound-btn" id="game-sound-btn" onclick="toggleSound()">🔊</button>
                <button class="back-menu-btn" onclick="backToMainMenu()">🏠 返回</button>
            </div>
            
            <div class="player-hud hud-p1" id="hud-p1">
                <div class="hud-avatar-container">
                    <div class="hud-player-label">P1</div>
                    <div class="hud-avatar-box">
                        <div class="hud-avatar" id="avatar-p1"></div>
                    </div>
                    <div class="hud-avatar-name">玩家 1</div>
                </div>
                <div class="hud-content">
                    <div class="hud-stats">
                        <div class="stat-row" id="stat-p1-bomb-row">
                            <div class="stat-icon"><img src="images/炸弹.png" alt="炸弹"></div>
                            <span class="stat-number" id="stat-p1-bomb">1</span>
                        </div>
                        <div class="stat-row" id="stat-p1-range-row">
                            <div class="stat-icon"><img src="images/蓝色试剂.png" alt="范围"></div>
                            <span class="stat-number" id="stat-p1-range">1</span>
                        </div>
                        <div class="stat-row" id="stat-p1-speed-row">
                            <div class="stat-icon"><img src="images/鞋子.png" alt="速度"></div>
                            <span class="stat-number" id="stat-p1-speed">1</span>
                        </div>
                        <div class="stat-row stat-inactive" id="stat-p1-kick">
                            <div class="stat-icon"><img src="images/手套.png" alt="手套"></div>
                        </div>
                        <div class="stat-row stat-inactive" id="stat-p1-weapon">
                            <div class="stat-icon"></div>
                            <span class="stat-number" id="stat-p1-weapon-val"></span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="player-hud hud-p2" id="hud-p2">
                <div class="hud-avatar-container">
                    <div class="hud-player-label">P2</div>
                    <div class="hud-avatar-box">
                        <div class="hud-avatar" id="avatar-p2"></div>
                    </div>
                    <div class="hud-avatar-name">玩家 2</div>
                </div>
                <div class="hud-content">
                    <div class="hud-stats">
                        <div class="stat-row" id="stat-p2-bomb-row">
                            <div class="stat-icon"><img src="images/炸弹.png" alt="炸弹"></div>
                            <span class="stat-number" id="stat-p2-bomb">1</span>
                        </div>
                        <div class="stat-row" id="stat-p2-range-row">
                            <div class="stat-icon"><img src="images/蓝色试剂.png" alt="范围"></div>
                            <span class="stat-number" id="stat-p2-range">1</span>
                        </div>
                        <div class="stat-row" id="stat-p2-speed-row">
                            <div class="stat-icon"><img src="images/鞋子.png" alt="速度"></div>
                            <span class="stat-number" id="stat-p2-speed">1</span>
                        </div>
                        <div class="stat-row stat-inactive" id="stat-p2-kick">
                            <div class="stat-icon"><img src="images/手套.png" alt="手套"></div>
                        </div>
                        <div class="stat-row stat-inactive" id="stat-p2-weapon">
                            <div class="stat-icon"></div>
                            <span class="stat-number" id="stat-p2-weapon-val"></span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="player-hud hud-ai1" id="hud-ai1">
                <div class="hud-avatar-container">
                    <div class="hud-player-label">AI</div>
                    <div class="hud-avatar-box">
                        <div class="hud-avatar" id="avatar-ai1"></div>
                    </div>
                    <div class="hud-avatar-name">AI 1</div>
                </div>
                <div class="hud-content">
                    <div class="hud-stats">
                        <div class="stat-row" id="stat-ai1-bomb-row">
                            <div class="stat-icon"><img src="images/炸弹.png" alt="炸弹"></div>
                            <span class="stat-number" id="stat-ai1-bomb">1</span>
                        </div>
                        <div class="stat-row" id="stat-ai1-range-row">
                            <div class="stat-icon"><img src="images/蓝色试剂.png" alt="范围"></div>
                            <span class="stat-number" id="stat-ai1-range">1</span>
                        </div>
                        <div class="stat-row" id="stat-ai1-speed-row">
                            <div class="stat-icon"><img src="images/鞋子.png" alt="速度"></div>
                            <span class="stat-number" id="stat-ai1-speed">1</span>
                        </div>
                        <div class="stat-row stat-inactive" id="stat-ai1-kick">
                            <div class="stat-icon"><img src="images/手套.png" alt="手套"></div>
                        </div>
                        <div class="stat-row stat-inactive" id="stat-ai1-weapon">
                            <div class="stat-icon"></div>
                            <span class="stat-number" id="stat-ai1-weapon-val"></span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="player-hud hud-ai2" id="hud-ai2">
                <div class="hud-avatar-container">
                    <div class="hud-player-label">AI</div>
                    <div class="hud-avatar-box">
                        <div class="hud-avatar" id="avatar-ai2"></div>
                    </div>
                    <div class="hud-avatar-name">AI 2</div>
                </div>
                <div class="hud-content">
                    <div class="hud-stats">
                        <div class="stat-row" id="stat-ai2-bomb-row">
                            <div class="stat-icon"><img src="images/炸弹.png" alt="炸弹"></div>
                            <span class="stat-number" id="stat-ai2-bomb">1</span>
                        </div>
                        <div class="stat-row" id="stat-ai2-range-row">
                            <div class="stat-icon"><img src="images/蓝色试剂.png" alt="范围"></div>
                            <span class="stat-number" id="stat-ai2-range">1</span>
                        </div>
                        <div class="stat-row" id="stat-ai2-speed-row">
                            <div class="stat-icon"><img src="images/鞋子.png" alt="速度"></div>
                            <span class="stat-number" id="stat-ai2-speed">1</span>
                        </div>
                        <div class="stat-row stat-inactive" id="stat-ai2-kick">
                            <div class="stat-icon"><img src="images/手套.png" alt="手套"></div>
                        </div>
                        <div class="stat-row stat-inactive" id="stat-ai2-weapon">
                            <div class="stat-icon"></div>
                            <span class="stat-number" id="stat-ai2-weapon-val"></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 游戏结束界面 -->
        <div id="gameover-screen" class="screen hidden">
            <div class="result-box">
                <div class="result-title">游戏结束</div>
                <div class="winner-name" id="winner-text">玩家 1 获胜!</div>
                <button class="menu-btn" onclick="restartGame()">再来一局</button>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
    // ==================== 游戏配置 ====================
    const CONFIG = {
        TILE_SIZE: 4,
        GRID_WIDTH: 15,
        GRID_HEIGHT: 13,
        WALL_HEIGHT: 4,
        GAME_TIME: 180,
        BOMB_TIMER: 3,
        BOMB_KICK_SPEED: 18
    };
    
    // 使用本地GLTF模型 - 每个玩家使用不同模型
    const GLTF_MODEL_URLS = [
        'models/粉酷比.glb',    // 玩家1
        'models/蓝酷比.glb',    // 玩家2
        'models/绿酷比.glb',    // 电脑1
        'models/黄酷比.glb'     // 电脑2
    ];
    let gltfModelTemplates = [null, null, null, null]; // 4个模型模板
    let modelsLoaded = 0;
    let modelLoadError = false;
    
    // 童话山模型（边缘装饰）
    let fairyMountainModel = null;

    // ==================== 音效系统 ====================
    class SoundManager {
        constructor() {
            this.ctx = null;
            this.masterGain = null;
            this.enabled = true;
            this.volume = 0.5;
            this.bgmVolume = 0.4;
            
            // 背景音乐
            this.startBgm = null;
            this.gameBgm = null;
            this.currentBgm = null;
            this.bgmLoaded = false;
        }
        
        init() {
            if (this.ctx) return;
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = this.volume;
            this.masterGain.connect(this.ctx.destination);
            
            // 加载背景音乐
            this.loadBgm();
        }
        
        loadBgm() {
            if (this.bgmLoaded) return;
            this.bgmLoaded = true;
            
            // 开始界面音乐 - 使用编码的文件名
            this.startBgm = new Audio('audio/' + encodeURIComponent('开始界面.mp3'));
            this.startBgm.loop = true;
            this.startBgm.volume = this.bgmVolume;
            this.startBgm.preload = 'auto';
            this.startBgm.load();
            
            // 游戏背景音乐
            this.gameBgm = new Audio('audio/' + encodeURIComponent('背景音乐.mp3'));
            this.gameBgm.loop = true;
            this.gameBgm.volume = this.bgmVolume;
            this.gameBgm.preload = 'auto';
            this.gameBgm.load();
            
            console.log('BGM loaded');
        }
        
        playStartBgm() {
            console.log('playStartBgm called, enabled:', this.enabled, 'startBgm:', this.startBgm);
            if (!this.enabled) return;
            if (!this.startBgm) this.loadBgm();
            this.stopAllBgm();
            if (this.startBgm) {
                this.startBgm.currentTime = 0;
                this.startBgm.play().then(() => {
                    console.log('Start BGM playing');
                }).catch((e) => {
                    console.log('Start BGM play failed:', e);
                });
                this.currentBgm = this.startBgm;
            }
        }
        
        playGameBgm() {
            console.log('playGameBgm called, enabled:', this.enabled, 'gameBgm:', this.gameBgm);
            if (!this.enabled) return;
            if (!this.gameBgm) this.loadBgm();
            this.stopAllBgm();
            if (this.gameBgm) {
                this.gameBgm.currentTime = 0;
                this.gameBgm.play().then(() => {
                    console.log('Game BGM playing');
                }).catch((e) => {
                    console.log('Game BGM play failed:', e);
                });
                this.currentBgm = this.gameBgm;
            }
        }
        
        stopAllBgm() {
            if (this.startBgm) {
                this.startBgm.pause();
                this.startBgm.currentTime = 0;
            }
            if (this.gameBgm) {
                this.gameBgm.pause();
                this.gameBgm.currentTime = 0;
            }
            this.currentBgm = null;
        }
        
        resume() {
            if (this.ctx && this.ctx.state === 'suspended') {
                this.ctx.resume();
            }
        }
        
        setVolume(v) {
            this.volume = v;
            if (this.masterGain) this.masterGain.gain.value = v;
        }
        
        toggle() {
            this.enabled = !this.enabled;
            if (this.masterGain) this.masterGain.gain.value = this.enabled ? this.volume : 0;
            
            // 同时控制背景音乐
            if (this.startBgm) this.startBgm.volume = this.enabled ? this.bgmVolume : 0;
            if (this.gameBgm) this.gameBgm.volume = this.enabled ? this.bgmVolume : 0;
            
            return this.enabled;
        }
        
        // 放置炸弹音效 - 轻柔的"噗"声，像放下一个软球
        playBombPlace() {
            if (!this.ctx || !this.enabled) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(200, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(80, this.ctx.currentTime + 0.1);
            
            gain.gain.setValueAtTime(0.25, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.12);
            
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.12);
        }
        
        // 爆炸音效 - 卡通风格的"砰"声
        playExplosion() {
            if (!this.ctx || !this.enabled) return;
            
            // 主爆炸音 - 短促有力
            const osc = this.ctx.createOscillator();
            const oscGain = this.ctx.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(120, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.15);
            oscGain.gain.setValueAtTime(0.3, this.ctx.currentTime);
            oscGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.18);
            
            osc.connect(oscGain);
            oscGain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.2);
            
            // 轻微噪音增加质感
            const bufferSize = this.ctx.sampleRate * 0.15;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 3);
            }
            
            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            
            const noiseGain = this.ctx.createGain();
            noiseGain.gain.setValueAtTime(0.2, this.ctx.currentTime);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
            
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(800, this.ctx.currentTime);
            filter.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 0.15);
            
            noise.connect(filter);
            filter.connect(noiseGain);
            noiseGain.connect(this.masterGain);
            noise.start();
        }
        
        // 拾取道具音效 - 欢快的"叮咚"声
        playPowerup() {
            if (!this.ctx || !this.enabled) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(600, this.ctx.currentTime);
            osc.frequency.setValueAtTime(900, this.ctx.currentTime + 0.06);
            osc.frequency.setValueAtTime(1200, this.ctx.currentTime + 0.12);
            
            gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
            gain.gain.setValueAtTime(0.25, this.ctx.currentTime + 0.06);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.25);
            
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.2);
        }
        
        // 玩家死亡音效 - 悲伤的下降音
        playDeath() {
            if (!this.ctx || !this.enabled) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(440, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(110, this.ctx.currentTime + 0.5);
            
            gain.gain.setValueAtTime(0.25, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
            
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 800;
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.5);
        }
        
        // 倒计时音效 - 滴答声
        playCountdown() {
            if (!this.ctx || !this.enabled) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            osc.type = 'square';
            osc.frequency.value = 800;
            
            gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
            
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.1);
        }
        
        // 游戏开始音效 - 激昂的上升音
        playGameStart() {
            if (!this.ctx || !this.enabled) return;
            const notes = [262, 330, 392, 523]; // C4, E4, G4, C5
            
            notes.forEach((freq, i) => {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'square';
                osc.frequency.value = freq;
                
                const startTime = this.ctx.currentTime + i * 0.1;
                gain.gain.setValueAtTime(0, startTime);
                gain.gain.linearRampToValueAtTime(0.2, startTime + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.15);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(startTime);
                osc.stop(startTime + 0.15);
            });
        }
        
        // 游戏结束音效
        playGameOver(isWin) {
            if (!this.ctx || !this.enabled) return;
            
            if (isWin) {
                // 胜利音效 - 欢快的旋律
                const notes = [523, 659, 784, 1047, 784, 1047]; // C5, E5, G5, C6
                notes.forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.type = 'square';
                    osc.frequency.value = freq;
                    
                    const startTime = this.ctx.currentTime + i * 0.12;
                    gain.gain.setValueAtTime(0.2, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.2);
                    
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.start(startTime);
                    osc.stop(startTime + 0.2);
                });
            } else {
                // 平局/失败音效
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(300, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.8);
                
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.8);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.8);
            }
        }
        
        // 踢炸弹音效
        playKick() {
            if (!this.ctx || !this.enabled) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(200, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);
            
            gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
            
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.1);
        }
        
        // 菜单选择音效
        playMenuSelect() {
            if (!this.ctx || !this.enabled) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            osc.type = 'sine';
            osc.frequency.value = 660;
            
            gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.08);
            
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.08);
        }
        
        // 准备确认音效
        playReady() {
            if (!this.ctx || !this.enabled) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(440, this.ctx.currentTime);
            osc.frequency.setValueAtTime(880, this.ctx.currentTime + 0.08);
            
            gain.gain.setValueAtTime(0.25, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
            
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.15);
        }
        
        // 箱子破坏音效
        playCrateDestroy() {
            if (!this.ctx || !this.enabled) return;
            
            const bufferSize = this.ctx.sampleRate * 0.15;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 3);
            }
            
            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            
            const gain = this.ctx.createGain();
            gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
            
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 500;
            
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(this.masterGain);
            noise.start();
        }
    }
    
    const soundManager = new SoundManager();
    
    // 音量开关函数
    function toggleSound() {
        soundManager.init();
        const enabled = soundManager.toggle();
        // 更新主界面音量按钮
        const btn = document.getElementById('sound-btn');
        btn.textContent = enabled ? '🔊' : '🔇';
        btn.classList.toggle('muted', !enabled);
        // 更新游戏内音量按钮
        const gameBtn = document.getElementById('game-sound-btn');
        if (gameBtn) {
            gameBtn.textContent = enabled ? '🔊' : '🔇';
        }
    }

    // 酷比配色
    const KUIKLY_COLORS = [
        { name: '天空蓝', hex: 0x00aaff },
        { name: '樱花粉', hex: 0xff6699 },
        { name: '薄荷绿', hex: 0x44dd88 },
        { name: '阳光橙', hex: 0xffaa00 },
        { name: '梦幻紫', hex: 0xaa66ff },
        { name: '柠檬黄', hex: 0xffee00 },
        { name: '珊瑚红', hex: 0xff5555 },
        { name: '薰衣草', hex: 0xcc88ff }
    ];

    // 地图类型 - 海盗主题
    const TILE = {
        EMPTY: 0,
        WALL: 1,      // 锚（不可破坏）
        CRATE: 2,     // 木桶（可破坏）
        BOMB: 3,
        TREASURE: 4   // 宝箱（可破坏，稀有道具）
    };

    // 道具类型
    const POWERUP = {
        SPEED: 1,
        RANGE: 2,
        BOMB: 3,
        KICK: 4,
        // 武器道具
        LASER: 5,      // 激光枪
        FLAMETHROWER: 6, // 喷火枪
        ROCKET: 7      // 火箭筒
    };
    
    // 武器类型
    const WEAPON = {
        LASER: 'laser',
        FLAMETHROWER: 'flamethrower',
        ROCKET: 'rocket'
    };
    
    // 武器投射物数组
    let projectiles = [];

    // ==================== 性能优化：几何体缓存 ====================
    const GeoCache = {
        _cache: {},
        getSphere(r, seg = 16) {
            const k = `s_${r}_${seg}`;
            if (!this._cache[k]) this._cache[k] = new THREE.SphereGeometry(r, seg, seg);
            return this._cache[k];
        },
        getCylinder(rt, rb, h, seg = 12) {
            const k = `c_${rt}_${rb}_${h}_${seg}`;
            if (!this._cache[k]) this._cache[k] = new THREE.CylinderGeometry(rt, rb, h, seg);
            return this._cache[k];
        },
        getBox(w, h, d) {
            const k = `b_${w}_${h}_${d}`;
            if (!this._cache[k]) this._cache[k] = new THREE.BoxGeometry(w, h, d);
            return this._cache[k];
        },
        getCone(r, h, seg = 8) {
            const k = `cn_${r}_${h}_${seg}`;
            if (!this._cache[k]) this._cache[k] = new THREE.ConeGeometry(r, h, seg);
            return this._cache[k];
        }
    };

    // 材质缓存
    const MatCache = {
        _cache: new Map(),
        get(color, opts = {}) {
            const k = `${color}_${opts.roughness||0.5}_${opts.metalness||0}_${opts.emissive||0}_${opts.emissiveIntensity||0}`;
            if (!this._cache.has(k)) {
                this._cache.set(k, new THREE.MeshStandardMaterial({
                    color, roughness: opts.roughness ?? 0.5, metalness: opts.metalness || 0,
                    emissive: opts.emissive || 0, emissiveIntensity: opts.emissiveIntensity || 0
                }));
            }
            return this._cache.get(k);
        }
    };

    // 对象池
    class ObjPool {
        constructor(createFn, resetFn, size = 10) {
            this.create = createFn; this.reset = resetFn;
            this.pool = []; this.active = [];
            for (let i = 0; i < size; i++) this.pool.push(createFn());
        }
        get() {
            let o = this.pool.pop() || this.create();
            this.active.push(o);
            return o;
        }
        release(o) {
            const i = this.active.indexOf(o);
            if (i !== -1) { this.active.splice(i, 1); this.reset(o); this.pool.push(o); }
        }
        releaseAll() {
            while (this.active.length) { const o = this.active.pop(); this.reset(o); this.pool.push(o); }
        }
    }

    let explosionPool;

    // ==================== 游戏状态 ====================
    let gameState = 'start'; // start, select, playing, gameover
    let scene, camera, renderer, clock;
    let ambientLight, dirLight, fillLight, bottomLight; // 光源变量
    let baseBrightness = { ambient: 0.8, dir: 0.6, fill: 0.4, bottom: 0.3 }; // 基础亮度
    let gameTime = CONFIG.GAME_TIME;
    
    // 游戏对象
    let grid = [];
    let players = [];
    let bombs = [];
    let explosions = [];
    let powerups = [];
    let kickGlovesDropped = 0; // 已掉落的手套道具数量（每局最多5个）
    let mapMeshes = [];
    let portals = []; // 传送门数组
    let volcanoTimer = 0; // 火山爆发计时器
    let lavaWarnings = []; // 岩浆预警点
    let lavaActive = false; // 岩浆是否正在喷发
    let cityCars = []; // 城市小汽车数组
    let flyingPowerups = []; // 飞行中的道具（旋转木马抛出）
    let sandstorms = []; // 沙尘龙卷风数组
    let flyingPlayers = []; // 被龙卷风抛飞的玩家
    
    // 游戏模式
    let gameMode = 'double'; // 'single' 或 'double'
    
    // 选人状态
    let p1Selection = { colorIndex: 0, ready: false };
    let p2Selection = { colorIndex: 1, ready: false };
    let countdownInterval = null;
    
    // 输入状态
    const keys = {};
    // 记录玩家按下的方向键顺序（最后一个是当前方向）
    let p1DirectionStack = [];
    let p2DirectionStack = [];

    // FPS计数器
    const FPS = { frames: 0, last: performance.now(), fps: 0, el: null,
        update() {
            this.frames++;
            const now = performance.now();
            if (now - this.last >= 1000) {
                this.fps = Math.round(this.frames * 1000 / (now - this.last));
                this.frames = 0; this.last = now;
                if (this.el) this.el.textContent = `FPS: ${this.fps}`;
            }
        }
    };

    // ==================== 初始化 ====================
    function init() {
        scene = new THREE.Scene();
        // 童话风格天空蓝背景
        scene.background = new THREE.Color(0x87ceeb);
        // 添加雾效增加深度感
        scene.fog = new THREE.Fog(0x87ceeb, 60, 150);
        
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 45, 30);
        camera.lookAt(0, 0, 0);
        
        // 优化渲染器设置
        renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFShadowMap;
        // 使用线性色彩空间输出，保持模型原始颜色
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.NoToneMapping; // 禁用色调映射，保持原色
        document.getElementById('game-container').appendChild(renderer.domElement);
        
        // 中性白光照明 - 保持模型原始颜色
        ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        
        // 主方向光 - 纯白光
        dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(30, 50, 30);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        dirLight.shadow.camera.near = 10;
        dirLight.shadow.camera.far = 120;
        dirLight.shadow.camera.left = -40;
        dirLight.shadow.camera.right = 40;
        dirLight.shadow.camera.top = 40;
        dirLight.shadow.camera.bottom = -40;
        dirLight.shadow.bias = -0.001;
        scene.add(dirLight);
        
        // 补光 - 纯白填充光
        fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
        fillLight.position.set(-20, 30, -20);
        scene.add(fillLight);
        
        // 底部补光 - 使用中性色，避免染色
        bottomLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.3);
        scene.add(bottomLight);
        
        // 设置亮度为50%
        updateBrightness(0.5);
        
        clock = new THREE.Clock();
        
        // 初始化爆炸对象池
        explosionPool = new ObjPool(
            () => {
                const m = new THREE.Mesh(
                    GeoCache.getBox(CONFIG.TILE_SIZE * 0.9, CONFIG.TILE_SIZE * 0.9, CONFIG.TILE_SIZE * 0.9),
                    new THREE.MeshBasicMaterial({ color: 0x00ccff, transparent: true, opacity: 0.8 })
                );
                m.visible = false;
                return { mesh: m, life: 0 };
            },
            (o) => { o.mesh.visible = false; o.mesh.scale.set(1,1,1); o.mesh.material.opacity = 0.8; o.life = 0; if(o.mesh.parent) o.mesh.parent.remove(o.mesh); },
            30
        );
        
        // FPS显示 - 已禁用
        // FPS.el = document.createElement('div');
        // FPS.el.style.cssText = 'position:fixed;top:10px;right:10px;background:rgba(0,0,0,0.7);color:#0f0;padding:5px 10px;font-family:monospace;font-size:14px;border-radius:5px;z-index:1000';
        // FPS.el.textContent = 'FPS: --';
        // document.body.appendChild(FPS.el);
        
        initColorSelectors();
        
        // 预加载FBX模型
        loadFBXModel();
        
        window.addEventListener('resize', onResize);
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('keyup', onKeyUp);
        
        // 初始化音效（需要用户交互后才能播放）
        document.addEventListener('click', () => {
            soundManager.init();
            soundManager.resume();
            // 首次交互时播放开始界面音乐
            if (gameState === 'start') {
                soundManager.playStartBgm();
            }
        }, { once: true });
        document.addEventListener('keydown', () => {
            soundManager.init();
            soundManager.resume();
            // 首次交互时播放开始界面音乐
            if (gameState === 'start') {
                soundManager.playStartBgm();
            }
        }, { once: true });
        
        animate();
    }
    
    // 加载GLTF模型
    function loadFBXModel() {
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingProgress = document.getElementById('loading-progress');
        const loadingPercent = document.getElementById('loading-percent');
        
        const loader = new THREE.GLTFLoader();
        const totalModels = GLTF_MODEL_URLS.length;
        let loadedBytes = [0, 0, 0, 0];
        
        // 加载所有模型
        GLTF_MODEL_URLS.forEach((url, index) => {
            loader.load(
                url,
                (gltf) => {
                    console.log(`GLTF模型${index + 1}加载成功!`, url);
                    const model = gltf.scene;
                    
                    // 计算模型边界框来确定合适的缩放
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const targetSize = 3; // 目标大小
                    const scale = targetSize / maxDim;
                    
                    model.scale.set(scale, scale, scale);
                    
                    // 重新计算边界框并居中模型
                    const newBox = new THREE.Box3().setFromObject(model);
                    const center = newBox.getCenter(new THREE.Vector3());
                    model.position.sub(center);
                    model.position.y = 0;
                    
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            if (child.material) {
                                const processMaterial = (m) => {
                                    m.side = THREE.DoubleSide;
                                    if (m.map) m.map.encoding = THREE.sRGBEncoding;
                                    if (m.emissiveMap) m.emissiveMap.encoding = THREE.sRGBEncoding;
                                    m.envMapIntensity = 0.3;
                                };
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(processMaterial);
                                } else {
                                    processMaterial(child.material);
                                }
                            }
                        }
                    });
                    
                    gltfModelTemplates[index] = model;
                    modelsLoaded++;
                    console.log(`模型${index + 1}处理完成，已加载 ${modelsLoaded}/${totalModels}`);
                    
                    // 所有模型加载完成后隐藏加载提示
                    if (modelsLoaded >= totalModels) {
                        loadingOverlay.classList.add('hidden');
                    }
                },
                (progress) => {
                    loadedBytes[index] = progress.loaded;
                    const totalLoaded = loadedBytes.reduce((a, b) => a + b, 0);
                    const mb = (totalLoaded / 1024 / 1024).toFixed(1);
                    loadingPercent.textContent = `已加载 ${mb} MB (${modelsLoaded}/${totalModels})`;
                },
                (error) => {
                    console.warn(`GLTF模型${index + 1}加载失败:`, error.message);
                    modelsLoaded++;
                    if (modelsLoaded >= totalModels) {
                        loadingOverlay.classList.add('hidden');
                    }
                }
            );
        });
        
        // 60秒超时
        setTimeout(() => {
            if (modelsLoaded < totalModels) {
                loadingOverlay.classList.add('hidden');
                console.log('模型加载超时，使用已加载的模型');
            }
        }, 60000);
        
        // 加载童话山模型（边缘装饰）
        loader.load(
            'Level/童话城堡/童话山.glb',
            (gltf) => {
                console.log('童话山模型加载成功!');
                const model = gltf.scene;
                
                // 计算模型边界框来确定合适的缩放
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const targetSize = 4; // 边缘墙目标大小
                const scale = targetSize / maxDim;
                
                model.scale.set(scale, scale, scale);
                
                // 重新计算边界框并居中模型
                const newBox = new THREE.Box3().setFromObject(model);
                const center = newBox.getCenter(new THREE.Vector3());
                model.position.sub(center);
                model.position.y = 0;
                
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            const processMaterial = (m) => {
                                m.side = THREE.DoubleSide;
                                if (m.map) m.map.encoding = THREE.sRGBEncoding;
                                if (m.emissiveMap) m.emissiveMap.encoding = THREE.sRGBEncoding;
                                // 确保材质能正确响应光照
                                m.metalness = m.metalness !== undefined ? m.metalness : 0.1;
                                m.roughness = m.roughness !== undefined ? m.roughness : 0.8;
                                m.envMapIntensity = 0.5;
                                m.needsUpdate = true;
                            };
                            if (Array.isArray(child.material)) {
                                child.material.forEach(processMaterial);
                            } else {
                                processMaterial(child.material);
                            }
                        }
                    }
                });
                
                fairyMountainModel = model;
                console.log('童话山模型处理完成');
            },
            null,
            (error) => {
                console.warn('童话山模型加载失败:', error.message);
            }
        );
    }
    
    // 克隆童话山模型
    function cloneFairyMountainModel() {
        if (!fairyMountainModel) {
            return null;
        }
        
        const clone = fairyMountainModel.clone(true);
        clone.scale.copy(fairyMountainModel.scale);
        
        // 克隆材质并确保光照属性正确
        clone.traverse((child) => {
            if (child.isMesh && child.material) {
                if (Array.isArray(child.material)) {
                    child.material = child.material.map(m => {
                        const cloned = m.clone();
                        cloned.needsUpdate = true;
                        return cloned;
                    });
                } else {
                    child.material = child.material.clone();
                    child.material.needsUpdate = true;
                }
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });
        
        return clone;
    }
    
    // 克隆GLTF模型（根据玩家ID选择对应模型）
    function cloneGLTFModel(playerIndex = 0) {
        const template = gltfModelTemplates[playerIndex] || gltfModelTemplates[0];
        if (!template) {
            console.log('模型模板不存在，使用默认模型');
            return null;
        }
        
        // 深度克隆模型
        const clone = template.clone(true);
        
        // 保持原始缩放
        clone.scale.copy(template.scale);
        
        // 克隆材质（保持原始颜色）
        clone.traverse((child) => {
            if (child.isMesh && child.material) {
                if (Array.isArray(child.material)) {
                    child.material = child.material.map(m => m.clone());
                } else {
                    child.material = child.material.clone();
                }
            }
        });
        
        // 保存原始缩放值用于跳跃动画
        clone.userData = {
            isGLTF: true,
            originalScaleX: clone.scale.x,
            originalScaleY: clone.scale.y,
            originalScaleZ: clone.scale.z
        };
        
        console.log(`克隆模型${playerIndex + 1}成功`);
        return clone;
    }

    function initColorSelectors() {
        const p1Colors = document.getElementById('colors-p1');
        const p2Colors = document.getElementById('colors-p2');
        
        KUIKLY_COLORS.forEach((color, i) => {
            const dot1 = document.createElement('div');
            dot1.className = 'color-dot';
            dot1.style.backgroundColor = '#' + color.hex.toString(16).padStart(6, '0');
            dot1.id = `p1-color-${i}`;
            p1Colors.appendChild(dot1);
            
            const dot2 = document.createElement('div');
            dot2.className = 'color-dot';
            dot2.style.backgroundColor = '#' + color.hex.toString(16).padStart(6, '0');
            dot2.id = `p2-color-${i}`;
            p2Colors.appendChild(dot2);
        });
        
        updateColorSelection();
    }

    function updateColorSelection() {
        // 更新P1
        const c1 = KUIKLY_COLORS[p1Selection.colorIndex];
        const hex1 = '#' + c1.hex.toString(16).padStart(6, '0');
        document.getElementById('preview-p1').style.backgroundColor = hex1;
        document.getElementById('preview-p1').style.boxShadow = `0 0 30px ${hex1}`;
        document.getElementById('title-p1').style.color = hex1;
        
        // 更新P2
        const c2 = KUIKLY_COLORS[p2Selection.colorIndex];
        const hex2 = '#' + c2.hex.toString(16).padStart(6, '0');
        document.getElementById('preview-p2').style.backgroundColor = hex2;
        document.getElementById('preview-p2').style.boxShadow = `0 0 30px ${hex2}`;
        document.getElementById('title-p2').style.color = hex2;
        
        // 更新颜色点
        KUIKLY_COLORS.forEach((_, i) => {
            document.getElementById(`p1-color-${i}`).classList.toggle('active', i === p1Selection.colorIndex);
            document.getElementById(`p2-color-${i}`).classList.toggle('active', i === p2Selection.colorIndex);
        });
    }

    // ==================== 酷比角色模型 - 优化版 ====================
    function createKuiklyModel(colorHex, playerIndex = 0) {
        // 尝试使用GLTF模型（根据玩家索引选择对应模型）
        const gltfClone = cloneGLTFModel(playerIndex);
        if (gltfClone) {
            // userData 已在 cloneGLTFModel 中设置
            return gltfClone;
        }
        
        // 如果GLTF加载失败，使用默认模型
        const defaultColor = colorHex || 0x00aaff; // 默认蓝色
        const group = new THREE.Group();
        
        // 使用缓存材质
        const mainMat = MatCache.get(defaultColor, { roughness: 0.4, metalness: 0.1 });
        const faceMat = MatCache.get(0xffe4d0, { roughness: 0.7 });
        const eyeMat = MatCache.get(0x222222, { roughness: 0.3 });
        const whiteMat = MatCache.get(0xffffff, { emissive: 0xffffff, emissiveIntensity: 0.3 });
        
        // 头部组 - 降低面数
        const headGroup = new THREE.Group();
        headGroup.position.y = 2.2;
        
        const helmet = new THREE.Mesh(GeoCache.getSphere(1.0, 12), mainMat);
        helmet.scale.set(1, 0.9, 0.95);
        helmet.castShadow = true;
        headGroup.add(helmet);
        
        const leftEar = new THREE.Mesh(GeoCache.getSphere(0.35, 8), mainMat);
        leftEar.position.set(-0.8, 0.5, 0);
        headGroup.add(leftEar);
        
        const rightEar = new THREE.Mesh(GeoCache.getSphere(0.35, 8), mainMat);
        rightEar.position.set(0.8, 0.5, 0);
        headGroup.add(rightEar);
        
        const face = new THREE.Mesh(GeoCache.getSphere(0.6, 12), faceMat);
        face.position.set(0, -0.1, 0.5);
        face.scale.set(1, 1, 0.5);
        headGroup.add(face);
        
        const leftEye = new THREE.Mesh(GeoCache.getSphere(0.15, 8), eyeMat);
        leftEye.position.set(-0.22, 0, 0.85);
        headGroup.add(leftEye);
        
        const leftEyeHL = new THREE.Mesh(GeoCache.getSphere(0.05, 4), whiteMat);
        leftEyeHL.position.set(-0.25, 0.05, 0.92);
        headGroup.add(leftEyeHL);
        
        const rightEye = new THREE.Mesh(GeoCache.getSphere(0.15, 8), eyeMat);
        rightEye.position.set(0.22, 0, 0.85);
        headGroup.add(rightEye);
        
        const rightEyeHL = new THREE.Mesh(GeoCache.getSphere(0.05, 4), whiteMat);
        rightEyeHL.position.set(0.19, 0.05, 0.92);
        headGroup.add(rightEyeHL);
        
        group.add(headGroup);
        
        // 身体
        const bodyGroup = new THREE.Group();
        bodyGroup.position.y = 1.1;
        
        const bodyCyl = new THREE.Mesh(GeoCache.getCylinder(0.45, 0.45, 0.6, 10), mainMat);
        bodyCyl.castShadow = true;
        bodyGroup.add(bodyCyl);
        
        const bodyTop = new THREE.Mesh(GeoCache.getSphere(0.45, 10), mainMat);
        bodyTop.position.y = 0.3;
        bodyGroup.add(bodyTop);
        
        const bodyBottom = new THREE.Mesh(GeoCache.getSphere(0.45, 10), mainMat);
        bodyBottom.position.y = -0.3;
        bodyGroup.add(bodyBottom);
        
        group.add(bodyGroup);
        
        // 手臂 - 简化
        const leftArmGroup = new THREE.Group();
        leftArmGroup.position.set(-0.55, 1.3, 0);
        const leftArm = new THREE.Mesh(GeoCache.getSphere(0.2, 8), mainMat);
        leftArm.scale.set(1, 1.3, 1);
        leftArmGroup.add(leftArm);
        const leftHand = new THREE.Mesh(GeoCache.getSphere(0.15, 6), mainMat);
        leftHand.position.set(-0.1, -0.25, 0);
        leftArmGroup.add(leftHand);
        group.add(leftArmGroup);
        
        const rightArmGroup = new THREE.Group();
        rightArmGroup.position.set(0.55, 1.3, 0);
        const rightArm = new THREE.Mesh(GeoCache.getSphere(0.2, 8), mainMat);
        rightArm.scale.set(1, 1.3, 1);
        rightArmGroup.add(rightArm);
        const rightHand = new THREE.Mesh(GeoCache.getSphere(0.15, 6), mainMat);
        rightHand.position.set(0.1, -0.25, 0);
        rightArmGroup.add(rightHand);
        group.add(rightArmGroup);
        
        // 腿 - 简化
        const leftLegGroup = new THREE.Group();
        leftLegGroup.position.set(-0.2, 0.4, 0);
        const leftLeg = new THREE.Mesh(GeoCache.getCylinder(0.15, 0.15, 0.4, 6), mainMat);
        leftLegGroup.add(leftLeg);
        const leftFoot = new THREE.Mesh(GeoCache.getSphere(0.18, 6), mainMat);
        leftFoot.position.set(0, -0.25, 0.05);
        leftFoot.scale.set(0.9, 0.6, 1.2);
        leftLegGroup.add(leftFoot);
        group.add(leftLegGroup);
        
        const rightLegGroup = new THREE.Group();
        rightLegGroup.position.set(0.2, 0.4, 0);
        const rightLeg = new THREE.Mesh(GeoCache.getCylinder(0.15, 0.15, 0.4, 6), mainMat);
        rightLegGroup.add(rightLeg);
        const rightFoot = new THREE.Mesh(GeoCache.getSphere(0.18, 6), mainMat);
        rightFoot.position.set(0, -0.25, 0.05);
        rightFoot.scale.set(0.9, 0.6, 1.2);
        rightLegGroup.add(rightFoot);
        group.add(rightLegGroup);
        
        group.userData = {
            head: headGroup,
            leftArm: leftArmGroup,
            rightArm: rightArmGroup,
            leftLeg: leftLegGroup,
            rightLeg: rightLegGroup
        };
        
        return group;
    }

    // ==================== 玩家类 ====================
    class Player {
        constructor(id, colorHex, startX, startZ, isAI = false) {
            this.id = id;
            this.isAI = isAI;
            this.isDead = false;
            
            // 位置
            this.gridX = startX;
            this.gridZ = startZ;
            
            // 属性
            this.speed = 10;
            this.speedLevel = 0;
            this.maxSpeed = 3;
            
            this.range = 1;
            this.rangeLevel = 0;
            this.maxRange = 4;
            
            this.maxBombs = 1;
            this.bombLevel = 0;
            this.maxBombLevel = 3;
            this.activeBombs = 0;
            
            this.canKick = false;
            
            // 武器系统
            this.weapon = null;      // 当前武器类型
            this.weaponAmmo = 0;     // 武器弹药数（2发）
            this.isUsingWeapon = false; // 是否正在使用武器（激光/喷火时不能移动）
            this.lastPortalGrid = null; // 上次传送到达的格子位置
            this.isFlying = false; // 是否被龙卷风抛飞
            
            // 创建模型（传入玩家索引，id从1开始，索引从0开始）
            this.mesh = createKuiklyModel(colorHex, id - 1);
            this.isGLTFModel = this.mesh.userData && this.mesh.userData.isGLTF;
            
            // 根据模型类型调整缩放
            if (this.isGLTFModel) {
                this.mesh.scale.set(1, 1, 1); // GLTF模型已在加载时缩放好
            } else {
                this.mesh.scale.set(1.2, 1.2, 1.2); // 默认模型缩放
            }
            
            const worldPos = gridToWorld(startX, startZ);
            this.mesh.position.set(worldPos.x, 0.3, worldPos.z);
            
            scene.add(this.mesh);
            
            // 为真人玩家添加1P/2P标记
            if (!isAI) {
                this.createPlayerLabel();
            }
            
            // 输入
            this.input = { x: 0, z: 0, bomb: false };
            
            // 转向状态
            this.isTurning = false;
            this.targetTurnAngle = 0; // 目标转向角度
            this.lastInputX = 0;
            this.lastInputZ = 0;
            
            // 动画
            this.walkTime = 0;
            this.bombAnimTime = 0;
            
            // AI
            this.aiTimer = 0;
            this.aiTarget = null;
        }
        
        update(dt) {
            if (this.isDead) return;
            
            // 飞行中不更新移动逻辑
            if (this.isFlying) return;
            
            // 检查是否离开了传送门格子（用于重置传送门状态）
            if (this.lastPortalGrid) {
                if (this.gridX !== this.lastPortalGrid.x || this.gridZ !== this.lastPortalGrid.z) {
                    this.lastPortalGrid = null; // 离开了传送门格子，可以再次传送
                }
            }
            
            // 使用武器时不能移动（激光枪、喷火枪）
            if (this.isUsingWeapon) {
                this.input.x = 0;
                this.input.z = 0;
                return;
            }
            
            if (this.isAI) {
                this.updateAI(dt);
            }
            
            let moving = false;
            
            // 四个主方向的角度（上、右、下、左）
            const DIRECTION_ANGLES = {
                UP: 0,           // Z+方向
                RIGHT: Math.PI / 2,   // X+方向
                DOWN: Math.PI,        // Z-方向
                LEFT: -Math.PI / 2    // X-方向
            };
            
            // 根据输入获取标准方向角度
            const getDirectionAngle = (inputX, inputZ) => {
                if (inputX > 0) return DIRECTION_ANGLES.RIGHT;
                if (inputX < 0) return DIRECTION_ANGLES.LEFT;
                if (inputZ > 0) return DIRECTION_ANGLES.UP;
                if (inputZ < 0) return DIRECTION_ANGLES.DOWN;
                return null;
            };
            
            // 简化的格子移动
            if (this.input.x !== 0 || this.input.z !== 0) {
                moving = true;
                
                const moveSpeed = this.speed + this.speedLevel * 2;
                const currentCenter = gridToWorld(this.gridX, this.gridZ);
                
                // 获取当前输入对应的标准方向角度
                const targetAngle = getDirectionAngle(this.input.x, this.input.z);
                
                // 检测方向是否改变（只有不在转向中时才检测新的转向）
                const directionChanged = (this.input.x !== this.lastInputX || this.input.z !== this.lastInputZ) &&
                                         (this.lastInputX !== 0 || this.lastInputZ !== 0);
                
                if (directionChanged && !this.isTurning) {
                    this.isTurning = true;
                    // 记录目标转向角度（标准四方向）
                    this.targetTurnAngle = targetAngle;
                }
                
                this.lastInputX = this.input.x;
                this.lastInputZ = this.input.z;
                
                // 如果正在转向，必须完成转向
                if (this.isTurning) {
                    // 直接设置为目标角度
                    this.mesh.rotation.y = this.targetTurnAngle;
                    
                    // 转向完成
                    this.isTurning = false;
                    
                    // 转向时对齐到当前格子中心
                    const dx = currentCenter.x - this.mesh.position.x;
                    const dz = currentCenter.z - this.mesh.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist > 0.1) {
                        const step = moveSpeed * dt;
                        this.mesh.position.x += (dx / dist) * Math.min(step, Math.abs(dx));
                        this.mesh.position.z += (dz / dist) * Math.min(step, Math.abs(dz));
                    }
                } else {
                    // 正常移动 - 直接设置为标准方向角度
                    if (targetAngle !== null) {
                        this.mesh.rotation.y = targetAngle;
                    }
                
                    // 计算目标格子
                    let targetGridX = this.gridX;
                    let targetGridZ = this.gridZ;
                    
                    // 只允许一个方向移动（优先X方向）
                    if (this.input.x !== 0) {
                        targetGridX = this.gridX + Math.sign(this.input.x);
                    } else if (this.input.z !== 0) {
                        targetGridZ = this.gridZ + Math.sign(this.input.z);
                    }
                    
                    // 检查目标格子是否可通行
                    if (this.canMoveTo(targetGridX, targetGridZ)) {
                        const targetCenter = gridToWorld(targetGridX, targetGridZ);
                        
                        // 向目标格子中心移动
                        const dx = targetCenter.x - this.mesh.position.x;
                        const dz = targetCenter.z - this.mesh.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        if (dist > 0.1) {
                            const step = moveSpeed * dt;
                            if (step >= dist) {
                                this.mesh.position.x = targetCenter.x;
                                this.mesh.position.z = targetCenter.z;
                            } else {
                                this.mesh.position.x += (dx / dist) * step;
                                this.mesh.position.z += (dz / dist) * step;
                            }
                        }
                    } else {
                        // 目标不可通行，对齐到当前格子中心
                        const dx = currentCenter.x - this.mesh.position.x;
                        const dz = currentCenter.z - this.mesh.position.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        if (dist > 0.1) {
                            const step = moveSpeed * dt;
                            this.mesh.position.x += (dx / dist) * Math.min(step, Math.abs(dx));
                            this.mesh.position.z += (dz / dist) * Math.min(step, Math.abs(dz));
                        }
                    }
                }
                
                // 踢炸弹
                if (this.canKick) {
                    this.tryKickBomb();
                }
            } else {
                // 没有输入时重置转向状态
                this.lastInputX = 0;
                this.lastInputZ = 0;
                this.isTurning = false;
            }
            
            // 更新网格位置
            const currentGrid = worldToGrid(this.mesh.position.x, this.mesh.position.z);
            this.gridX = currentGrid.x;
            this.gridZ = currentGrid.z;
            
            // 检查道具
            this.checkPowerup();
            
            // 检查传送门
            checkPortalTeleport(this);
            
            // 放炸弹 - 无论是否成功都清除输入，防止预存
            if (this.input.bomb) {
                if (this.activeBombs < this.maxBombs) {
                    this.placeBomb();
                }
                this.input.bomb = false;
            }
            
            // 动画
            this.updateAnimation(dt, moving);
        }
        
        updateAnimation(dt, moving) {
            const parts = this.mesh.userData;
            
            // GLTF模型使用跳跃动画
            if (parts && parts.isGLTF) {
                // 初始化跳跃动画状态
                if (this.jumpPhase === undefined) {
                    this.jumpPhase = 0;
                    this.baseY = this.mesh.position.y;
                }
                
                if (moving) {
                    // 跳跃动画 - 使用正弦波模拟连续跳跃
                    this.jumpPhase += dt * 12; // 跳跃速度
                    const jumpHeight = Math.abs(Math.sin(this.jumpPhase)) * 0.8; // 跳跃高度
                    this.mesh.position.y = this.baseY + jumpHeight;
                    
                    // 轻微的缩放效果（落地时压缩）
                    const squash = 1 - Math.abs(Math.sin(this.jumpPhase)) * 0.1;
                    const stretch = 1 + Math.abs(Math.sin(this.jumpPhase)) * 0.05;
                    this.mesh.scale.y = this.mesh.userData.originalScaleY * squash;
                    this.mesh.scale.x = this.mesh.userData.originalScaleX * stretch;
                    this.mesh.scale.z = this.mesh.userData.originalScaleZ * stretch;
                } else {
                    // 停止时平滑回到地面
                    this.jumpPhase = 0;
                    this.mesh.position.y += (this.baseY - this.mesh.position.y) * dt * 10;
                    
                    // 恢复原始缩放
                    if (this.mesh.userData.originalScaleY) {
                        this.mesh.scale.y += (this.mesh.userData.originalScaleY - this.mesh.scale.y) * dt * 10;
                        this.mesh.scale.x += (this.mesh.userData.originalScaleX - this.mesh.scale.x) * dt * 10;
                        this.mesh.scale.z += (this.mesh.userData.originalScaleZ - this.mesh.scale.z) * dt * 10;
                    }
                }
                return;
            }
            
            if (!parts) return;
            
            // 默认模型的放炸弹动作
            if (this.bombAnimTime > 0) {
                this.bombAnimTime -= dt;
                const progress = 1 - (this.bombAnimTime / 0.4);
                
                if (progress < 0.3) {
                    // 举起双手
                    const lift = progress / 0.3;
                    parts.leftArm.rotation.x = -Math.PI * 0.6 * lift;
                    parts.rightArm.rotation.x = -Math.PI * 0.6 * lift;
                    parts.leftArm.rotation.z = -0.3 * lift;
                    parts.rightArm.rotation.z = 0.3 * lift;
                } else if (progress < 0.6) {
                    // 保持举起
                    parts.leftArm.rotation.x = -Math.PI * 0.6;
                    parts.rightArm.rotation.x = -Math.PI * 0.6;
                    parts.leftArm.rotation.z = -0.3;
                    parts.rightArm.rotation.z = 0.3;
                } else {
                    // 放下动作
                    const drop = (progress - 0.6) / 0.4;
                    parts.leftArm.rotation.x = -Math.PI * 0.6 * (1 - drop);
                    parts.rightArm.rotation.x = -Math.PI * 0.6 * (1 - drop);
                    parts.leftArm.rotation.z = -0.3 * (1 - drop);
                    parts.rightArm.rotation.z = 0.3 * (1 - drop);
                }
                
                // 头部点头
                parts.head.rotation.x = Math.sin(progress * Math.PI) * 0.2;
                return;
            }
            
            // 重置状态
            const lerp = dt * 8;
            parts.leftArm.rotation.x *= (1 - lerp);
            parts.rightArm.rotation.x *= (1 - lerp);
            parts.leftArm.rotation.z *= (1 - lerp);
            parts.rightArm.rotation.z *= (1 - lerp);
            parts.head.rotation.x *= (1 - lerp);
        }
        
        canMoveTo(gx, gz) {
            if (gx < 0 || gx >= CONFIG.GRID_WIDTH || gz < 0 || gz >= CONFIG.GRID_HEIGHT) return false;
            
            const tile = grid[gz][gx];
            if (tile === TILE.WALL || tile === TILE.CRATE || tile === TILE.TREASURE) return false;
            
            // 检查水池区域（中央3x3不可通行）
            if (isWaterTrapArea(gx, gz)) return false;
            
            // 检查炸弹
            const bombHere = bombs.find(b => b.gridX === gx && b.gridZ === gz);
            if (bombHere) {
                // 如果是自己所在的格子，可以通过
                if (this.gridX === gx && this.gridZ === gz) return true;
                return false;
            }
            
            return true;
        }
        
        tryKickBomb() {
            let kickDir = { x: 0, z: 0 };
            if (Math.abs(this.input.x) > Math.abs(this.input.z)) {
                kickDir.x = Math.sign(this.input.x);
            } else {
                kickDir.z = Math.sign(this.input.z);
            }
            
            const targetX = this.gridX + kickDir.x;
            const targetZ = this.gridZ + kickDir.z;
            
            const bomb = bombs.find(b => b.gridX === targetX && b.gridZ === targetZ && !b.moving);
            if (bomb) {
                const nextX = targetX + kickDir.x;
                const nextZ = targetZ + kickDir.z;
                if (canBombMoveTo(nextX, nextZ)) {
                    bomb.moving = true;
                    bomb.velocity = { x: kickDir.x, z: kickDir.z };
                    soundManager.playKick();
                }
            }
        }
        
        checkPowerup() {
            const idx = powerups.findIndex(p => p.gridX === this.gridX && p.gridZ === this.gridZ);
            if (idx !== -1) {
                const powerup = powerups[idx];
                
                // 只有玩家拾取道具才播放音效
                if (!this.isAI) {
                    soundManager.playPowerup();
                }
                
                switch (powerup.type) {
                    case POWERUP.SPEED:
                        if (this.speedLevel < this.maxSpeed) this.speedLevel++;
                        break;
                    case POWERUP.RANGE:
                        if (this.rangeLevel < this.maxRange) {
                            this.rangeLevel++;
                            this.range = 1 + this.rangeLevel;
                        }
                        break;
                    case POWERUP.BOMB:
                        if (this.bombLevel < this.maxBombLevel) {
                            this.bombLevel++;
                            this.maxBombs = 1 + this.bombLevel;
                        }
                        break;
                    case POWERUP.KICK:
                        this.canKick = true;
                        break;
                    // 武器道具
                    case POWERUP.LASER:
                        this.weapon = WEAPON.LASER;
                        this.weaponAmmo = 2;
                        break;
                    case POWERUP.FLAMETHROWER:
                        this.weapon = WEAPON.FLAMETHROWER;
                        this.weaponAmmo = 2;
                        break;
                    case POWERUP.ROCKET:
                        this.weapon = WEAPON.ROCKET;
                        this.weaponAmmo = 2;
                        break;
                }
                
                scene.remove(powerup.mesh);
                powerups.splice(idx, 1);
                updateHUD();
            }
        }
        
        createPlayerLabel() {
            // 创建Canvas绘制1P/2P标记
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // 清除画布
            ctx.clearRect(0, 0, 128, 64);
            
            // 绘制背景圆角矩形
            const labelText = this.id === 1 ? '1P' : '2P';
            const bgColor = this.id === 1 ? '#00aaff' : '#ff6699';
            
            ctx.fillStyle = bgColor;
            ctx.beginPath();
            ctx.roundRect(14, 8, 100, 48, 12);
            ctx.fill();
            
            // 绘制边框
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 4;
            ctx.stroke();
            
            // 绘制文字
            ctx.font = 'bold 36px "Press Start 2P", "Arial Black", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(labelText, 64, 34);
            
            // 创建纹理和精灵
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            const spriteMat = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false,
                depthWrite: false
            });
            
            this.labelSprite = new THREE.Sprite(spriteMat);
            this.labelSprite.scale.set(1.5, 0.75, 1);
            this.labelSprite.position.set(0, 4.5, 0); // 放在角色头顶上方
            this.labelSprite.renderOrder = 1000;
            
            this.mesh.add(this.labelSprite);
        }
        
        placeBomb() {
            // 如果有武器弹药，使用武器
            if (this.weapon && this.weaponAmmo > 0) {
                this.useWeapon();
                return;
            }
            
            if (bombs.some(b => b.gridX === this.gridX && b.gridZ === this.gridZ)) return;
            
            const bomb = new Bomb(this.gridX, this.gridZ, this.range, this);
            bombs.push(bomb);
            this.activeBombs++;
            
            // 播放放炸弹音效
            soundManager.playBombPlace();
            
            // 触发放炸弹动画
            this.bombAnimTime = 0.4;
        }
        
        useWeapon() {
            // AI使用存储的方向，玩家使用当前朝向
            let dirX = 0, dirZ = 0;
            
            if (this.isAI && this.aiWeaponDir) {
                // AI使用预先计算的方向
                dirX = this.aiWeaponDir.x;
                dirZ = this.aiWeaponDir.z;
                this.aiWeaponDir = null; // 清除存储的方向
            } else {
                // 玩家使用当前朝向
                const direction = {
                    x: Math.sin(this.mesh.rotation.y),
                    z: Math.cos(this.mesh.rotation.y)
                };
                
                // 标准化方向到四个主方向
                if (Math.abs(direction.x) > Math.abs(direction.z)) {
                    dirX = direction.x > 0 ? 1 : -1;
                } else {
                    dirZ = direction.z > 0 ? 1 : -1;
                }
            }
            
            switch (this.weapon) {
                case WEAPON.LASER:
                    fireLaser(this.gridX, this.gridZ, dirX, dirZ, this);
                    break;
                case WEAPON.FLAMETHROWER:
                    fireFlamethrower(this.gridX, this.gridZ, dirX, dirZ, this);
                    break;
                case WEAPON.ROCKET:
                    fireRocket(this.gridX, this.gridZ, dirX, dirZ, this);
                    break;
            }
            
            this.weaponAmmo--;
            if (this.weaponAmmo <= 0) {
                this.weapon = null;
            }
            
            updateHUD();
        }
        
        die() {
            if (this.isDead) return;
            this.isDead = true;
            
            // 播放死亡音效
            soundManager.playDeath();
            
            // 直接移除模型
            scene.remove(this.mesh);
            
            // 更新HUD
            const hudId = ['p1', 'p2', 'ai1', 'ai2'][this.id - 1];
            document.getElementById(`hud-${hudId}`).classList.add('hud-dead');
            
            checkGameOver();
        }
        
        updateAI(dt) {
            this.aiTimer -= dt;
            if (this.aiTimer > 0) return;
            this.aiTimer = 0.15 + Math.random() * 0.1; // 决策间隔更短，反应更快
            
            // 初始化AI状态
            if (this.aiState === undefined) {
                this.aiState = 'wander';
                this.aiTargetX = -1;
                this.aiTargetZ = -1;
                this.moveDirection = null;
                this.directionLockTimer = 0;
                this.idleCounter = 0; // 空闲计数器，防止踱步
                this.waitTimer = 0; // 等待计时器（放炸弹后等待）
                this.positionHistory = []; // 位置历史，用于检测来回踱步
                this.stuckCounter = 0; // 卡住计数器
            }
            
            // 记录位置历史（每次决策时记录）
            const currentPosKey = `${this.gridX},${this.gridZ}`;
            this.positionHistory.push(currentPosKey);
            if (this.positionHistory.length > 10) {
                this.positionHistory.shift();
            }
            
            // 检测是否在来回踱步（同一位置出现3次以上）
            const positionCounts = {};
            for (const pos of this.positionHistory) {
                positionCounts[pos] = (positionCounts[pos] || 0) + 1;
            }
            const maxCount = Math.max(...Object.values(positionCounts));
            if (maxCount >= 4) {
                this.stuckCounter++;
                if (this.stuckCounter >= 2) {
                    // 强制探索新区域
                    this.positionHistory = [];
                    this.stuckCounter = 0;
                    this.forceExplore();
                    return;
                }
            } else {
                this.stuckCounter = 0;
            }
            
            // 方向锁定计时器递减
            if (this.directionLockTimer > 0) {
                this.directionLockTimer -= 0.15;
            }
            
            // 等待计时器递减
            if (this.waitTimer > 0) {
                this.waitTimer -= 0.15;
                // 等待时停止移动
                this.input.x = 0;
                this.input.z = 0;
                this.input.bomb = false;
                // 但如果有危险，立即打断等待
                const danger = this.checkDanger();
                if (danger) {
                    this.waitTimer = 0;
                    this.aiState = 'escape';
                    this.escapeFromDanger(danger);
                }
                return;
            }
            
            // 检查危险 - 最高优先级
            const danger = this.checkDanger();
            if (danger) {
                this.input.bomb = false;
                this.aiState = 'escape';
                this.idleCounter = 0;
                this.escapeFromDanger(danger);
                return;
            }
            
            // 如果当前有移动方向且方向被锁定，继续移动
            if (this.moveDirection && this.directionLockTimer > 0) {
                if (this.canMoveTo(this.gridX + this.moveDirection.x, this.gridZ + this.moveDirection.z)) {
                    this.input.x = this.moveDirection.x;
                    this.input.z = this.moveDirection.z;
                    return;
                } else {
                    // 方向被阻挡，解除锁定
                    this.directionLockTimer = 0;
                    this.moveDirection = null;
                }
            }
            
            // 如果有武器，检查是否有目标可以攻击
            if (this.weapon && this.weaponAmmo > 0) {
                // 先检查当前位置是否有目标
                if (this.shouldUseWeapon()) {
                    this.input.x = 0;
                    this.input.z = 0;
                    this.input.bomb = true;
                    this.aiState = 'attack';
                    this.idleCounter = 0;
                    return;
                }
                // 没有目标，主动寻找可以使用武器的位置
                const weaponTarget = this.findWeaponAttackPosition();
                if (weaponTarget) {
                    this.aiState = 'hunt_weapon';
                    this.moveToward(weaponTarget.x, weaponTarget.z);
                    return;
                }
            }
            
            // 主动攻击 - 如果能安全放炸弹且有目标，就放！
            if (this.shouldAttack() && this.canPlaceBombSafely()) {
                this.input.x = 0;
                this.input.z = 0;
                this.input.bomb = true;
                this.aiState = 'attack';
                this.idleCounter = 0;
                // 放炸弹后，进入等待状态（在安全位置等待爆炸）
                this.waitTimer = 0.5 + Math.random() * 0.3;
                return;
            }
            
            // 如果当前位置安全，且附近有自己的炸弹，可以原地等待
            if (this.isSafePosition(this.gridX, this.gridZ) && this.hasOwnBombNearby()) {
                this.input.x = 0;
                this.input.z = 0;
                this.input.bomb = false;
                this.aiState = 'wait';
                return;
            }
            
            // 寻找道具（降低优先级，只有附近有道具才去捡）
            const nearPowerup = this.findNearestPowerup();
            if (nearPowerup) {
                const dist = Math.abs(nearPowerup.gridX - this.gridX) + Math.abs(nearPowerup.gridZ - this.gridZ);
                // 只有道具很近（4格内）或者没有其他目标时才去捡
                if (dist <= 4) {
                    this.aiState = 'collect';
                    this.aiTargetX = nearPowerup.gridX;
                    this.aiTargetZ = nearPowerup.gridZ;
                    this.idleCounter = 0;
                    this.moveToward(nearPowerup.gridX, nearPowerup.gridZ);
                    return;
                }
            }
            
            // 寻找目标（箱子或敌人）并主动靠近
            const target = this.findTarget();
            if (target) {
                this.aiState = 'hunt';
                this.aiTargetX = target.x;
                this.aiTargetZ = target.z;
                this.idleCounter = 0;
                this.moveToward(target.x, target.z);
                return;
            }
            
            // 如果远处有道具，去捡
            if (nearPowerup) {
                this.aiState = 'collect';
                this.aiTargetX = nearPowerup.gridX;
                this.aiTargetZ = nearPowerup.gridZ;
                this.idleCounter = 0;
                this.moveToward(nearPowerup.gridX, nearPowerup.gridZ);
                return;
            }
            
            // 如果当前位置安全，可以停下来观察
            if (this.isSafePosition(this.gridX, this.gridZ) && Math.random() < 0.3) {
                this.input.x = 0;
                this.input.z = 0;
                this.aiState = 'idle';
                return;
            }
            
            // 漫游 - 但要检测是否在踱步
            this.idleCounter++;
            if (this.idleCounter > 8) {
                // 踱步太久了，强制找个方向走远一点
                this.forceExplore();
                this.idleCounter = 0;
            } else {
                this.aiState = 'wander';
                this.smartWander();
            }
        }
        
        // 检查附近是否有自己放的炸弹
        hasOwnBombNearby() {
            for (const bomb of bombs) {
                if (bomb.owner === this) {
                    const dist = Math.abs(bomb.gridX - this.gridX) + Math.abs(bomb.gridZ - this.gridZ);
                    if (dist <= this.range + 1) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // 寻找可以使用武器攻击的位置
        findWeaponAttackPosition() {
            const weaponRange = this.weapon === WEAPON.FLAMETHROWER ? 3 : 
                               this.weapon === WEAPON.ROCKET ? 10 : 15;
            
            // 寻找附近的目标（箱子或敌人）
            let bestTarget = null;
            let minDist = 8;
            
            // 优先寻找敌人
            for (const p of players) {
                if (p.isDead || p.id === this.id) continue;
                const dist = Math.abs(p.gridX - this.gridX) + Math.abs(p.gridZ - this.gridZ);
                if (dist < minDist && dist <= weaponRange + 2) {
                    // 检查是否可以从某个位置攻击到这个敌人
                    const attackPos = this.findPositionToAttack(p.gridX, p.gridZ, weaponRange);
                    if (attackPos) {
                        minDist = dist;
                        bestTarget = attackPos;
                    }
                }
            }
            
            // 其次寻找箱子
            if (!bestTarget) {
                for (let z = 0; z < CONFIG.GRID_HEIGHT; z++) {
                    for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                        if (grid[z][x] === TILE.CRATE || grid[z][x] === TILE.TREASURE) {
                            const dist = Math.abs(x - this.gridX) + Math.abs(z - this.gridZ);
                            if (dist < minDist && dist <= weaponRange + 2) {
                                const attackPos = this.findPositionToAttack(x, z, weaponRange);
                                if (attackPos) {
                                    minDist = dist;
                                    bestTarget = attackPos;
                                }
                            }
                        }
                    }
                }
            }
            
            return bestTarget;
        }
        
        // 找到可以攻击目标的位置
        findPositionToAttack(targetX, targetZ, range) {
            const dirs = [
                { x: 1, z: 0 }, { x: -1, z: 0 },
                { x: 0, z: 1 }, { x: 0, z: -1 }
            ];
            
            // 检查目标四个方向上的位置
            for (const dir of dirs) {
                // 如果是火箭筒，从更远的位置开始检查（保持安全距离）
                const startDist = this.weapon === WEAPON.ROCKET ? 3 : 1;
                
                for (let i = startDist; i <= range; i++) {
                    const posX = targetX + dir.x * i;
                    const posZ = targetZ + dir.z * i;
                    
                    if (posX < 0 || posX >= CONFIG.GRID_WIDTH || posZ < 0 || posZ >= CONFIG.GRID_HEIGHT) break;
                    if (grid[posZ][posX] === TILE.WALL || grid[posZ][posX] === TILE.CRATE) break;
                    
                    // 检查这个位置是否可以站立且安全
                    if (grid[posZ][posX] === TILE.EMPTY && this.isSafePosition(posX, posZ)) {
                        // 如果是火箭筒，额外检查是否在爆炸范围外
                        if (this.weapon === WEAPON.ROCKET) {
                            const distToTarget = Math.abs(posX - targetX) + Math.abs(posZ - targetZ);
                            if (distToTarget < 3) continue; // 太近，不安全
                        }
                        
                        // 检查从当前位置到这个位置的路径
                        const pathDist = Math.abs(posX - this.gridX) + Math.abs(posZ - this.gridZ);
                        if (pathDist <= 5) { // 不要走太远
                            return { x: posX, z: posZ };
                        }
                    }
                }
            }
            
            return null;
        }
        
        // 强制探索 - 当AI踱步太久时，强制向远处移动
        forceExplore() {
            const dirs = [{ x: 1, z: 0 }, { x: -1, z: 0 }, { x: 0, z: 1 }, { x: 0, z: -1 }];
            let bestDir = null;
            let bestScore = -Infinity;
            
            for (const d of dirs) {
                let steps = 0;
                let score = 0;
                let cx = this.gridX, cz = this.gridZ;
                
                for (let i = 0; i < 8; i++) {
                    const nx = cx + d.x;
                    const nz = cz + d.z;
                    if (!this.canMoveTo(nx, nz)) break;
                    if (!this.isSafePosition(nx, nz)) break;
                    
                    // 检查是否是最近访问过的位置
                    const posKey = `${nx},${nz}`;
                    if (this.positionHistory && this.positionHistory.includes(posKey)) {
                        score -= 10; // 扣分但不停止
                    } else {
                        score += 15; // 新位置加分
                    }
                    
                    steps++;
                    cx = nx;
                    cz = nz;
                }
                
                score += steps * 5; // 能走更远的方向更好
                
                // 避免反向
                if (this.lastMoveDir && d.x === -this.lastMoveDir.x && d.z === -this.lastMoveDir.z) {
                    score -= 30;
                }
                
                if (score > bestScore && steps >= 2) {
                    bestScore = score;
                    bestDir = d;
                }
            }
            
            if (bestDir) {
                this.lastMoveDir = this.moveDirection;
                this.moveDirection = bestDir;
                this.directionLockTimer = 2.0; // 锁定更长时间
                this.input.x = bestDir.x;
                this.input.z = bestDir.z;
            } else {
                this.smartWander();
            }
        }
        
        // 寻找攻击目标
        findTarget() {
            let bestTarget = null;
            let minDist = 10;
            
            // 寻找最近的箱子
            for (let z = 0; z < CONFIG.GRID_HEIGHT; z++) {
                for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                    if (grid[z][x] === TILE.CRATE || grid[z][x] === TILE.TREASURE) {
                        const dist = Math.abs(x - this.gridX) + Math.abs(z - this.gridZ);
                        if (dist < minDist && dist > 0) {
                            minDist = dist;
                            bestTarget = { x, z };
                        }
                    }
                }
            }
            
            // 寻找敌人
            for (const p of players) {
                if (p.isDead || p.id === this.id) continue;
                const dist = Math.abs(p.gridX - this.gridX) + Math.abs(p.gridZ - this.gridZ);
                if (dist < minDist && dist > 0) {
                    minDist = dist;
                    bestTarget = { x: p.gridX, z: p.gridZ };
                }
            }
            
            return bestTarget;
        }
        
        // 智能漫游 - 持续朝一个方向移动，优先寻找可攻击位置
        smartWander() {
            const dirs = [{ x: 1, z: 0 }, { x: -1, z: 0 }, { x: 0, z: 1 }, { x: 0, z: -1 }];
            
            // 如果当前方向仍然可行且锁定时间未到，继续走
            if (this.moveDirection && this.directionLockTimer > 0) {
                const nx = this.gridX + this.moveDirection.x;
                const nz = this.gridZ + this.moveDirection.z;
                // 检查是否应该避免走向传送门，以及是否是最近访问过的位置
                const nextPosKey = `${nx},${nz}`;
                const recentlyVisited = this.positionHistory && this.positionHistory.slice(-5).includes(nextPosKey);
                
                if (this.canMoveTo(nx, nz) && this.isSafePosition(nx, nz) && !this.shouldAvoidPortal(nx, nz) && !recentlyVisited) {
                    this.input.x = this.moveDirection.x;
                    this.input.z = this.moveDirection.z;
                    return;
                }
            }
            
            // 需要选择新方向 - 优先选择能到达可攻击位置的方向
            const validDirs = dirs.filter(d => {
                const nx = this.gridX + d.x;
                const nz = this.gridZ + d.z;
                return this.canMoveTo(nx, nz) && this.isSafePosition(nx, nz);
            });
            
            if (validDirs.length > 0) {
                let bestDir = null;
                let bestScore = -Infinity;
                
                for (const d of validDirs) {
                    let score = 0;
                    const nx = this.gridX + d.x;
                    const nz = this.gridZ + d.z;
                    const nextPosKey = `${nx},${nz}`;
                    
                    // 如果刚传送过，避免走向传送门
                    if (this.shouldAvoidPortal(nx, nz)) {
                        score -= 100; // 大幅扣分
                    }
                    
                    // 避免走向最近访问过的位置（防止来回踱步）
                    if (this.positionHistory) {
                        const recentPositions = this.positionHistory.slice(-6);
                        const visitCount = recentPositions.filter(p => p === nextPosKey).length;
                        score -= visitCount * 30; // 每次访问扣30分
                    }
                    
                    // 检查这个方向上是否有可攻击目标
                    for (let i = 1; i <= 5; i++) {
                        const checkX = this.gridX + d.x * i;
                        const checkZ = this.gridZ + d.z * i;
                        
                        if (checkX < 0 || checkX >= CONFIG.GRID_WIDTH || checkZ < 0 || checkZ >= CONFIG.GRID_HEIGHT) break;
                        if (grid[checkZ][checkX] === TILE.WALL) break;
                        
                        // 发现箱子加分
                        if (grid[checkZ][checkX] === TILE.CRATE || grid[checkZ][checkX] === TILE.TREASURE) {
                            score += 80 / i; // 距离越近分数越高
                            break;
                        }
                        
                        // 发现敌人加分 - 更高优先级
                        const enemy = players.find(p => !p.isDead && p.id !== this.id && p.gridX === checkX && p.gridZ === checkZ);
                        if (enemy) {
                            score += 100 / i;
                            break;
                        }
                    }
                    
                    // 检查移动后能否放炸弹攻击到目标
                    const attackScore = this.evaluateAttackPosition(nx, nz);
                    score += attackScore * 2;
                    
                    // 避免来回踱步：如果上次移动方向相反，大幅扣分
                    if (this.lastMoveDir && d.x === -this.lastMoveDir.x && d.z === -this.lastMoveDir.z) {
                        score -= 80; // 增加扣分力度
                    }
                    
                    // 优先选择能走更远的方向
                    let steps = 0;
                    let cx = this.gridX, cz = this.gridZ;
                    for (let i = 0; i < 5; i++) {
                        const nnx = cx + d.x;
                        const nnz = cz + d.z;
                        if (!this.canMoveTo(nnx, nnz)) break;
                        steps++;
                        cx = nnx;
                        cz = nnz;
                    }
                    score += steps * 5; // 增加走远的权重
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestDir = d;
                    }
                }
                
                if (bestDir) {
                    this.lastMoveDir = this.moveDirection;
                    this.moveDirection = bestDir;
                    this.directionLockTimer = 0.8 + Math.random() * 0.4; // 增加锁定时间，减少方向切换
                    this.input.x = bestDir.x;
                    this.input.z = bestDir.z;
                    return;
                }
                
                // 随机选择（但避免反向）
                let filteredDirs = validDirs;
                if (this.lastMoveDir) {
                    filteredDirs = validDirs.filter(d => !(d.x === -this.lastMoveDir.x && d.z === -this.lastMoveDir.z));
                    if (filteredDirs.length === 0) filteredDirs = validDirs;
                }
                const pick = filteredDirs[Math.floor(Math.random() * filteredDirs.length)];
                this.lastMoveDir = this.moveDirection;
                this.moveDirection = pick;
                this.directionLockTimer = 0.6;
                this.input.x = pick.x;
                this.input.z = pick.z;
            } else {
                // 没有安全方向，选择任意可通行方向
                const anyValid = dirs.filter(d => this.canMoveTo(this.gridX + d.x, this.gridZ + d.z));
                if (anyValid.length > 0) {
                    const pick = anyValid[Math.floor(Math.random() * anyValid.length)];
                    this.lastMoveDir = this.moveDirection;
                    this.moveDirection = pick;
                    this.input.x = pick.x;
                    this.input.z = pick.z;
                }
            }
        }
        
        // 评估某个位置的攻击价值
        evaluateAttackPosition(x, z) {
            let score = 0;
            const dirs = [{ x: 1, z: 0 }, { x: -1, z: 0 }, { x: 0, z: 1 }, { x: 0, z: -1 }];
            
            for (const dir of dirs) {
                for (let i = 1; i <= this.range; i++) {
                    const checkX = x + dir.x * i;
                    const checkZ = z + dir.z * i;
                    
                    if (checkX < 0 || checkX >= CONFIG.GRID_WIDTH || checkZ < 0 || checkZ >= CONFIG.GRID_HEIGHT) break;
                    if (grid[checkZ][checkX] === TILE.WALL) break;
                    
                    if (grid[checkZ][checkX] === TILE.CRATE || grid[checkZ][checkX] === TILE.TREASURE) {
                        score += 15;
                        break;
                    }
                    
                    const enemy = players.find(p => !p.isDead && p.id !== this.id && p.gridX === checkX && p.gridZ === checkZ);
                    if (enemy) {
                        score += 30;
                        break;
                    }
                }
            }
            
            return score;
        }
        
        // 检查位置是否安全（不在炸弹范围内，也不在车辆路径上）
        isSafePosition(x, z) {
            // 检查炸弹危险
            for (const bomb of bombs) {
                if ((x === bomb.gridX && Math.abs(z - bomb.gridZ) <= bomb.range) ||
                    (z === bomb.gridZ && Math.abs(x - bomb.gridX) <= bomb.range)) {
                    return false;
                }
            }
            
            // 检查车辆危险（城市关卡）
            const theme = LEVEL_THEMES[currentLevel];
            if (theme && theme.hasCars && cityCars.length > 0) {
                for (const car of cityCars) {
                    const posInfo = getCarPositionOnRoute(car.route, car.progress);
                    const carGridX = Math.round(posInfo.x);
                    const carGridZ = Math.round(posInfo.z);
                    
                    // 如果目标位置靠近车辆当前位置，不安全
                    const dist = Math.abs(x - carGridX) + Math.abs(z - carGridZ);
                    if (dist <= 2) {
                        return false;
                    }
                    
                    // 预测车辆未来位置（往前看一点）
                    const futureProgress = (car.progress + 0.05) % 1;
                    const futurePos = getCarPositionOnRoute(car.route, futureProgress);
                    const futureGridX = Math.round(futurePos.x);
                    const futureGridZ = Math.round(futurePos.z);
                    const futureDist = Math.abs(x - futureGridX) + Math.abs(z - futureGridZ);
                    if (futureDist <= 1) {
                        return false;
                    }
                }
            }
            
            return true;
        }
        
        // 检查位置是否是传送门（AI应该避免刚传送后又走回传送门）
        isPortalPosition(x, z) {
            if (!portals || portals.length === 0) return false;
            return portals.some(p => p.userData.gridX === x && p.userData.gridZ === z);
        }
        
        // AI应该避免走向传送门（刚传送后一段时间内）
        shouldAvoidPortal(x, z) {
            if (!this.lastPortalGrid) return false;
            // 刚传送后，避免走向任何传送门
            return this.isPortalPosition(x, z);
        }
        
        // 检查放炸弹后是否有安全的逃跑路线
        canPlaceBombSafely() {
            if (this.activeBombs >= this.maxBombs) return false;
            
            const bombRange = this.range;
            const dirs = [{ x: 1, z: 0 }, { x: -1, z: 0 }, { x: 0, z: 1 }, { x: 0, z: -1 }];
            
            for (const dir of dirs) {
                let cx = this.gridX;
                let cz = this.gridZ;
                
                // 检查能否走出炸弹范围
                for (let step = 1; step <= bombRange + 2; step++) {
                    const nx = cx + dir.x;
                    const nz = cz + dir.z;
                    
                    if (!this.canMoveTo(nx, nz)) break;
                    
                    cx = nx;
                    cz = nz;
                    
                    // 检查是否脱离爆炸范围
                    const inXLine = cx === this.gridX;
                    const inZLine = cz === this.gridZ;
                    
                    if (!inXLine && !inZLine) return true; // 拐弯了，安全
                    
                    const dist = Math.abs(cx - this.gridX) + Math.abs(cz - this.gridZ);
                    if (dist > bombRange) return true; // 走出范围了
                    
                    // 在走的过程中检查能否拐弯逃跑
                    const perpDirs = dir.x !== 0 ? 
                        [{ x: 0, z: 1 }, { x: 0, z: -1 }] : 
                        [{ x: 1, z: 0 }, { x: -1, z: 0 }];
                    
                    for (const pd of perpDirs) {
                        const turnX = cx + pd.x;
                        const turnZ = cz + pd.z;
                        if (this.canMoveTo(turnX, turnZ)) {
                            // 检查拐弯后是否安全
                            const turnInXLine = turnX === this.gridX;
                            const turnInZLine = turnZ === this.gridZ;
                            if (!turnInXLine && !turnInZLine) {
                                return true; // 拐弯后不在爆炸线上
                            }
                            // 继续检查拐弯后能否走出范围
                            let tcx = turnX, tcz = turnZ;
                            for (let ts = 1; ts <= bombRange; ts++) {
                                const tnx = tcx + pd.x;
                                const tnz = tcz + pd.z;
                                if (!this.canMoveTo(tnx, tnz)) break;
                                tcx = tnx;
                                tcz = tnz;
                                const tdist = Math.abs(tcx - this.gridX) + Math.abs(tcz - this.gridZ);
                                if (tdist > bombRange) return true;
                            }
                        }
                    }
                }
            }
            
            return false;
        }
        
        checkDanger() {
            // 检查炸弹危险
            for (const bomb of bombs) {
                if (bomb.gridX === this.gridX && Math.abs(bomb.gridZ - this.gridZ) <= bomb.range) {
                    return { type: 'bomb', source: bomb };
                }
                if (bomb.gridZ === this.gridZ && Math.abs(bomb.gridX - this.gridX) <= bomb.range) {
                    return { type: 'bomb', source: bomb };
                }
            }
            
            // 检查车辆危险（城市关卡）
            const theme = LEVEL_THEMES[currentLevel];
            if (theme && theme.hasCars && cityCars.length > 0) {
                for (const car of cityCars) {
                    const posInfo = getCarPositionOnRoute(car.route, car.progress);
                    const carGridX = Math.round(posInfo.x);
                    const carGridZ = Math.round(posInfo.z);
                    
                    // 如果AI在车辆附近，视为危险
                    const dist = Math.abs(this.gridX - carGridX) + Math.abs(this.gridZ - carGridZ);
                    if (dist <= 2) {
                        return { type: 'car', source: car, carX: carGridX, carZ: carGridZ };
                    }
                }
            }
            
            return null;
        }
        
        escapeFromDanger(danger) {
            const dirs = [{ x: 1, z: 0 }, { x: -1, z: 0 }, { x: 0, z: 1 }, { x: 0, z: -1 }];
            const scoredDirs = [];
            
            for (const d of dirs) {
                const nx = this.gridX + d.x;
                const nz = this.gridZ + d.z;
                
                if (!this.canMoveTo(nx, nz)) continue;
                
                let score = 10; // 基础分
                
                if (danger.type === 'bomb') {
                    const bomb = danger.source;
                    // 检查移动后是否脱离当前炸弹范围
                    const stillInDanger = (nx === bomb.gridX && Math.abs(nz - bomb.gridZ) <= bomb.range) ||
                                         (nz === bomb.gridZ && Math.abs(nx - bomb.gridX) <= bomb.range);
                    
                    if (!stillInDanger) {
                        score += 100;
                    } else {
                        // 检查继续走能否脱离
                        let cx = nx, cz = nz;
                        for (let step = 0; step < 4; step++) {
                            const nnx = cx + d.x;
                            const nnz = cz + d.z;
                            if (!this.canMoveTo(nnx, nnz)) break;
                            cx = nnx;
                            cz = nnz;
                            const safe = !((cx === bomb.gridX && Math.abs(cz - bomb.gridZ) <= bomb.range) ||
                                          (cz === bomb.gridZ && Math.abs(cx - bomb.gridX) <= bomb.range));
                            if (safe) {
                                score += 50;
                                break;
                            }
                        }
                    }
                    
                    // 检查是否会进入其他炸弹范围
                    for (const otherBomb of bombs) {
                        if (otherBomb === bomb) continue;
                        if ((nx === otherBomb.gridX && Math.abs(nz - otherBomb.gridZ) <= otherBomb.range) ||
                            (nz === otherBomb.gridZ && Math.abs(nx - otherBomb.gridX) <= otherBomb.range)) {
                            score -= 80;
                        }
                    }
                } else if (danger.type === 'car') {
                    // 逃离车辆：远离车辆当前位置
                    const carX = danger.carX;
                    const carZ = danger.carZ;
                    const currentDist = Math.abs(this.gridX - carX) + Math.abs(this.gridZ - carZ);
                    const newDist = Math.abs(nx - carX) + Math.abs(nz - carZ);
                    
                    if (newDist > currentDist) {
                        score += 100; // 远离车辆加分
                    } else {
                        score -= 50; // 靠近车辆扣分
                    }
                    
                    // 避开道路区域
                    if (!isCarRoadArea(nx, nz)) {
                        score += 50; // 离开道路加分
                    }
                }
                
                scoredDirs.push({ dir: d, score });
            }
            
            if (scoredDirs.length > 0) {
                scoredDirs.sort((a, b) => b.score - a.score);
                const best = scoredDirs[0];
                this.moveDirection = best.dir;
                this.directionLockTimer = 0.5; // 逃跑时锁定方向
                this.input.x = best.dir.x;
                this.input.z = best.dir.z;
            }
        }
        
        findNearestPowerup() {
            let nearest = null;
            let minDist = 8;
            for (const p of powerups) {
                const dist = Math.abs(p.gridX - this.gridX) + Math.abs(p.gridZ - this.gridZ);
                if (dist < minDist && this.isSafePosition(p.gridX, p.gridZ)) {
                    minDist = dist;
                    nearest = p;
                }
            }
            return nearest;
        }
        
        moveToward(tx, tz) {
            const dirs = [];
            
            // 计算到目标的方向
            const dx = tx - this.gridX;
            const dz = tz - this.gridZ;
            
            // 优先沿着主要方向移动
            if (Math.abs(dx) >= Math.abs(dz)) {
                if (dx > 0) dirs.push({ x: 1, z: 0, priority: 1 });
                if (dx < 0) dirs.push({ x: -1, z: 0, priority: 1 });
                if (dz > 0) dirs.push({ x: 0, z: 1, priority: 2 });
                if (dz < 0) dirs.push({ x: 0, z: -1, priority: 2 });
            } else {
                if (dz > 0) dirs.push({ x: 0, z: 1, priority: 1 });
                if (dz < 0) dirs.push({ x: 0, z: -1, priority: 1 });
                if (dx > 0) dirs.push({ x: 1, z: 0, priority: 2 });
                if (dx < 0) dirs.push({ x: -1, z: 0, priority: 2 });
            }
            
            // 添加其他方向作为备选
            const allDirs = [{ x: 1, z: 0 }, { x: -1, z: 0 }, { x: 0, z: 1 }, { x: 0, z: -1 }];
            for (const d of allDirs) {
                if (!dirs.some(pd => pd.x === d.x && pd.z === d.z)) {
                    dirs.push({ ...d, priority: 3 });
                }
            }
            
            dirs.sort((a, b) => a.priority - b.priority);
            
            // 选择安全的方向（避免传送门）
            for (const d of dirs) {
                const nx = this.gridX + d.x;
                const nz = this.gridZ + d.z;
                if (this.canMoveTo(nx, nz) && this.isSafePosition(nx, nz) && !this.shouldAvoidPortal(nx, nz)) {
                    this.moveDirection = d;
                    this.directionLockTimer = 0.3;
                    this.input.x = d.x;
                    this.input.z = d.z;
                    return;
                }
            }
            
            // 如果所有方向都有传送门，选择安全但可能有传送门的方向
            for (const d of dirs) {
                const nx = this.gridX + d.x;
                const nz = this.gridZ + d.z;
                if (this.canMoveTo(nx, nz) && this.isSafePosition(nx, nz)) {
                    this.moveDirection = d;
                    this.directionLockTimer = 0.3;
                    this.input.x = d.x;
                    this.input.z = d.z;
                    return;
                }
            }
            
            // 没有安全方向，选择任意可通行方向
            for (const d of dirs) {
                if (this.canMoveTo(this.gridX + d.x, this.gridZ + d.z)) {
                    this.moveDirection = d;
                    this.input.x = d.x;
                    this.input.z = d.z;
                    return;
                }
            }
            
            this.smartWander();
        }
        
        shouldAttack() {
            // 检查相邻格子是否有可攻击目标
            const neighbors = [
                { x: this.gridX + 1, z: this.gridZ },
                { x: this.gridX - 1, z: this.gridZ },
                { x: this.gridX, z: this.gridZ + 1 },
                { x: this.gridX, z: this.gridZ - 1 }
            ];
            
            // 相邻有目标，立即攻击
            for (const pos of neighbors) {
                if (pos.x >= 0 && pos.x < CONFIG.GRID_WIDTH && pos.z >= 0 && pos.z < CONFIG.GRID_HEIGHT) {
                    if (grid[pos.z][pos.x] === TILE.CRATE) return true;
                    if (grid[pos.z][pos.x] === TILE.TREASURE) return true;
                    const enemy = players.find(p => !p.isDead && p.id !== this.id && p.gridX === pos.x && p.gridZ === pos.z);
                    if (enemy) return true;
                }
            }
            
            // 检查炸弹范围内是否有目标
            const dirs = [{ x: 1, z: 0 }, { x: -1, z: 0 }, { x: 0, z: 1 }, { x: 0, z: -1 }];
            let targetsInRange = 0;
            
            for (const dir of dirs) {
                for (let i = 1; i <= this.range; i++) {
                    const checkX = this.gridX + dir.x * i;
                    const checkZ = this.gridZ + dir.z * i;
                    
                    if (checkX < 0 || checkX >= CONFIG.GRID_WIDTH || checkZ < 0 || checkZ >= CONFIG.GRID_HEIGHT) break;
                    if (grid[checkZ][checkX] === TILE.WALL) break;
                    
                    // 发现可破坏物
                    if (grid[checkZ][checkX] === TILE.CRATE || grid[checkZ][checkX] === TILE.TREASURE) {
                        targetsInRange++;
                        break;
                    }
                    
                    // 发现敌人 - 高优先级，立即攻击
                    const enemy = players.find(p => !p.isDead && p.id !== this.id && p.gridX === checkX && p.gridZ === checkZ);
                    if (enemy) return true;
                }
            }
            
            // 如果范围内有多个目标，或者有至少一个目标且随机决定攻击
            if (targetsInRange >= 2) return true;
            if (targetsInRange >= 1 && Math.random() < 0.7) return true; // 70%概率攻击单个目标
            
            return false;
        }
        
        // AI判断是否应该使用武器 - 检查四个方向，找到目标就转向并攻击
        shouldUseWeapon() {
            const weaponRange = this.weapon === WEAPON.FLAMETHROWER ? 3 : 
                               this.weapon === WEAPON.ROCKET ? 10 : 15;
            
            const dirs = [
                { x: 0, z: -1, angle: 0 },           // 上
                { x: 1, z: 0, angle: Math.PI / 2 },  // 右
                { x: 0, z: 1, angle: Math.PI },      // 下
                { x: -1, z: 0, angle: -Math.PI / 2 } // 左
            ];
            
            let bestDir = null;
            let bestPriority = 0; // 敌人优先级高于箱子
            let bestDistance = Infinity;
            
            for (const dir of dirs) {
                let foundTarget = false;
                
                for (let i = 1; i <= weaponRange; i++) {
                    const checkX = this.gridX + dir.x * i;
                    const checkZ = this.gridZ + dir.z * i;
                    
                    if (checkX < 0 || checkX >= CONFIG.GRID_WIDTH || checkZ < 0 || checkZ >= CONFIG.GRID_HEIGHT) break;
                    
                    // 喷火器不会被墙阻挡，但激光和火箭筒会
                    if (grid[checkZ][checkX] === TILE.WALL) {
                        if (this.weapon !== WEAPON.FLAMETHROWER) {
                            break; // 激光和火箭筒被墙阻挡
                        }
                        continue; // 喷火器穿过墙壁继续检测
                    }
                    
                    // 发现敌人 - 最高优先级
                    const enemy = players.find(p => !p.isDead && p.id !== this.id && p.gridX === checkX && p.gridZ === checkZ);
                    if (enemy) {
                        // 如果是火箭筒，检查自己是否在爆炸范围内
                        if (this.weapon === WEAPON.ROCKET) {
                            if (!this.isRocketSafe(checkX, checkZ)) {
                                break; // 不安全，跳过这个方向
                            }
                        }
                        if (bestPriority < 100 || (bestPriority === 100 && i < bestDistance)) {
                            bestPriority = 100;
                            bestDir = dir;
                            bestDistance = i;
                            foundTarget = true;
                        }
                        break;
                    }
                    
                    // 发现可破坏物
                    if (grid[checkZ][checkX] === TILE.CRATE || grid[checkZ][checkX] === TILE.TREASURE) {
                        // 如果是火箭筒，检查自己是否在爆炸范围内
                        if (this.weapon === WEAPON.ROCKET) {
                            if (!this.isRocketSafe(checkX, checkZ)) {
                                break; // 不安全，跳过这个方向
                            }
                        }
                        if (bestPriority < 50 || (bestPriority === 50 && i < bestDistance)) {
                            bestPriority = 50;
                            bestDir = dir;
                            bestDistance = i;
                            foundTarget = true;
                        }
                        break;
                    }
                }
            }
            
            // 必须有目标才使用武器（不对空气和不可破坏物使用）
            if (bestDir && bestPriority > 0) {
                // 存储AI的武器攻击方向，确保在useWeapon时使用正确的方向
                this.aiWeaponDir = { x: bestDir.x, z: bestDir.z };
                // 转向目标方向
                this.mesh.rotation.y = bestDir.angle;
                return true;
            }
            
            return false;
        }
        
        // 检查火箭筒发射是否安全（自己不在3x3爆炸范围内）
        isRocketSafe(targetX, targetZ) {
            // 检查自己是否在目标点的3x3范围内
            const distX = Math.abs(this.gridX - targetX);
            const distZ = Math.abs(this.gridZ - targetZ);
            
            // 如果自己在3x3范围内（距离<=1），不安全
            if (distX <= 1 && distZ <= 1) {
                return false;
            }
            
            // 额外安全边距：如果距离太近（<=2格），也要小心
            if (distX + distZ <= 2) {
                return false;
            }
            
            return true;
        }
        
        wander() {
            this.smartWander();
        }
    }

    // ==================== 炸弹类 - 优化版 ====================
    class Bomb {
        constructor(gx, gz, range, owner) {
            this.gridX = gx;
            this.gridZ = gz;
            this.range = range;
            this.owner = owner;
            this.timer = CONFIG.BOMB_TIMER;
            this.moving = false;
            this.velocity = { x: 0, z: 0 };
            
            // 使用缓存几何体
            const geo = GeoCache.getSphere(CONFIG.TILE_SIZE / 3, 12);
            this.mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.3 }));
            
            const pos = gridToWorld(gx, gz);
            this.mesh.position.set(pos.x, CONFIG.TILE_SIZE / 2.5, pos.z);
            this.mesh.castShadow = true;
            
            // 引信 - 简化
            const fuseGeo = GeoCache.getCylinder(0.1, 0.1, 0.5, 4);
            const fuseMat = MatCache.get(0x886644);
            this.fuse = new THREE.Mesh(fuseGeo, fuseMat);
            this.fuse.position.y = CONFIG.TILE_SIZE / 3;
            this.mesh.add(this.fuse);
            
            // 火花
            const sparkGeo = GeoCache.getSphere(0.15, 4);
            this.sparkMat = new THREE.MeshStandardMaterial({ color: 0xff4400, emissive: 0xff2200, emissiveIntensity: 1 });
            this.spark = new THREE.Mesh(sparkGeo, this.sparkMat);
            this.spark.position.y = 0.35;
            this.fuse.add(this.spark);
            
            scene.add(this.mesh);
            this.pulseTime = 0;
        }
        
        update(dt) {
            this.timer -= dt;
            
            if (this.moving) {
                const moveSpeed = CONFIG.BOMB_KICK_SPEED;
                this.mesh.position.x += this.velocity.x * moveSpeed * dt;
                this.mesh.position.z += this.velocity.z * moveSpeed * dt;
                
                const currentCenter = gridToWorld(this.gridX, this.gridZ);
                let passedCenter = false;
                
                if (this.velocity.x > 0 && this.mesh.position.x >= currentCenter.x + CONFIG.TILE_SIZE / 2) passedCenter = true;
                else if (this.velocity.x < 0 && this.mesh.position.x <= currentCenter.x - CONFIG.TILE_SIZE / 2) passedCenter = true;
                else if (this.velocity.z > 0 && this.mesh.position.z >= currentCenter.z + CONFIG.TILE_SIZE / 2) passedCenter = true;
                else if (this.velocity.z < 0 && this.mesh.position.z <= currentCenter.z - CONFIG.TILE_SIZE / 2) passedCenter = true;
                
                if (passedCenter) {
                    const nextX = this.gridX + this.velocity.x;
                    const nextZ = this.gridZ + this.velocity.z;
                    
                    if (canBombMoveTo(nextX, nextZ)) {
                        this.gridX = nextX;
                        this.gridZ = nextZ;
                    } else {
                        this.moving = false;
                        this.velocity = { x: 0, z: 0 };
                        const snapPos = gridToWorld(this.gridX, this.gridZ);
                        this.mesh.position.x = snapPos.x;
                        this.mesh.position.z = snapPos.z;
                    }
                }
            }
            
            this.pulseTime += dt * 6;
            const scale = 1 + Math.sin(this.pulseTime) * 0.12;
            this.mesh.scale.set(scale, scale, scale);
            
            const red = Math.abs(Math.sin(this.pulseTime * 2));
            this.mesh.material.emissive.setRGB(red * 0.5, 0, 0);
            this.sparkMat.emissiveIntensity = 0.5 + Math.random() * 0.5;
            
            if (this.timer <= 0) this.explode();
        }
        
        explode() {
            scene.remove(this.mesh);
            const idx = bombs.indexOf(this);
            if (idx !== -1) bombs.splice(idx, 1);
            this.owner.activeBombs--;
            createExplosion(this.gridX, this.gridZ, this.range);
        }
    }

    // ==================== 爆炸效果 - 连续光柱样式 ====================
    function createExplosion(cx, cz, range) {
        // 播放爆炸音效
        soundManager.playExplosion();
        
        // 计算每个方向的实际范围（遇到障碍物停止）
        const directions = [
            { x: 1, z: 0 },
            { x: -1, z: 0 },
            { x: 0, z: 1 },
            { x: 0, z: -1 }
        ];
        
        const actualRanges = [];
        const hitGrids = [{ x: cx, z: cz }]; // 所有被爆炸覆盖的格子
        
        for (const dir of directions) {
            let actualRange = 0;
            for (let r = 1; r <= range; r++) {
                const tx = cx + dir.x * r;
                const tz = cz + dir.z * r;
                
                if (tx < 0 || tx >= CONFIG.GRID_WIDTH || tz < 0 || tz >= CONFIG.GRID_HEIGHT) break;
                
                const tile = grid[tz][tx];
                if (tile === TILE.WALL) break;
                
                actualRange = r;
                hitGrids.push({ x: tx, z: tz });
                
                // 木桶和宝箱都可以被炸毁
                if (tile === TILE.CRATE || tile === TILE.TREASURE) {
                    destroyCrate(tx, tz);
                    break;
                }
                
                // 连锁炸弹
                const chainBomb = bombs.find(b => b.gridX === tx && b.gridZ === tz);
                if (chainBomb) chainBomb.timer = 0.05;
            }
            actualRanges.push({ dir, range: actualRange });
        }
        
        // 创建连续爆炸光柱效果
        const explosionGroup = new THREE.Group();
        const centerPos = gridToWorld(cx, cz);
        
        // 中心爆炸球
        const centerMat = new THREE.MeshBasicMaterial({
            color: 0x00ccff,
            transparent: true,
            opacity: 0.9
        });
        const centerSphere = new THREE.Mesh(
            GeoCache.getSphere(CONFIG.TILE_SIZE * 0.5, 16),
            centerMat
        );
        centerSphere.position.set(centerPos.x, CONFIG.TILE_SIZE / 2, centerPos.z);
        explosionGroup.add(centerSphere);
        
        // 为每个方向创建连续光柱
        actualRanges.forEach(({ dir, range: r }) => {
            if (r === 0) return;
            
            const length = r * CONFIG.TILE_SIZE;
            const halfLength = length / 2;
            
            // 光柱主体
            const beamGeo = new THREE.CylinderGeometry(
                CONFIG.TILE_SIZE * 0.35,  // 顶部半径
                CONFIG.TILE_SIZE * 0.35,  // 底部半径
                length,
                12
            );
            const beamMat = new THREE.MeshBasicMaterial({
                color: 0x00ccff,
                transparent: true,
                opacity: 0.8
            });
            const beam = new THREE.Mesh(beamGeo, beamMat);
            
            // 旋转光柱使其水平
            beam.rotation.z = Math.PI / 2;
            if (dir.z !== 0) {
                beam.rotation.y = Math.PI / 2;
            }
            
            // 定位光柱
            beam.position.set(
                centerPos.x + dir.x * halfLength,
                CONFIG.TILE_SIZE / 2,
                centerPos.z + dir.z * halfLength
            );
            explosionGroup.add(beam);
            
            // 末端圆弧（半球）
            const endPos = gridToWorld(cx + dir.x * r, cz + dir.z * r);
            const endMat = new THREE.MeshBasicMaterial({
                color: 0x00ddff,
                transparent: true,
                opacity: 0.85
            });
            const endSphere = new THREE.Mesh(
                GeoCache.getSphere(CONFIG.TILE_SIZE * 0.4, 12),
                endMat
            );
            endSphere.position.set(endPos.x, CONFIG.TILE_SIZE / 2, endPos.z);
            explosionGroup.add(endSphere);
        });
        
        scene.add(explosionGroup);
        
        // 立即检测伤害
        hitGrids.forEach(pos => {
            checkExplosionHit(pos.x, pos.z);
        });
        
        // 爆炸消失动画
        let explosionLife = 0.4;
        const explosionUpdate = () => {
            explosionLife -= 0.016;
            if (explosionLife <= 0) {
                scene.remove(explosionGroup);
                return;
            }
            
            const progress = explosionLife / 0.4;
            explosionGroup.children.forEach(child => {
                if (child.material) {
                    child.material.opacity = progress * 0.9;
                }
                child.scale.setScalar(0.8 + progress * 0.2);
            });
            
            requestAnimationFrame(explosionUpdate);
        };
        explosionUpdate();
    }

    function spawnExplosionCell(gx, gz) {
        // 保留此函数用于其他地方调用（如火箭爆炸）
        const exp = explosionPool.get();
        exp.life = 0.4;
        exp.mesh.visible = true;
        exp.mesh.scale.set(1, 1, 1);
        exp.mesh.material.opacity = 0.8;
        
        const pos = gridToWorld(gx, gz);
        exp.mesh.position.set(pos.x, CONFIG.TILE_SIZE / 2, pos.z);
        scene.add(exp.mesh);
        
        explosions.push(exp);
    }

    function checkExplosionHit(gx, gz) {
        // 检查玩家
        players.forEach(p => {
            if (!p.isDead && p.gridX === gx && p.gridZ === gz) {
                p.die();
            }
        });
        
        // 检查道具（跳过刚生成的道具，给500ms无敌时间）
        const pIdx = powerups.findIndex(p => p.gridX === gx && p.gridZ === gz && (!p.spawnTime || Date.now() - p.spawnTime > 500));
        if (pIdx !== -1) {
            scene.remove(powerups[pIdx].mesh);
            powerups.splice(pIdx, 1);
        }
    }

    function destroyCrate(gx, gz) {
        // 播放箱子破坏音效
        soundManager.playCrateDestroy();
        
        // 检查是否是宝箱
        const isTreasure = grid[gz][gx] === TILE.TREASURE;
        
        // 找到并移除箱子或宝箱
        const crateIdx = mapMeshes.findIndex(m => 
            m.userData.gridX === gx && m.userData.gridZ === gz && 
            (m.userData.type === 'crate' || m.userData.type === 'treasure')
        );
        if (crateIdx !== -1) {
            scene.remove(mapMeshes[crateIdx]);
            mapMeshes.splice(crateIdx, 1);
        }
        
        grid[gz][gx] = TILE.EMPTY;
        
        // 宝箱有更高概率掉落道具，且可能掉落稀有道具
        if (isTreasure) {
            // 宝箱100%掉落道具
            spawnPowerup(gx, gz, true);
        } else if (Math.random() < 0.35) {
            // 普通木桶35%概率掉落
            spawnPowerup(gx, gz, false);
        }
    }
    
    // ==================== 武器系统 ====================
    
    // 激光枪 - 直线攻击，消灭第一个目标
    function fireLaser(startX, startZ, dirX, dirZ, owner) {
        soundManager.playExplosion(); // 临时使用爆炸音效
        
        // 锁定玩家移动
        owner.isUsingWeapon = true;
        
        // 创建激光视觉效果
        const laserGroup = new THREE.Group();
        const startPos = gridToWorld(startX, startZ);
        
        // 沿着方向检测目标
        let hitX = startX, hitZ = startZ;
        let hitSomething = false;
        let laserLength = 0;
        
        for (let i = 1; i <= 15; i++) {
            const checkX = startX + dirX * i;
            const checkZ = startZ + dirZ * i;
            
            // 检查边界
            if (checkX < 0 || checkX >= CONFIG.GRID_WIDTH || checkZ < 0 || checkZ >= CONFIG.GRID_HEIGHT) {
                laserLength = i - 1;
                break;
            }
            
            // 检查墙壁
            if (grid[checkZ][checkX] === TILE.WALL) {
                laserLength = i - 1;
                break;
            }
            
            // 检查可破坏物
            if (grid[checkZ][checkX] === TILE.CRATE || grid[checkZ][checkX] === TILE.TREASURE) {
                hitX = checkX;
                hitZ = checkZ;
                hitSomething = true;
                laserLength = i;
                destroyCrate(checkX, checkZ);
                break;
            }
            
            // 检查敌人
            const enemy = players.find(p => !p.isDead && p.id !== owner.id && p.gridX === checkX && p.gridZ === checkZ);
            if (enemy) {
                hitX = checkX;
                hitZ = checkZ;
                hitSomething = true;
                laserLength = i;
                enemy.die();
                break;
            }
            
            laserLength = i;
        }
        
        // 创建激光光束
        if (laserLength > 0) {
            const laserMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.9
            });
            
            const beamLength = laserLength * CONFIG.TILE_SIZE;
            const laserGeo = new THREE.CylinderGeometry(0.15, 0.15, beamLength, 8);
            const laser = new THREE.Mesh(laserGeo, laserMat);
            
            // 旋转激光束使其水平
            if (dirX !== 0) {
                laser.rotation.z = Math.PI / 2;
            } else {
                laser.rotation.x = Math.PI / 2;
            }
            
            // 设置位置
            const midX = startX + dirX * laserLength / 2;
            const midZ = startZ + dirZ * laserLength / 2;
            const midPos = gridToWorld(midX, midZ);
            laser.position.set(midPos.x, 1.5, midPos.z);
            
            laserGroup.add(laser);
            
            // 添加发光效果
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.4
            });
            const glowGeo = new THREE.CylinderGeometry(0.4, 0.4, beamLength, 8);
            const glow = new THREE.Mesh(glowGeo, glowMat);
            glow.rotation.copy(laser.rotation);
            glow.position.copy(laser.position);
            laserGroup.add(glow);
        }
        
        scene.add(laserGroup);
        
        // 激光消失动画
        let laserLife = 0.3;
        const laserUpdate = () => {
            laserLife -= 0.016;
            if (laserLife <= 0) {
                scene.remove(laserGroup);
                owner.isUsingWeapon = false; // 解锁玩家移动
                return;
            }
            laserGroup.children.forEach(c => {
                if (c.material) c.material.opacity = laserLife / 0.3;
            });
            requestAnimationFrame(laserUpdate);
        };
        laserUpdate();
    }
    
    // 喷火枪 - 前方3格范围攻击，持续2秒，不会被不可破坏物阻挡
    function fireFlamethrower(startX, startZ, dirX, dirZ, owner) {
        soundManager.playExplosion();
        
        // 锁定玩家移动
        owner.isUsingWeapon = true;
        
        // 计算火焰实际范围（固定3格，不会被阻挡）
        const hitPositions = [];
        let flameLength = 0;
        
        for (let i = 1; i <= 3; i++) {
            const checkX = startX + dirX * i;
            const checkZ = startZ + dirZ * i;
            
            if (checkX < 0 || checkX >= CONFIG.GRID_WIDTH || checkZ < 0 || checkZ >= CONFIG.GRID_HEIGHT) {
                break;
            }
            
            // 火焰不会被任何物体阻挡，直接穿过
            hitPositions.push({ x: checkX, z: checkZ });
            flameLength = i;
            
            // 破坏可破坏物（立即破坏）
            if (grid[checkZ][checkX] === TILE.CRATE || grid[checkZ][checkX] === TILE.TREASURE) {
                destroyCrate(checkX, checkZ);
            }
        }
        
        if (flameLength === 0) {
            owner.isUsingWeapon = false;
            return;
        }
        
        // 创建连续火焰流效果
        const flameGroup = new THREE.Group();
        const startPos = gridToWorld(startX, startZ);
        const length = flameLength * CONFIG.TILE_SIZE;
        
        // 火焰偏移量，让火焰从角色前方发出
        const flameOffset = CONFIG.TILE_SIZE * 0.5;
        
        // 火焰核心（锥形，从粗到细）
        const coreGeo = new THREE.CylinderGeometry(
            CONFIG.TILE_SIZE * 0.15,  // 末端细
            CONFIG.TILE_SIZE * 0.4,   // 起点粗
            length,
            12
        );
        const coreMat = new THREE.MeshBasicMaterial({
            color: 0xff4400,
            transparent: true,
            opacity: 0.9
        });
        const core = new THREE.Mesh(coreGeo, coreMat);
        
        // 旋转火焰使其水平 - 粗端朝向角色，细端朝向远方
        if (dirX !== 0) {
            // 左右方向
            core.rotation.z = dirX > 0 ? Math.PI / 2 : -Math.PI / 2;
        } else {
            // 上下方向 - Z轴方向
            core.rotation.x = dirZ > 0 ? -Math.PI / 2 : Math.PI / 2;
        }
        
        // 定位火焰 - 从角色前方开始
        core.position.set(
            startPos.x + dirX * (length / 2 + flameOffset),
            CONFIG.TILE_SIZE / 2,
            startPos.z + dirZ * (length / 2 + flameOffset)
        );
        flameGroup.add(core);
        
        // 外层火焰光晕
        const glowGeo = new THREE.CylinderGeometry(
            CONFIG.TILE_SIZE * 0.25,
            CONFIG.TILE_SIZE * 0.6,
            length,
            12
        );
        const glowMat = new THREE.MeshBasicMaterial({
            color: 0xffaa00,
            transparent: true,
            opacity: 0.5
        });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        glow.rotation.copy(core.rotation);
        glow.position.copy(core.position);
        flameGroup.add(glow);
        
        // 末端火球
        const endX = startX + dirX * flameLength;
        const endZ = startZ + dirZ * flameLength;
        const endPos = gridToWorld(endX, endZ);
        const endMat = new THREE.MeshBasicMaterial({
            color: 0xff6600,
            transparent: true,
            opacity: 0.8
        });
        const endBall = new THREE.Mesh(
            GeoCache.getSphere(CONFIG.TILE_SIZE * 0.3, 12),
            endMat
        );
        endBall.position.set(endPos.x, CONFIG.TILE_SIZE / 2, endPos.z);
        flameGroup.add(endBall);
        
        scene.add(flameGroup);
        
        // 火焰持续1.25秒，期间持续检测伤害
        let flameLife = 1.25;
        let lastDamageCheck = 0;
        const damageInterval = 0.1; // 每0.1秒检测一次伤害
        
        const flameUpdate = () => {
            flameLife -= 0.016;
            lastDamageCheck += 0.016;
            
            // 持续检测伤害
            if (lastDamageCheck >= damageInterval) {
                lastDamageCheck = 0;
                hitPositions.forEach(pos => {
                    players.forEach(p => {
                        if (!p.isDead && p.id !== owner.id && p.gridX === pos.x && p.gridZ === pos.z) {
                            p.die();
                        }
                    });
                });
            }
            
            if (flameLife <= 0) {
                scene.remove(flameGroup);
                owner.isUsingWeapon = false;
                return;
            }
            
            // 火焰闪烁效果
            const flicker = 0.8 + Math.sin(flameLife * 30) * 0.2;
            const fadeProgress = Math.min(flameLife / 1.25, 1.0);
            
            flameGroup.children.forEach(child => {
                if (child.material) {
                    const baseOpacity = child === glow ? 0.5 : (child === endBall ? 0.8 : 0.9);
                    child.material.opacity = baseOpacity * fadeProgress * flicker;
                }
            });
            
            // 末端火球跳动
            endBall.scale.setScalar(1 + Math.sin(flameLife * 20) * 0.1);
            
            requestAnimationFrame(flameUpdate);
        };
        flameUpdate();
    }
    
    // 火箭筒 - 发射飞行火箭，碰撞后3x3爆炸
    function fireRocket(startX, startZ, dirX, dirZ, owner) {
        soundManager.playBombPlace();
        
        // 创建火箭模型
        const rocketGroup = new THREE.Group();
        
        // 火箭主体
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8, roughness: 0.3 });
        const body = new THREE.Mesh(GeoCache.getCylinder(0.2, 0.2, 1.2, 8), bodyMat);
        body.rotation.x = Math.PI / 2;
        rocketGroup.add(body);
        
        // 火箭头
        const headMat = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.5, roughness: 0.3 });
        const head = new THREE.Mesh(GeoCache.getCone(0.2, 0.4, 8), headMat);
        head.rotation.x = -Math.PI / 2;
        head.position.z = 0.8;
        rocketGroup.add(head);
        
        // 火箭尾焰
        const flameMat = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.8 });
        const tailFlame = new THREE.Mesh(GeoCache.getCone(0.15, 0.5, 8), flameMat);
        tailFlame.rotation.x = Math.PI / 2;
        tailFlame.position.z = -0.85;
        rocketGroup.add(tailFlame);
        
        // 设置初始位置和朝向
        const startPos = gridToWorld(startX, startZ);
        rocketGroup.position.set(startPos.x, 1.5, startPos.z);
        rocketGroup.rotation.y = Math.atan2(dirX, dirZ);
        
        scene.add(rocketGroup);
        
        // 火箭飞行数据
        const rocket = {
            mesh: rocketGroup,
            x: startX,
            z: startZ,
            dirX: dirX,
            dirZ: dirZ,
            owner: owner,
            speed: 15, // 格/秒
            traveled: 0
        };
        
        projectiles.push(rocket);
    }
    
    // 更新投射物
    function updateProjectiles(dt) {
        for (let i = projectiles.length - 1; i >= 0; i--) {
            const proj = projectiles[i];
            
            // 移动火箭
            const moveAmount = proj.speed * dt;
            proj.traveled += moveAmount;
            
            proj.mesh.position.x += proj.dirX * moveAmount * CONFIG.TILE_SIZE;
            proj.mesh.position.z += proj.dirZ * moveAmount * CONFIG.TILE_SIZE;
            
            // 更新网格位置
            const currentGrid = worldToGrid(proj.mesh.position.x, proj.mesh.position.z);
            proj.x = currentGrid.x;
            proj.z = currentGrid.z;
            
            // 尾焰动画
            const tailFlame = proj.mesh.children[2];
            if (tailFlame) {
                tailFlame.scale.y = 0.8 + Math.random() * 0.4;
            }
            
            // 检查碰撞
            let hit = false;
            
            // 边界检查
            if (proj.x < 0 || proj.x >= CONFIG.GRID_WIDTH || proj.z < 0 || proj.z >= CONFIG.GRID_HEIGHT) {
                hit = true;
            }
            // 墙壁检查
            else if (grid[proj.z] && grid[proj.z][proj.x] === TILE.WALL) {
                hit = true;
            }
            // 可破坏物检查
            else if (grid[proj.z] && (grid[proj.z][proj.x] === TILE.CRATE || grid[proj.z][proj.x] === TILE.TREASURE)) {
                hit = true;
            }
            // 敌人检查
            else {
                const enemy = players.find(p => !p.isDead && p.id !== proj.owner.id && p.gridX === proj.x && p.gridZ === proj.z);
                if (enemy) {
                    hit = true;
                }
            }
            
            // 超出范围
            if (proj.traveled > 15) {
                hit = true;
            }
            
            if (hit) {
                // 3x3爆炸
                rocketExplosion(proj.x, proj.z, proj.owner);
                scene.remove(proj.mesh);
                projectiles.splice(i, 1);
            }
        }
    }
    
    // 火箭爆炸 - 3x3范围
    function rocketExplosion(centerX, centerZ, owner) {
        soundManager.playExplosion();
        
        // 3x3范围
        for (let dz = -1; dz <= 1; dz++) {
            for (let dx = -1; dx <= 1; dx++) {
                const gx = centerX + dx;
                const gz = centerZ + dz;
                
                // 边界检查
                if (gx < 0 || gx >= CONFIG.GRID_WIDTH || gz < 0 || gz >= CONFIG.GRID_HEIGHT) continue;
                
                // 墙壁不受影响
                if (grid[gz][gx] === TILE.WALL) continue;
                
                // 创建爆炸效果
                createSingleExplosion(gx, gz);
                
                // 破坏可破坏物
                if (grid[gz][gx] === TILE.CRATE || grid[gz][gx] === TILE.TREASURE) {
                    destroyCrate(gx, gz);
                }
                
                // 伤害玩家（包括自己）
                players.forEach(p => {
                    if (!p.isDead && p.gridX === gx && p.gridZ === gz) {
                        p.die();
                    }
                });
                
                // 引爆炸弹
                const bombHere = bombs.find(b => b.gridX === gx && b.gridZ === gz);
                if (bombHere) {
                    bombHere.timer = 0;
                }
            }
        }
    }
    
    // 创建单个爆炸效果（不造成伤害，只是视觉效果）
    function createSingleExplosion(gx, gz) {
        const exp = explosionPool.get();
        exp.life = 0.4;
        exp.mesh.visible = true;
        exp.mesh.scale.set(1, 1, 1);
        exp.mesh.material.opacity = 0.8;
        
        const pos = gridToWorld(gx, gz);
        exp.mesh.position.set(pos.x, CONFIG.TILE_SIZE / 2, pos.z);
        scene.add(exp.mesh);
        
        explosions.push(exp);
    }
    
    // 水泡陷阱投掷炸弹
    function launchWaterTrapBomb() {
        // 找到所有空位
        const emptySpots = [];
        for (let z = 1; z < CONFIG.GRID_HEIGHT - 1; z++) {
            for (let x = 1; x < CONFIG.GRID_WIDTH - 1; x++) {
                if (grid[z][x] === TILE.EMPTY && !isWaterTrapArea(x, z)) {
                    // 确保没有炸弹在这个位置
                    if (!bombs.some(b => b.gridX === x && b.gridZ === z)) {
                        emptySpots.push({ x, z });
                    }
                }
            }
        }
        
        if (emptySpots.length === 0) return;
        
        // 随机选择一个空位
        const target = emptySpots[Math.floor(Math.random() * emptySpots.length)];
        
        // 创建一个特殊的水泡炸弹
        createWaterBomb(target.x, target.z);
        
        // 播放音效
        soundManager.playBombPlace();
    }
    
    // 创建水泡炸弹（无主人的炸弹）
    function createWaterBomb(gx, gz) {
        const pos = gridToWorld(gx, gz);
        
        // 创建炸弹外观
        const bombMat = new THREE.MeshStandardMaterial({
            color: 0x00bfff,
            roughness: 0.3,
            metalness: 0.5,
            emissive: 0x0066ff,
            emissiveIntensity: 0.3
        });
        
        const bombGeo = GeoCache.getSphere(1.2, 12);
        const mesh = new THREE.Mesh(bombGeo, bombMat);
        mesh.position.set(pos.x, 1.2, pos.z);
        mesh.castShadow = true;
        scene.add(mesh);
        
        // 添加气泡效果
        const bubbleMat = MatCache.get(0x87ceeb, { emissive: 0x00ffff, emissiveIntensity: 0.5 });
        for (let i = 0; i < 3; i++) {
            const bubble = new THREE.Mesh(GeoCache.getSphere(0.2, 6), bubbleMat);
            const angle = (i / 3) * Math.PI * 2;
            bubble.position.set(Math.cos(angle) * 0.8, 0.5, Math.sin(angle) * 0.8);
            mesh.add(bubble);
        }
        
        // 创建特殊炸弹对象
        const waterBomb = {
            gridX: gx,
            gridZ: gz,
            mesh: mesh,
            timer: 3,
            range: 3,
            pulseTime: 0,
            moving: false,
            velocity: { x: 0, z: 0 },
            owner: { activeBombs: 0 }, // 假的owner
            update: function(dt) {
                this.timer -= dt;
                this.pulseTime += dt * 6;
                const scale = 1 + Math.sin(this.pulseTime) * 0.15;
                this.mesh.scale.set(scale, scale, scale);
                this.mesh.material.emissiveIntensity = 0.3 + Math.sin(this.pulseTime * 2) * 0.2;
                
                if (this.timer <= 0) {
                    this.explode();
                }
            },
            explode: function() {
                scene.remove(this.mesh);
                const idx = bombs.indexOf(this);
                if (idx !== -1) bombs.splice(idx, 1);
                createExplosion(this.gridX, this.gridZ, this.range);
            }
        };
        
        bombs.push(waterBomb);
    }

    // ==================== 道具 - 泡泡样式（2D图标） ====================
    
    function spawnPowerup(gx, gz, fromTreasure = false) {
        // 基础道具和武器道具
        const baseTypes = [POWERUP.SPEED, POWERUP.RANGE, POWERUP.BOMB, POWERUP.KICK];
        const weaponTypes = [POWERUP.LASER, POWERUP.FLAMETHROWER, POWERUP.ROCKET];
        
        
        // 宝箱有更高概率掉落武器道具
        let type;
        if (fromTreasure && Math.random() < 0.5) {
            // 宝箱50%概率掉落武器
            type = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
        } else if (!fromTreasure && Math.random() < 0.15) {
            // 普通箱子15%概率掉落武器
            type = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
        } else {
            // 掉落基础道具 - 手套权重降低，且检查数量限制
            // 权重：速度、范围、炸弹数量、手套
            // 宝箱原权重 [20, 20, 20, 40] -> [25, 25, 25, 25]（手套降低）
            // 普通原权重 [30, 30, 25, 15] -> [35, 35, 25, 5]（手套大幅降低）
            let weights = fromTreasure ? [25, 25, 25, 25] : [35, 35, 25, 5];
            
            // 如果手套已达上限，将手套权重设为0
            if (kickGlovesDropped >= 5) {
                weights[3] = 0;
            }
            
            const total = weights.reduce((a, b) => a + b, 0);
            let rand = Math.random() * total;
            type = baseTypes[0];
            
            for (let i = 0; i < weights.length; i++) {
                rand -= weights[i];
                if (rand <= 0) { type = baseTypes[i]; break; }
            }
        }
        
        // 如果掉落的是手套，增加计数
        if (type === POWERUP.KICK) {
            kickGlovesDropped++;
        }
        
        const group = new THREE.Group();
        
        // 道具颜色
        const colors = {
            [POWERUP.SPEED]: 0x00ffff,   // 青色 - 速度
            [POWERUP.RANGE]: 0xff6600,   // 橙色 - 范围
            [POWERUP.BOMB]: 0xffdd00,    // 金色 - 炸弹数量
            [POWERUP.KICK]: 0xff44ff,    // 粉紫 - 踢炸弹
            // 武器道具颜色
            [POWERUP.LASER]: 0x00ffff,       // 青色 - 激光枪
            [POWERUP.FLAMETHROWER]: 0xff4400, // 橙红 - 喷火枪
            [POWERUP.ROCKET]: 0xff0000       // 红色 - 火箭筒
        };
        
        // 道具emoji图标（与HUD一致）
        const icons = {
            [POWERUP.SPEED]: '👟',
            [POWERUP.RANGE]: '🔥',
            [POWERUP.BOMB]: '💣',
            [POWERUP.KICK]: '🧤',
            // 武器道具图标
            [POWERUP.LASER]: '🔫',
            [POWERUP.FLAMETHROWER]: '🧯',
            [POWERUP.ROCKET]: '🚀'
        };
        
        // 创建透明泡泡外壳
        const bubbleMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.35,
            roughness: 0.0,
            metalness: 0.0,
            transmission: 0.9,
            thickness: 0.5,
            envMapIntensity: 1.0,
            clearcoat: 1.0,
            clearcoatRoughness: 0.0,
            side: THREE.DoubleSide
        });
        
        const bubble = new THREE.Mesh(GeoCache.getSphere(1.2, 32), bubbleMat);
        bubble.castShadow = false;
        group.add(bubble);
        
        // 泡泡高光效果
        const highlightMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.6
        });
        const highlight = new THREE.Mesh(GeoCache.getSphere(0.2, 8), highlightMat);
        highlight.position.set(-0.5, 0.5, 0.6);
        group.add(highlight);
        
        // 小高光
        const highlight2 = new THREE.Mesh(GeoCache.getSphere(0.1, 6), highlightMat);
        highlight2.position.set(-0.3, 0.2, 0.8);
        group.add(highlight2);
        
        // 泡泡彩虹边缘光
        const rimMat = new THREE.MeshBasicMaterial({
            color: colors[type],
            transparent: true,
            opacity: 0.3,
            side: THREE.BackSide
        });
        const rim = new THREE.Mesh(GeoCache.getSphere(1.25, 32), rimMat);
        group.add(rim);
        
        // 道具图片映射
        const iconImages = {
            [POWERUP.SPEED]: 'images/鞋子.png',
            [POWERUP.RANGE]: 'images/蓝色试剂.png',
            [POWERUP.BOMB]: 'images/炸弹.png',
            [POWERUP.KICK]: 'images/手套.png',
            // 武器道具图片
            [POWERUP.LASER]: 'images/激光枪.png',
            [POWERUP.FLAMETHROWER]: 'images/喷火器.png',
            [POWERUP.ROCKET]: 'images/火箭筒.png'
        };
        
        // 创建2D精灵图标
        const createPowerupSprite = (imgSrc) => {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 256, 256);
            
            if (imgSrc) {
                // 使用图片
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, 28, 28, 200, 200);
                    texture.needsUpdate = true;
                };
                img.src = imgSrc;
            } else {
                // 武器道具使用emoji
                ctx.font = '160px "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(icons[type], 128, 138);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        };
        
        const texture = createPowerupSprite(iconImages[type]);
        const spriteMat = new THREE.SpriteMaterial({ 
            map: texture,
            transparent: true,
            depthTest: false,
            depthWrite: false
        });
        const sprite = new THREE.Sprite(spriteMat);
        sprite.scale.set(1.8, 1.8, 1);
        sprite.renderOrder = 999;
        group.add(sprite);
        
        const pos = gridToWorld(gx, gz);
        group.position.set(pos.x, 1.8, pos.z);
        
        scene.add(group);
        powerups.push({ type, mesh: group, gridX: gx, gridZ: gz, rotSpeed: 1.5 + Math.random(), bobPhase: Math.random() * Math.PI * 2, spawnTime: Date.now() });
    }


    // ==================== 地图生成 - 多主题支持 ====================
    let waterTrap = null; // 水泡陷阱
    let waterTrapTimer = 0;
    let carouselTimer = 0; // 旋转木马计时器
    let centerCarouselGroup = null; // 中央旋转木马引用
    
    // 主题配置
    const LEVEL_THEMES = {
        fairy: {
            name: '童话森林',
            floorColor: 0x7ec850,
            pathColor1: 0x90d468,
            pathColor2: 0x7ec850,
            wallCreator: 'createFairyMountainWall',
            obstacleCreator: 'createMushroomHouse',
            crateCreator: 'createBush',
            centerCreator: 'createFountain'
        },
        forest: {
            name: '神秘森林',
            floorColor: 0x2d5a27,
            pathColor1: 0x3d6a37,
            pathColor2: 0x2d5a27,
            wallCreator: 'createTreeWall',
            obstacleCreator: 'createWoodStump',
            crateCreator: 'createSmallBushOrFlower',
            centerCreator: 'createBigFlowerBed',
            hasPortals: true
        },
        ocean: {
            name: '海洋世界',
            floorColor: 0x1a5276,
            pathColor1: 0x2980b9,
            pathColor2: 0x1a5276,
            wallCreator: 'createCoralWall',
            obstacleCreator: 'createCoralCluster',
            crateCreator: 'createSpongeOrStarfish',
            centerCreator: 'createUnderwaterVolcano',
            hasVolcano: true
        },
        city: {
            name: '都市街区',
            floorColor: 0x505050,
            pathColor1: 0x606060,
            pathColor2: 0x505050,
            wallCreator: 'createOfficeBuilding',
            obstacleCreator: 'createConvenienceStore',
            crateCreator: 'createConeOrTrashBin',
            centerCreator: null,
            hasCars: true
        },
        park: {
            name: '欢乐公园',
            floorColor: 0x8fbc8f,
            pathColor1: 0xa0cca0,
            pathColor2: 0x8fbc8f,
            wallCreator: 'createHotAirBalloon',
            obstacleCreator: 'createTicketBooth',
            crateCreator: 'createCottonCandyOrGachapon',
            centerCreator: 'createCenterCarousel',
            hasCarousel: true
        },
        desert: {
            name: '沙漠绿洲',
            floorColor: 0xd4a574,
            pathColor1: 0xe0b584,
            pathColor2: 0xd4a574,
            wallCreator: 'createSandstoneWall',
            obstacleCreator: 'createCactus',
            crateCreator: 'createPotteryOrWoodCrate',
            centerCreator: null,
            hasSandstorm: true
        }
    };
    
    function createMap() {
        mapMeshes.forEach(m => scene.remove(m));
        mapMeshes = [];
        grid = [];
        waterTrapTimer = 0;
        carouselTimer = 0;
        centerCarouselGroup = null;
        // 清理飞行中的道具
        flyingPowerups.forEach(fp => scene.remove(fp.mesh));
        flyingPowerups = [];
        
        const theme = LEVEL_THEMES[currentLevel] || LEVEL_THEMES.fairy;
        
        // 地板
        const floorGeo = new THREE.PlaneGeometry(CONFIG.GRID_WIDTH * CONFIG.TILE_SIZE + 10, CONFIG.GRID_HEIGHT * CONFIG.TILE_SIZE + 10);
        const floorMat = new THREE.MeshStandardMaterial({ 
            color: theme.floorColor, 
            roughness: 0.9,
            metalness: 0.0
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.1;
        floor.receiveShadow = true;
        scene.add(floor);
        mapMeshes.push(floor);
        
        // 棋盘式地面
        const pathGeo = GeoCache.getBox(CONFIG.TILE_SIZE, 0.1, CONFIG.TILE_SIZE);
        const pathMat = new THREE.MeshStandardMaterial({ color: theme.pathColor1, roughness: 0.8 });
        const pathMat2 = new THREE.MeshStandardMaterial({ color: theme.pathColor2, roughness: 0.8 });
        
        for (let z = 0; z < CONFIG.GRID_HEIGHT; z++) {
            for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                const pos = gridToWorld(x, z);
                const isLight = (x + z) % 2 === 0;
                const tile = new THREE.Mesh(pathGeo, isLight ? pathMat : pathMat2);
                tile.position.set(pos.x, 0.05, pos.z);
                tile.receiveShadow = true;
                scene.add(tile);
                mapMeshes.push(tile);
            }
        }
        
        // 创建中央装饰
        const centerCreators = {
            'createFountain': createWaterTrap,
            'createAncientTree': createAncientTree,
            'createWhirlpool': createWhirlpool,
            'createFountainCity': createFountainCity,
            'createFerrisWheel': createFerrisWheel,
            'createOasis': createOasis,
            'createBigFlowerBed': createBigFlowerBed,
            'createUnderwaterVolcano': createUnderwaterVolcano,
            'createCenterCarousel': createCenterCarousel
        };
        if (centerCreators[theme.centerCreator]) {
            centerCreators[theme.centerCreator]();
        }
        
        // 为城市关卡创建道路
        if (theme.hasCars) {
            createCityRoads();
        }
        
        // 预先生成随机障碍物位置（确保地图可通行）
        const obstaclePositions = generateRandomObstacles();
        
        // 生成网格
        for (let z = 0; z < CONFIG.GRID_HEIGHT; z++) {
            const row = [];
            for (let x = 0; x < CONFIG.GRID_WIDTH; x++) {
                const pos = gridToWorld(x, z);
                
                // 边界墙
                if (x === 0 || x === CONFIG.GRID_WIDTH - 1 || z === 0 || z === CONFIG.GRID_HEIGHT - 1) {
                    const wall = createThemedWall(theme.wallCreator);
                    wall.position.set(pos.x, 0, pos.z);
                    scene.add(wall);
                    mapMeshes.push(wall);
                    row.push(TILE.WALL);
                }
                // 城市道路区域保持空旷
                else if (theme.hasCars && isCarRoadArea(x, z)) {
                    row.push(TILE.EMPTY);
                }
                // 随机不可破坏障碍物
                else if (obstaclePositions.has(`${x},${z}`)) {
                    const wall = createThemedObstacle(theme.obstacleCreator);
                    wall.position.set(pos.x, 0, pos.z);
                    scene.add(wall);
                    mapMeshes.push(wall);
                    row.push(TILE.WALL);
                }
                // 出生点保持空旷
                else if (isSpawnArea(x, z)) {
                    row.push(TILE.EMPTY);
                }
                // 中央区域保持空旷
                else if (isWaterTrapArea(x, z)) {
                    row.push(TILE.EMPTY);
                }
                // 沙尘龙卷风区域保持空旷
                else if (isSandstormArea(x, z)) {
                    row.push(TILE.EMPTY);
                }
                // 随机生成宝箱（10%概率，森林、海洋、城市、游乐园、沙漠关卡不生成）
                else if (!theme.hasPortals && !theme.hasVolcano && !theme.hasCars && !theme.hasCarousel && !theme.hasSandstorm && Math.random() < 0.1) {
                    const treasure = createTreasureChest();
                    treasure.position.set(pos.x, 0, pos.z);
                    treasure.userData = { gridX: x, gridZ: z, type: 'treasure' };
                    scene.add(treasure);
                    mapMeshes.push(treasure);
                    row.push(TILE.TREASURE);
                }
                // 随机生成可破坏物（45%概率）
                else if (Math.random() < 0.45) {
                    const crate = createThemedCrate(theme.crateCreator);
                    crate.position.set(pos.x, 0, pos.z);
                    crate.userData = { gridX: x, gridZ: z, type: 'crate' };
                    scene.add(crate);
                    mapMeshes.push(crate);
                    row.push(TILE.CRATE);
                }
                else {
                    row.push(TILE.EMPTY);
                }
            }
            grid.push(row);
        }
        
        // 为森林关卡生成传送门（在地图生成完成后）
        if (theme.hasPortals) {
            createPortals();
        }
        
        // 为城市关卡生成小汽车
        if (theme.hasCars) {
            createCityCars();
        }
        
        // 为沙漠关卡生成沙尘龙卷风
        if (theme.hasSandstorm) {
            createSandstorms();
        }
    }
    
    // 生成随机障碍物位置（保证地图连通性）
    function generateRandomObstacles() {
        const positions = new Set();
        const targetCount = Math.floor((CONFIG.GRID_WIDTH - 2) * (CONFIG.GRID_HEIGHT - 2) * 0.18); // 约18%的内部格子放障碍物
        
        // 收集所有候选位置
        const candidates = [];
        const theme = LEVEL_THEMES[currentLevel] || LEVEL_THEMES.fairy;
        
        for (let z = 1; z < CONFIG.GRID_HEIGHT - 1; z++) {
            for (let x = 1; x < CONFIG.GRID_WIDTH - 1; x++) {
                // 排除出生点区域
                if (isSpawnArea(x, z)) continue;
                // 排除中央区域
                if (isWaterTrapArea(x, z)) continue;
                // 排除沙尘龙卷风区域
                if (isSandstormArea(x, z)) continue;
                // 排除出生点周围的通道（确保玩家能移动）
                if (isSpawnPathArea(x, z)) continue;
                // 排除城市道路区域
                if (theme.hasCars && isCarRoadArea(x, z)) continue;
                
                candidates.push({ x, z });
            }
        }
        
        // 随机打乱候选位置
        for (let i = candidates.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
        }
        
        // 逐个尝试放置障碍物，每次放置后检查连通性
        let placed = 0;
        for (const pos of candidates) {
            if (placed >= targetCount) break;
            
            // 临时添加这个障碍物
            positions.add(`${pos.x},${pos.z}`);
            
            // 检查是否仍然连通
            if (isMapConnected(positions, theme)) {
                placed++;
            } else {
                // 不连通，撤销
                positions.delete(`${pos.x},${pos.z}`);
            }
        }
        
        return positions;
    }
    
    // 检查地图是否连通（使用BFS）
    function isMapConnected(obstaclePositions, theme) {
        // 找到所有可通行的格子
        const passable = [];
        for (let z = 1; z < CONFIG.GRID_HEIGHT - 1; z++) {
            for (let x = 1; x < CONFIG.GRID_WIDTH - 1; x++) {
                // 跳过障碍物位置
                if (obstaclePositions.has(`${x},${z}`)) continue;
                // 跳过中央水池区域（不可通行）
                if (isWaterTrapArea(x, z)) continue;
                
                passable.push({ x, z });
            }
        }
        
        if (passable.length === 0) return true;
        
        // 从第一个可通行格子开始BFS
        const visited = new Set();
        const queue = [passable[0]];
        visited.add(`${passable[0].x},${passable[0].z}`);
        
        const directions = [
            { dx: 1, dz: 0 }, { dx: -1, dz: 0 },
            { dx: 0, dz: 1 }, { dx: 0, dz: -1 }
        ];
        
        while (queue.length > 0) {
            const current = queue.shift();
            
            for (const dir of directions) {
                const nx = current.x + dir.dx;
                const nz = current.z + dir.dz;
                const key = `${nx},${nz}`;
                
                // 边界检查
                if (nx <= 0 || nx >= CONFIG.GRID_WIDTH - 1 || nz <= 0 || nz >= CONFIG.GRID_HEIGHT - 1) continue;
                // 已访问
                if (visited.has(key)) continue;
                // 是障碍物
                if (obstaclePositions.has(key)) continue;
                // 是中央水池区域
                if (isWaterTrapArea(nx, nz)) continue;
                
                visited.add(key);
                queue.push({ x: nx, z: nz });
            }
        }
        
        // 检查所有可通行格子是否都被访问到
        return visited.size === passable.length;
    }
    
    // 检查出生点通道区域（确保玩家初始能移动）
    function isSpawnPathArea(x, z) {
        // 四个角落的出生通道
        // 左上角通道
        if ((x === 1 && z <= 3) || (z === 1 && x <= 3)) return true;
        // 右上角通道
        if ((x === CONFIG.GRID_WIDTH - 2 && z <= 3) || (z === 1 && x >= CONFIG.GRID_WIDTH - 4)) return true;
        // 左下角通道
        if ((x === 1 && z >= CONFIG.GRID_HEIGHT - 4) || (z === CONFIG.GRID_HEIGHT - 2 && x <= 3)) return true;
        // 右下角通道
        if ((x === CONFIG.GRID_WIDTH - 2 && z >= CONFIG.GRID_HEIGHT - 4) || (z === CONFIG.GRID_HEIGHT - 2 && x >= CONFIG.GRID_WIDTH - 4)) return true;
        
        return false;
    }
    
    // 创建主题墙壁
    function createThemedWall(type) {
        switch(type) {
            case 'createTreeWall': return createTreeWall();
            case 'createCoralWall': return createCoralWall();
            case 'createBuildingWall': return createBuildingWall();
            case 'createOfficeBuilding': return createOfficeBuilding();
            case 'createFenceWall': return createFenceWall();
            case 'createSandstoneWall': return createSandstoneWall();
            case 'createHotAirBalloon': return createHotAirBalloon();
            case 'createFairyMountainWall': return createFairyMountainWall();
            default: return createStoneWall();
        }
    }
    
    // 创建主题障碍物
    function createThemedObstacle(type) {
        switch(type) {
            case 'createBigTree': return createBigTree();
            case 'createSeaRock': return createSeaRock();
            case 'createMailbox': return createMailbox();
            case 'createCarousel': return createCarousel();
            case 'createCactus': return createCactus();
            case 'createWoodStump': return createWoodStump();
            case 'createCoralCluster': return createCoralCluster();
            case 'createConvenienceStore': return createConvenienceStore();
            case 'createTicketBooth': return createTicketBooth();
            default: return createMushroomHouse();
        }
    }
    
    // 创建主题可破坏物
    function createThemedCrate(type) {
        switch(type) {
            case 'createMushroom': return createForestMushroom();
            case 'createSeaweed': return createSeaweed();
            case 'createTrashCan': return createTrashCan();
            case 'createBalloon': return createBalloonCrate();
            case 'createPottery': return createPottery();
            case 'createPotteryOrWoodCrate': return createPotteryOrWoodCrate();
            case 'createSmallBushOrFlower': return createSmallBushOrFlower();
            case 'createSpongeOrStarfish': return createSpongeOrStarfish();
            case 'createConeOrTrashBin': return createConeOrTrashBin();
            case 'createCottonCandyOrGachapon': return createCottonCandyOrGachapon();
            default: return createBush();
        }
    }
    
    // 判断是否是水泡陷阱区域（地图中央3x3）
    // 如果当前关卡没有中央建筑（centerCreator为null），则中央区域可通行
    function isWaterTrapArea(x, z) {
        // 城市关卡等没有中央建筑的关卡，中央区域可通行
        const theme = LEVEL_THEMES[currentLevel];
        if (theme && theme.centerCreator === null) {
            return false;
        }
        const centerX = Math.floor(CONFIG.GRID_WIDTH / 2);
        const centerZ = Math.floor(CONFIG.GRID_HEIGHT / 2);
        return Math.abs(x - centerX) <= 1 && Math.abs(z - centerZ) <= 1;
    }
    
    // 判断是否是沙尘龙卷风区域（沙漠关卡4个固定位置）
    function isSandstormArea(x, z) {
        const theme = LEVEL_THEMES[currentLevel];
        if (!theme || !theme.hasSandstorm) return false;
        
        // 龙卷风的4个固定位置
        const stormPositions = [
            { gx: 3, gz: 3 },
            { gx: CONFIG.GRID_WIDTH - 4, gz: 3 },
            { gx: 3, gz: CONFIG.GRID_HEIGHT - 4 },
            { gx: CONFIG.GRID_WIDTH - 4, gz: CONFIG.GRID_HEIGHT - 4 }
        ];
        
        // 检查是否在任一龙卷风位置附近（1格范围内）
        for (const pos of stormPositions) {
            if (Math.abs(x - pos.gx) <= 1 && Math.abs(z - pos.gz) <= 1) {
                return true;
            }
        }
        return false;
    }
    
    // 创建魔法喷泉 - 中央特殊区域（童话风格）
    function createWaterTrap() {
        const group = new THREE.Group();
        
        const centerX = Math.floor(CONFIG.GRID_WIDTH / 2);
        const centerZ = Math.floor(CONFIG.GRID_HEIGHT / 2);
        const pos = gridToWorld(centerX, centerZ);
        
        // 喷泉底座 - 白色大理石风格
        const baseMat = new THREE.MeshStandardMaterial({ 
            color: 0xf5f5f5, 
            roughness: 0.4, 
            metalness: 0.1 
        });
        const base = new THREE.Mesh(GeoCache.getCylinder(3.5, 4.0, 0.5, 16), baseMat);
        base.position.y = 0.25;
        base.receiveShadow = true;
        base.castShadow = true;
        group.add(base);
        
        // 喷泉池边
        const rimMat = new THREE.MeshStandardMaterial({ 
            color: 0xe8e8e8, 
            roughness: 0.3 
        });
        const rim = new THREE.Mesh(GeoCache.getCylinder(3.2, 3.0, 0.8, 16), rimMat);
        rim.position.y = 0.9;
        rim.castShadow = true;
        group.add(rim);
        
        // 水面 - 清澈的蓝色
        const waterMat = new THREE.MeshStandardMaterial({
            color: 0x66ccff,
            roughness: 0.0,
            metalness: 0.2,
            transparent: true,
            opacity: 0.8
        });
        const water = new THREE.Mesh(GeoCache.getCylinder(2.8, 2.8, 0.15, 16), waterMat);
        water.position.y = 0.7;
        group.add(water);
        
        // 中央喷泉柱
        const pillarMat = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, 
            roughness: 0.3,
            metalness: 0.2
        });
        const pillar = new THREE.Mesh(GeoCache.getCylinder(0.4, 0.5, 2.5, 12), pillarMat);
        pillar.position.y = 1.75;
        pillar.castShadow = true;
        group.add(pillar);
        
        // 喷泉顶部装饰球
        const topMat = new THREE.MeshStandardMaterial({ 
            color: 0xffd700, 
            roughness: 0.2, 
            metalness: 0.8,
            emissive: 0xffd700,
            emissiveIntensity: 0.2
        });
        const topBall = new THREE.Mesh(GeoCache.getSphere(0.5, 12), topMat);
        topBall.position.y = 3.2;
        topBall.castShadow = true;
        group.add(topBall);
        
        // 水花泡泡装饰
        const bubbleMat = new THREE.MeshStandardMaterial({ 
            color: 0xaaddff, 
            roughness: 0.0, 
            metalness: 0.3, 
            transparent: true,
            opacity: 0.6
        });
        for (let i = 0; i < 8; i++) {
            const bubble = new THREE.Mesh(GeoCache.getSphere(0.12 + Math.random() * 0.15, 8), bubbleMat);
            const angle = (i / 8) * Math.PI * 2;
            const r = 0.8 + Math.random() * 0.5;
            bubble.position.set(Math.cos(angle) * r, 2.0 + Math.random() * 1.0, Math.sin(angle) * r);
            bubble.userData = { floatOffset: Math.random() * Math.PI * 2 };
            group.add(bubble);
        }
        
        // 花朵装饰在池边
        const flowerColors = [0xff69b4, 0xff6b6b, 0xffeaa7, 0xdfe6e9];
        for (let i = 0; i < 6; i++) {
            const flowerMat = new THREE.MeshStandardMaterial({ 
                color: flowerColors[i % flowerColors.length], 
                roughness: 0.5 
            });
            const flower = new THREE.Mesh(GeoCache.getSphere(0.25, 6), flowerMat);
            const angle = (i / 6) * Math.PI * 2;
            flower.position.set(Math.cos(angle) * 3.3, 1.1, Math.sin(angle) * 3.3);
            group.add(flower);
        }
        
        group.position.set(pos.x, 0, pos.z);
        group.scale.set(1.5, 1.5, 1.5); // 放大喷泉
        scene.add(group);
        mapMeshes.push(group);
        waterTrap = group;
    }

    function isSpawnArea(x, z) {
        const corners = [
            [1, 1], [2, 1], [1, 2],
            [CONFIG.GRID_WIDTH - 2, 1], [CONFIG.GRID_WIDTH - 3, 1], [CONFIG.GRID_WIDTH - 2, 2],
            [1, CONFIG.GRID_HEIGHT - 2], [2, CONFIG.GRID_HEIGHT - 2], [1, CONFIG.GRID_HEIGHT - 3],
            [CONFIG.GRID_WIDTH - 2, CONFIG.GRID_HEIGHT - 2], [CONFIG.GRID_WIDTH - 3, CONFIG.GRID_HEIGHT - 2], [CONFIG.GRID_WIDTH - 2, CONFIG.GRID_HEIGHT - 3]
        ];
        return corners.some(c => c[0] === x && c[1] === z);
    }

    // 石头墙 - 边界障碍物（童话风格）- 备用
    function createStoneWall() {
        const group = new THREE.Group();
        
        const stoneMat = new THREE.MeshStandardMaterial({ 
            color: 0x8899aa, 
            roughness: 0.8, 
            metalness: 0.1 
        });
        const mossMat = new THREE.MeshStandardMaterial({ 
            color: 0x5a8a4a, 
            roughness: 0.9 
        });
        
        // 主石块
        const stone1 = new THREE.Mesh(GeoCache.getBox(2.8, 2.2, 2.8), stoneMat);
        stone1.position.y = 1.1;
        stone1.rotation.y = Math.random() * 0.3;
        stone1.castShadow = true;
        group.add(stone1);
        
        // 顶部小石块
        const stone2 = new THREE.Mesh(GeoCache.getBox(1.8, 1.0, 1.8), stoneMat);
        stone2.position.set(0.3, 2.5, 0.2);
        stone2.rotation.y = Math.random() * 0.5;
        stone2.castShadow = true;
        group.add(stone2);
        
        // 苔藓装饰
        const moss = new THREE.Mesh(GeoCache.getSphere(0.5, 6), mossMat);
        moss.position.set(-0.8, 1.8, 0.9);
        moss.scale.set(1, 0.5, 1);
        group.add(moss);
        
        return group;
    }
    
    // 童话山 - 边界障碍物（童话城堡关卡使用GLB模型）
    function createFairyMountainWall() {
        // 尝试使用GLB模型
        const mountainClone = cloneFairyMountainModel();
        if (mountainClone) {
            const group = new THREE.Group();
            group.add(mountainClone);
            // 随机旋转增加变化
            group.rotation.y = Math.random() * Math.PI * 2;
            return group;
        }
        
        // 如果模型未加载，使用备用石头墙
        return createStoneWall();
    }
    
    // 蘑菇屋 - 固定障碍物（童话风格）
    function createMushroomHouse() {
        const group = new THREE.Group();
        
        // 随机蘑菇颜色
        const capColors = [0xff6b6b, 0xff9f43, 0xee5a24, 0xf368e0, 0xff6b81];
        const capColor = capColors[Math.floor(Math.random() * capColors.length)];
        
        const stemMat = new THREE.MeshStandardMaterial({ 
            color: 0xffeaa7, 
            roughness: 0.7 
        });
        const capMat = new THREE.MeshStandardMaterial({ 
            color: capColor, 
            roughness: 0.5,
            metalness: 0.1
        });
        const spotMat = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, 
            roughness: 0.3 
        });
        
        // 蘑菇柄
        const stem = new THREE.Mesh(GeoCache.getCylinder(0.8, 1.0, 2.0, 12), stemMat);
        stem.position.y = 1.0;
        stem.castShadow = true;
        group.add(stem);
        
        // 蘑菇帽
        const cap = new THREE.Mesh(GeoCache.getSphere(1.8, 16), capMat);
        cap.position.y = 2.5;
        cap.scale.set(1, 0.6, 1);
        cap.castShadow = true;
        group.add(cap);
        
        // 白色斑点
        for (let i = 0; i < 5; i++) {
            const spot = new THREE.Mesh(GeoCache.getSphere(0.25, 8), spotMat);
            const angle = (i / 5) * Math.PI * 2 + Math.random() * 0.5;
            const r = 1.0 + Math.random() * 0.4;
            spot.position.set(
                Math.cos(angle) * r,
                2.3 + Math.random() * 0.5,
                Math.sin(angle) * r
            );
            group.add(spot);
        }
        
        // 门（可爱的小门）
        const doorMat = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.8 });
        const door = new THREE.Mesh(GeoCache.getBox(0.6, 1.0, 0.1), doorMat);
        door.position.set(0, 0.5, 1.0);
        group.add(door);
        
        // 门把手
        const knobMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 });
        const knob = new THREE.Mesh(GeoCache.getSphere(0.08, 6), knobMat);
        knob.position.set(0.2, 0.5, 1.1);
        group.add(knob);
        
        return group;
    }
    
    // 草丛 - 可破坏的障碍物（童话风格）
    function createBush() {
        const group = new THREE.Group();
        
        const leafMat = new THREE.MeshStandardMaterial({ 
            color: 0x27ae60, 
            roughness: 0.8 
        });
        const leafMat2 = new THREE.MeshStandardMaterial({ 
            color: 0x2ecc71, 
            roughness: 0.8 
        });
        const flowerMat = new THREE.MeshStandardMaterial({ 
            color: 0xf1c40f, 
            roughness: 0.5,
            emissive: 0xf1c40f,
            emissiveIntensity: 0.2
        });
        
        // 主体灌木丛
        const bush1 = new THREE.Mesh(GeoCache.getSphere(1.3, 8), leafMat);
        bush1.position.set(0, 1.0, 0);
        bush1.scale.set(1, 0.8, 1);
        bush1.castShadow = true;
        group.add(bush1);
        
        const bush2 = new THREE.Mesh(GeoCache.getSphere(1.0, 8), leafMat2);
        bush2.position.set(0.5, 1.3, 0.3);
        bush2.castShadow = true;
        group.add(bush2);
        
        const bush3 = new THREE.Mesh(GeoCache.getSphere(0.9, 8), leafMat);
        bush3.position.set(-0.4, 1.2, -0.3);
        bush3.castShadow = true;
        group.add(bush3);
        
        // 小花装饰
        if (Math.random() > 0.5) {
            const flower = new THREE.Mesh(GeoCache.getSphere(0.2, 6), flowerMat);
            flower.position.set(0.6, 1.8, 0.5);
            group.add(flower);
        }
        
        return group;
    }

    // 木桶 - 保留但不再使用
    function createBarrel() {
        return createBush(); // 现在使用草丛替代
    }
    
    // ==================== 森林主题装饰物 ====================
    function createTreeWall() {
        const group = new THREE.Group();
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.9 });
        const leafMat = new THREE.MeshStandardMaterial({ color: 0x1e5631, roughness: 0.8 });
        
        const trunk = new THREE.Mesh(GeoCache.getCylinder(0.8, 1.0, 2.5, 8), trunkMat);
        trunk.position.y = 1.25;
        trunk.castShadow = true;
        group.add(trunk);
        
        const leaves = new THREE.Mesh(GeoCache.getSphere(1.8, 8), leafMat);
        leaves.position.y = 3.0;
        leaves.scale.set(1, 0.8, 1);
        leaves.castShadow = true;
        group.add(leaves);
        
        return group;
    }
    
    function createBigTree() {
        const group = new THREE.Group();
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 0.9 });
        const leafMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32, roughness: 0.7 });
        
        const trunk = new THREE.Mesh(GeoCache.getCylinder(0.6, 0.8, 3.0, 8), trunkMat);
        trunk.position.y = 1.5;
        trunk.castShadow = true;
        group.add(trunk);
        
        for (let i = 0; i < 3; i++) {
            const leaf = new THREE.Mesh(GeoCache.getCone(1.5 - i * 0.3, 1.5, 8), leafMat);
            leaf.position.y = 2.5 + i * 0.8;
            leaf.castShadow = true;
            group.add(leaf);
        }
        
        return group;
    }
    
    function createForestMushroom() {
        const group = new THREE.Group();
        const stemMat = new THREE.MeshStandardMaterial({ color: 0xf5f5dc, roughness: 0.7 });
        const capMat = new THREE.MeshStandardMaterial({ color: 0x8b0000, roughness: 0.5 });
        const spotMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
        
        const stem = new THREE.Mesh(GeoCache.getCylinder(0.4, 0.5, 1.2, 8), stemMat);
        stem.position.y = 0.6;
        group.add(stem);
        
        const cap = new THREE.Mesh(GeoCache.getSphere(1.2, 8), capMat);
        cap.position.y = 1.4;
        cap.scale.set(1, 0.5, 1);
        group.add(cap);
        
        for (let i = 0; i < 5; i++) {
            const spot = new THREE.Mesh(GeoCache.getSphere(0.15, 6), spotMat);
            const angle = (i / 5) * Math.PI * 2;
            spot.position.set(Math.cos(angle) * 0.7, 1.5, Math.sin(angle) * 0.7);
            group.add(spot);
        }
        
        return group;
    }
    
    function createAncientTree() {
        const group = new THREE.Group();
        const centerX = Math.floor(CONFIG.GRID_WIDTH / 2);
        const centerZ = Math.floor(CONFIG.GRID_HEIGHT / 2);
        const pos = gridToWorld(centerX, centerZ);
        
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x3e2723, roughness: 0.9 });
        const leafMat = new THREE.MeshStandardMaterial({ color: 0x1b5e20, roughness: 0.7 });
        const glowMat = new THREE.MeshStandardMaterial({ color: 0x76ff03, emissive: 0x76ff03, emissiveIntensity: 0.5, transparent: true, opacity: 0.7 });
        
        const trunk = new THREE.Mesh(GeoCache.getCylinder(1.5, 2.0, 5, 12), trunkMat);
        trunk.position.y = 2.5;
        trunk.castShadow = true;
        group.add(trunk);
        
        const crown = new THREE.Mesh(GeoCache.getSphere(4, 12), leafMat);
        crown.position.y = 6;
        crown.scale.set(1, 0.7, 1);
        crown.castShadow = true;
        group.add(crown);
        
        for (let i = 0; i < 8; i++) {
            const firefly = new THREE.Mesh(GeoCache.getSphere(0.15, 6), glowMat);
            const angle = (i / 8) * Math.PI * 2;
            firefly.position.set(Math.cos(angle) * 2.5, 4 + Math.random() * 3, Math.sin(angle) * 2.5);
            firefly.userData = { floatOffset: Math.random() * Math.PI * 2 };
            group.add(firefly);
        }
        
        group.position.set(pos.x, 0, pos.z);
        group.scale.set(1.2, 1.2, 1.2);
        scene.add(group);
        mapMeshes.push(group);
        waterTrap = group;
    }
    
    // 热气球边缘墙
    function createHotAirBalloon() {
        const group = new THREE.Group();
        const colors = [0xef5350, 0x42a5f5, 0xffee58, 0x66bb6a, 0xab47bc, 0xff7043];
        const balloonColor = colors[Math.floor(Math.random() * colors.length)];
        
        // 气球主体
        const balloonMat = new THREE.MeshStandardMaterial({ 
            color: balloonColor, 
            roughness: 0.4,
            metalness: 0.1
        });
        const balloon = new THREE.Mesh(GeoCache.getSphere(1.8, 16), balloonMat);
        balloon.position.y = 4.0;
        balloon.scale.set(1, 1.2, 1);
        balloon.castShadow = true;
        group.add(balloon);
        
        // 气球条纹装饰
        const stripeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
        for (let i = 0; i < 4; i++) {
            const stripe = new THREE.Mesh(GeoCache.getBox(0.1, 2.5, 1.6), stripeMat);
            stripe.position.y = 4.0;
            stripe.rotation.y = (i / 4) * Math.PI;
            group.add(stripe);
        }
        
        // 吊篮绳索
        const ropeMat = new THREE.MeshBasicMaterial({ color: 0x8d6e63 });
        for (let i = 0; i < 4; i++) {
            const rope = new THREE.Mesh(GeoCache.getCylinder(0.03, 0.03, 2.0, 4), ropeMat);
            const angle = (i / 4) * Math.PI * 2 + Math.PI / 4;
            rope.position.set(Math.cos(angle) * 0.6, 1.8, Math.sin(angle) * 0.6);
            group.add(rope);
        }
        
        // 吊篮
        const basketMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63, roughness: 0.8 });
        const basket = new THREE.Mesh(GeoCache.getCylinder(0.7, 0.8, 0.8, 8), basketMat);
        basket.position.y = 0.6;
        basket.castShadow = true;
        group.add(basket);
        
        // 吊篮底部
        const basketBottom = new THREE.Mesh(GeoCache.getCylinder(0.75, 0.75, 0.1, 8), basketMat);
        basketBottom.position.y = 0.2;
        group.add(basketBottom);
        
        return group;
    }
    
    // 售票亭（不可破坏）
    function createTicketBooth() {
        const group = new THREE.Group();
        
        // 主体
        const boothMat = new THREE.MeshStandardMaterial({ color: 0xffcc80, roughness: 0.6 });
        const booth = new THREE.Mesh(GeoCache.getBox(2.5, 2.5, 2.5), boothMat);
        booth.position.y = 1.25;
        booth.castShadow = true;
        group.add(booth);
        
        // 屋顶
        const roofMat = new THREE.MeshStandardMaterial({ color: 0xef5350, roughness: 0.5 });
        const roof = new THREE.Mesh(GeoCache.getCone(2.0, 1.2, 4), roofMat);
        roof.position.y = 3.1;
        roof.rotation.y = Math.PI / 4;
        roof.castShadow = true;
        group.add(roof);
        
        // 窗口
        const windowMat = new THREE.MeshStandardMaterial({ color: 0x42a5f5, roughness: 0.2, metalness: 0.3 });
        const window1 = new THREE.Mesh(GeoCache.getBox(1.2, 0.8, 0.1), windowMat);
        window1.position.set(0, 1.5, 1.26);
        group.add(window1);
        
        // 售票标志
        const signMat = new THREE.MeshStandardMaterial({ color: 0xffeb3b, roughness: 0.4, emissive: 0xffeb3b, emissiveIntensity: 0.2 });
        const sign = new THREE.Mesh(GeoCache.getBox(1.5, 0.4, 0.1), signMat);
        sign.position.set(0, 2.3, 1.26);
        group.add(sign);
        
        return group;
    }
    
    // 棉花糖或扭蛋机（可破坏）
    function createCottonCandyOrGachapon() {
        const group = new THREE.Group();
        
        if (Math.random() < 0.5) {
            // 棉花糖
            const colors = [0xffb6c1, 0x87ceeb, 0x98fb98, 0xdda0dd, 0xfffacd];
            const cottonColor = colors[Math.floor(Math.random() * colors.length)];
            
            // 棉花糖主体
            const cottonMat = new THREE.MeshStandardMaterial({ 
                color: cottonColor, 
                roughness: 0.9,
                transparent: true,
                opacity: 0.9
            });
            const cotton = new THREE.Mesh(GeoCache.getSphere(1.0, 12), cottonMat);
            cotton.position.y = 2.2;
            cotton.scale.set(1, 1.3, 1);
            cotton.castShadow = true;
            group.add(cotton);
            
            // 棉花糖蓬松效果
            for (let i = 0; i < 5; i++) {
                const puff = new THREE.Mesh(GeoCache.getSphere(0.4, 8), cottonMat);
                const angle = (i / 5) * Math.PI * 2;
                puff.position.set(Math.cos(angle) * 0.6, 2.0 + Math.random() * 0.5, Math.sin(angle) * 0.6);
                group.add(puff);
            }
            
            // 木棍
            const stickMat = new THREE.MeshStandardMaterial({ color: 0xd4a574, roughness: 0.7 });
            const stick = new THREE.Mesh(GeoCache.getCylinder(0.1, 0.1, 2.0, 6), stickMat);
            stick.position.y = 1.0;
            group.add(stick);
        } else {
            // 扭蛋机
            // 底座
            const baseMat = new THREE.MeshStandardMaterial({ color: 0xef5350, roughness: 0.4, metalness: 0.3 });
            const base = new THREE.Mesh(GeoCache.getCylinder(0.8, 0.9, 0.5, 12), baseMat);
            base.position.y = 0.25;
            base.castShadow = true;
            group.add(base);
            
            // 主体
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xef5350, roughness: 0.4 });
            const body = new THREE.Mesh(GeoCache.getCylinder(0.7, 0.8, 1.0, 12), bodyMat);
            body.position.y = 1.0;
            body.castShadow = true;
            group.add(body);
            
            // 透明球体（装扭蛋的部分）
            const globeMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                roughness: 0.1, 
                metalness: 0.1,
                transparent: true,
                opacity: 0.6
            });
            const globe = new THREE.Mesh(GeoCache.getSphere(0.9, 16), globeMat);
            globe.position.y = 2.2;
            group.add(globe);
            
            // 里面的小扭蛋
            const eggColors = [0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3, 0xf38181];
            for (let i = 0; i < 6; i++) {
                const eggMat = new THREE.MeshStandardMaterial({ color: eggColors[i % eggColors.length], roughness: 0.3 });
                const egg = new THREE.Mesh(GeoCache.getSphere(0.2, 8), eggMat);
                egg.position.set(
                    (Math.random() - 0.5) * 0.8,
                    2.0 + Math.random() * 0.4,
                    (Math.random() - 0.5) * 0.8
                );
                group.add(egg);
            }
            
            // 顶盖
            const topMat = new THREE.MeshStandardMaterial({ color: 0xef5350, roughness: 0.4 });
            const top = new THREE.Mesh(GeoCache.getCylinder(0.5, 0.7, 0.3, 12), topMat);
            top.position.y = 3.0;
            group.add(top);
        }
        
        return group;
    }
    
    // 中央旋转木马
    function createCenterCarousel() {
        const group = new THREE.Group();
        const centerX = Math.floor(CONFIG.GRID_WIDTH / 2);
        const centerZ = Math.floor(CONFIG.GRID_HEIGHT / 2);
        const pos = gridToWorld(centerX, centerZ);
        
        // 底座
        const baseMat = new THREE.MeshStandardMaterial({ color: 0xffd54f, roughness: 0.3, metalness: 0.4 });
        const base = new THREE.Mesh(GeoCache.getCylinder(4.5, 5.0, 0.6, 24), baseMat);
        base.position.y = 0.3;
        base.receiveShadow = true;
        base.castShadow = true;
        group.add(base);
        
        // 装饰边缘
        const edgeMat = new THREE.MeshStandardMaterial({ color: 0xef5350, roughness: 0.4, metalness: 0.3 });
        const edge = new THREE.Mesh(GeoCache.getCylinder(5.0, 5.2, 0.3, 24), edgeMat);
        edge.position.y = 0.15;
        group.add(edge);
        
        // 中央柱子
        const poleMat = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.2, metalness: 0.7 });
        const centerPole = new THREE.Mesh(GeoCache.getCylinder(0.5, 0.6, 5, 12), poleMat);
        centerPole.position.y = 3.0;
        centerPole.castShadow = true;
        group.add(centerPole);
        
        // 顶棚
        const roofMat = new THREE.MeshStandardMaterial({ color: 0xef5350, roughness: 0.4 });
        const roof = new THREE.Mesh(GeoCache.getCone(5.5, 2.5, 24), roofMat);
        roof.position.y = 6.5;
        roof.castShadow = true;
        group.add(roof);
        
        // 顶棚装饰条纹
        const stripeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
        for (let i = 0; i < 8; i++) {
            const stripe = new THREE.Mesh(GeoCache.getBox(0.15, 2.6, 4.5), stripeMat);
            stripe.position.y = 6.5;
            stripe.rotation.y = (i / 8) * Math.PI * 2;
            stripe.rotation.x = 0.45;
            group.add(stripe);
        }
        
        // 顶部装饰球
        const topBallMat = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.2, metalness: 0.8, emissive: 0xffd700, emissiveIntensity: 0.3 });
        const topBall = new THREE.Mesh(GeoCache.getSphere(0.5, 12), topBallMat);
        topBall.position.y = 8.0;
        group.add(topBall);
        
        // 旋转木马的马匹
        const horseColors = [0xffffff, 0xffcc80, 0xce93d8, 0x81d4fa, 0xa5d6a7, 0xffab91];
        for (let i = 0; i < 6; i++) {
            const horseGroup = new THREE.Group();
            const horseMat = new THREE.MeshStandardMaterial({ color: horseColors[i], roughness: 0.5 });
            
            // 马身体
            const body = new THREE.Mesh(GeoCache.getBox(0.8, 0.6, 1.5), horseMat);
            body.position.y = 0;
            horseGroup.add(body);
            
            // 马头
            const head = new THREE.Mesh(GeoCache.getBox(0.4, 0.5, 0.6), horseMat);
            head.position.set(0, 0.3, 0.8);
            head.rotation.x = 0.3;
            horseGroup.add(head);
            
            // 马腿
            const legMat = new THREE.MeshStandardMaterial({ color: horseColors[i], roughness: 0.5 });
            const legPositions = [[-0.25, -0.6, 0.4], [0.25, -0.6, 0.4], [-0.25, -0.6, -0.4], [0.25, -0.6, -0.4]];
            legPositions.forEach(lp => {
                const leg = new THREE.Mesh(GeoCache.getCylinder(0.1, 0.1, 0.6, 6), legMat);
                leg.position.set(lp[0], lp[1], lp[2]);
                horseGroup.add(leg);
            });
            
            // 支撑杆
            const supportPole = new THREE.Mesh(GeoCache.getCylinder(0.08, 0.08, 3, 8), poleMat);
            supportPole.position.y = 1.5;
            horseGroup.add(supportPole);
            
            // 放置马匹
            const angle = (i / 6) * Math.PI * 2;
            horseGroup.position.set(Math.cos(angle) * 3.2, 2.0 + Math.sin(i * 0.5) * 0.3, Math.sin(angle) * 3.2);
            horseGroup.rotation.y = -angle + Math.PI / 2;
            group.add(horseGroup);
        }
        
        group.position.set(pos.x, 0, pos.z);
        scene.add(group);
        mapMeshes.push(group);
        waterTrap = group;
        centerCarouselGroup = group; // 保存引用用于旋转动画
    }
    
    // 旋转木马抛出道具
    function launchCarouselPowerups() {
        // 找到所有空位
        const emptySpots = [];
        for (let z = 1; z < CONFIG.GRID_HEIGHT - 1; z++) {
            for (let x = 1; x < CONFIG.GRID_WIDTH - 1; x++) {
                if (grid[z][x] === TILE.EMPTY && !isWaterTrapArea(x, z) && !isSpawnArea(x, z)) {
                    // 确保没有道具在这个位置
                    if (!powerups.some(p => p.gridX === x && p.gridZ === z)) {
                        emptySpots.push({ x, z });
                    }
                }
            }
        }
        
        if (emptySpots.length < 3) return;
        
        // 随机选择3个空位
        const shuffled = emptySpots.sort(() => Math.random() - 0.5);
        const targets = shuffled.slice(0, 3);
        
        // 获取旋转木马中心位置
        const centerX = Math.floor(CONFIG.GRID_WIDTH / 2);
        const centerZ = Math.floor(CONFIG.GRID_HEIGHT / 2);
        const startPos = gridToWorld(centerX, centerZ);
        
        // 为每个目标创建飞行道具
        targets.forEach((target, index) => {
            const endPos = gridToWorld(target.x, target.z);
            
            // 创建飞行道具的视觉效果（彩色星星）
            const colors = [0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3, 0xf38181, 0xaa96da];
            const starMat = new THREE.MeshStandardMaterial({ 
                color: colors[index % colors.length], 
                roughness: 0.3,
                emissive: colors[index % colors.length],
                emissiveIntensity: 0.5
            });
            
            const starGroup = new THREE.Group();
            
            // 星星主体
            const star = new THREE.Mesh(GeoCache.getSphere(0.5, 8), starMat);
            starGroup.add(star);
            
            // 添加拖尾粒子效果
            const trailMat = new THREE.MeshBasicMaterial({ 
                color: colors[index % colors.length], 
                transparent: true, 
                opacity: 0.6 
            });
            for (let i = 0; i < 3; i++) {
                const trail = new THREE.Mesh(GeoCache.getSphere(0.2 - i * 0.05, 6), trailMat);
                trail.position.y = -0.3 * (i + 1);
                starGroup.add(trail);
            }
            
            // 初始位置在旋转木马顶部
            starGroup.position.set(startPos.x, 8, startPos.z);
            scene.add(starGroup);
            
            // 创建飞行道具对象
            const flyingPowerup = {
                mesh: starGroup,
                startX: startPos.x,
                startY: 8,
                startZ: startPos.z,
                endX: endPos.x,
                endY: 1.8, // 道具最终高度
                endZ: endPos.z,
                targetGridX: target.x,
                targetGridZ: target.z,
                progress: 0,
                duration: 1.0 + index * 0.2, // 错开时间
                delay: index * 0.15 // 延迟发射
            };
            
            flyingPowerups.push(flyingPowerup);
        });
        
        // 播放音效
        soundManager.playPowerup();
    }
    
    // 更新飞行中的道具
    function updateFlyingPowerups(dt) {
        for (let i = flyingPowerups.length - 1; i >= 0; i--) {
            const fp = flyingPowerups[i];
            
            // 处理延迟
            if (fp.delay > 0) {
                fp.delay -= dt;
                continue;
            }
            
            // 更新进度
            fp.progress += dt / fp.duration;
            
            if (fp.progress >= 1) {
                // 飞行完成，移除飞行效果并生成实际道具
                scene.remove(fp.mesh);
                flyingPowerups.splice(i, 1);
                
                // 在目标位置生成道具
                spawnPowerup(fp.targetGridX, fp.targetGridZ, false);
            } else {
                // 抛物线运动
                const t = fp.progress;
                
                // 水平方向线性插值
                const x = fp.startX + (fp.endX - fp.startX) * t;
                const z = fp.startZ + (fp.endZ - fp.startZ) * t;
                
                // 垂直方向抛物线（先上升后下降）
                const peakHeight = 15; // 最高点
                const baseHeight = fp.startY + (fp.endY - fp.startY) * t;
                const arcHeight = Math.sin(t * Math.PI) * peakHeight;
                const y = baseHeight + arcHeight;
                
                fp.mesh.position.set(x, y, z);
                
                // 旋转效果
                fp.mesh.rotation.y += dt * 8;
                fp.mesh.rotation.x += dt * 5;
                
                // 缩放脉冲效果
                const scale = 1 + Math.sin(t * Math.PI * 4) * 0.2;
                fp.mesh.scale.set(scale, scale, scale);
            }
        }
    }
    
    // ==================== 森林关卡专属装饰物 ====================
    
    // 木桩 - 不可破坏障碍物
    function createWoodStump() {
        const group = new THREE.Group();
        const stumpMat = new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 0.9 });
        const ringMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63, roughness: 0.8 });
        
        // 木桩主体
        const stump = new THREE.Mesh(GeoCache.getCylinder(1.2, 1.4, 2.0, 12), stumpMat);
        stump.position.y = 1.0;
        stump.castShadow = true;
        group.add(stump);
        
        // 顶部年轮
        const top = new THREE.Mesh(GeoCache.getCylinder(1.2, 1.2, 0.1, 12), ringMat);
        top.position.y = 2.05;
        group.add(top);
        
        // 年轮纹理
        for (let i = 0; i < 3; i++) {
            const ring = new THREE.Mesh(
                new THREE.RingGeometry(0.3 + i * 0.3, 0.35 + i * 0.3, 16),
                new THREE.MeshStandardMaterial({ color: 0x4e342e, roughness: 0.9, side: THREE.DoubleSide })
            );
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = 2.1;
            group.add(ring);
        }
        
        // 随机添加小蘑菇
        if (Math.random() > 0.5) {
            const mushroomMat = new THREE.MeshStandardMaterial({ color: 0xff6b6b, roughness: 0.5 });
            const mushroom = new THREE.Mesh(GeoCache.getSphere(0.2, 6), mushroomMat);
            mushroom.position.set(1.0, 0.2, 0.5);
            mushroom.scale.set(1, 0.6, 1);
            group.add(mushroom);
        }
        
        return group;
    }
    
    // 小灌木丛或花丛 - 可破坏物
    function createSmallBushOrFlower() {
        const group = new THREE.Group();
        
        if (Math.random() > 0.5) {
            // 小灌木丛
            const bushColors = [0x228b22, 0x2e8b57, 0x3cb371, 0x32cd32];
            const bushMat = new THREE.MeshStandardMaterial({ 
                color: bushColors[Math.floor(Math.random() * bushColors.length)], 
                roughness: 0.8 
            });
            
            // 主体灌木
            const mainBush = new THREE.Mesh(GeoCache.getSphere(1.0, 8), bushMat);
            mainBush.position.y = 0.8;
            mainBush.scale.set(1.2, 0.8, 1.2);
            mainBush.castShadow = true;
            group.add(mainBush);
            
            // 小灌木
            for (let i = 0; i < 3; i++) {
                const smallBush = new THREE.Mesh(GeoCache.getSphere(0.5, 6), bushMat);
                const angle = (i / 3) * Math.PI * 2;
                smallBush.position.set(Math.cos(angle) * 0.6, 0.4, Math.sin(angle) * 0.6);
                smallBush.scale.set(1, 0.7, 1);
                group.add(smallBush);
            }
        } else {
            // 花丛
            const flowerColors = [0xff69b4, 0xff1493, 0xffd700, 0xff6347, 0x9370db, 0x00ced1];
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x228b22, roughness: 0.7 });
            
            // 绿叶底座
            const leaves = new THREE.Mesh(GeoCache.getSphere(0.8, 8), leafMat);
            leaves.position.y = 0.4;
            leaves.scale.set(1.3, 0.5, 1.3);
            group.add(leaves);
            
            // 多朵花
            for (let i = 0; i < 5; i++) {
                const flowerMat = new THREE.MeshStandardMaterial({ 
                    color: flowerColors[Math.floor(Math.random() * flowerColors.length)], 
                    roughness: 0.4 
                });
                const flower = new THREE.Mesh(GeoCache.getSphere(0.25, 6), flowerMat);
                const angle = (i / 5) * Math.PI * 2;
                const radius = 0.3 + Math.random() * 0.4;
                flower.position.set(
                    Math.cos(angle) * radius, 
                    0.6 + Math.random() * 0.4, 
                    Math.sin(angle) * radius
                );
                group.add(flower);
            }
            
            // 花心
            const centerMat = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.3 });
            const center = new THREE.Mesh(GeoCache.getSphere(0.15, 6), centerMat);
            center.position.y = 0.9;
            group.add(center);
        }
        
        return group;
    }
    
    // 大花丛 - 中央装饰（3x3区域）
    function createBigFlowerBed() {
        const group = new THREE.Group();
        const centerX = Math.floor(CONFIG.GRID_WIDTH / 2);
        const centerZ = Math.floor(CONFIG.GRID_HEIGHT / 2);
        const pos = gridToWorld(centerX, centerZ);
        
        // 花坛边框
        const borderMat = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.9 });
        const borderGeo = new THREE.TorusGeometry(4.5, 0.4, 8, 32);
        const border = new THREE.Mesh(borderGeo, borderMat);
        border.rotation.x = -Math.PI / 2;
        border.position.y = 0.3;
        group.add(border);
        
        // 土壤
        const soilMat = new THREE.MeshStandardMaterial({ color: 0x3e2723, roughness: 0.95 });
        const soil = new THREE.Mesh(GeoCache.getCylinder(4.2, 4.2, 0.3, 32), soilMat);
        soil.position.y = 0.15;
        group.add(soil);
        
        // 草地
        const grassMat = new THREE.MeshStandardMaterial({ color: 0x228b22, roughness: 0.8 });
        const grass = new THREE.Mesh(GeoCache.getCylinder(4.0, 4.0, 0.2, 32), grassMat);
        grass.position.y = 0.35;
        group.add(grass);
        
        // 花朵颜色
        const flowerColors = [0xff69b4, 0xff1493, 0xffd700, 0xff6347, 0x9370db, 0x00ced1, 0xff4500, 0xda70d6];
        
        // 中央大花
        const centerFlowerMat = new THREE.MeshStandardMaterial({ color: 0xff1493, roughness: 0.3, emissive: 0xff1493, emissiveIntensity: 0.1 });
        const centerFlower = new THREE.Mesh(GeoCache.getSphere(1.0, 12), centerFlowerMat);
        centerFlower.position.y = 1.5;
        centerFlower.scale.set(1.2, 0.8, 1.2);
        group.add(centerFlower);
        
        // 中央花蕊
        const stamenMat = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.3, emissive: 0xffd700, emissiveIntensity: 0.2 });
        const stamen = new THREE.Mesh(GeoCache.getSphere(0.4, 8), stamenMat);
        stamen.position.y = 1.8;
        group.add(stamen);
        
        // 花瓣环绕
        for (let i = 0; i < 8; i++) {
            const petalMat = new THREE.MeshStandardMaterial({ color: 0xff69b4, roughness: 0.4 });
            const petal = new THREE.Mesh(GeoCache.getSphere(0.5, 8), petalMat);
            const angle = (i / 8) * Math.PI * 2;
            petal.position.set(Math.cos(angle) * 0.8, 1.3, Math.sin(angle) * 0.8);
            petal.scale.set(1, 0.5, 0.6);
            petal.rotation.y = angle;
            group.add(petal);
        }
        
        // 周围的小花丛（多圈）
        for (let ring = 0; ring < 3; ring++) {
            const radius = 1.5 + ring * 1.2;
            const count = 8 + ring * 4;
            for (let i = 0; i < count; i++) {
                const flowerMat = new THREE.MeshStandardMaterial({ 
                    color: flowerColors[Math.floor(Math.random() * flowerColors.length)], 
                    roughness: 0.4 
                });
                const flower = new THREE.Mesh(GeoCache.getSphere(0.3 - ring * 0.05, 6), flowerMat);
                const angle = (i / count) * Math.PI * 2 + ring * 0.2;
                flower.position.set(
                    Math.cos(angle) * radius, 
                    0.5 + Math.random() * 0.3, 
                    Math.sin(angle) * radius
                );
                flower.userData = { floatOffset: Math.random() * Math.PI * 2 };
                group.add(flower);
            }
        }
        
        // 蝴蝶装饰
        const butterflyColors = [0xff69b4, 0x00bfff, 0xffd700, 0xff6347];
        for (let i = 0; i < 4; i++) {
            const butterflyMat = new THREE.MeshStandardMaterial({ 
                color: butterflyColors[i], 
                roughness: 0.3,
                transparent: true,
                opacity: 0.8
            });
            const butterfly = new THREE.Mesh(GeoCache.getSphere(0.15, 6), butterflyMat);
            const angle = (i / 4) * Math.PI * 2;
            butterfly.position.set(Math.cos(angle) * 2.5, 2.5 + Math.random(), Math.sin(angle) * 2.5);
            butterfly.userData = { floatOffset: Math.random() * Math.PI * 2, isButterfly: true };
            group.add(butterfly);
        }
        
        group.position.set(pos.x, 0, pos.z);
        scene.add(group);
        mapMeshes.push(group);
        waterTrap = group;
    }
    
    // 创建传送门
    function createPortals() {
        portals = [];
        
        // 检查位置周围是否至少有一个真正可通行的空格（排除中央座台区域）
        function hasAdjacentEmpty(x, z) {
            const dirs = [
                { x: 1, z: 0 }, { x: -1, z: 0 }, 
                { x: 0, z: 1 }, { x: 0, z: -1 }
            ];
            let emptyCount = 0;
            for (const d of dirs) {
                const nx = x + d.x;
                const nz = z + d.z;
                if (nx >= 0 && nx < CONFIG.GRID_WIDTH && nz >= 0 && nz < CONFIG.GRID_HEIGHT) {
                    // 必须是空格且不是中央座台区域（座台虽然标记为EMPTY但不可通行）
                    if (grid[nz][nx] === TILE.EMPTY && !isWaterTrapArea(nx, nz)) {
                        emptyCount++;
                    }
                }
            }
            return emptyCount >= 1; // 至少有一个真正可通行的空格
        }
        
        // 找到可以放置传送门的位置（避开出生点、中央区域、边界和已有障碍物）
        const validPositions = [];
        for (let z = 2; z < CONFIG.GRID_HEIGHT - 2; z++) {
            for (let x = 2; x < CONFIG.GRID_WIDTH - 2; x++) {
                if (!isSpawnArea(x, z) && !isWaterTrapArea(x, z) && grid[z][x] === TILE.EMPTY) {
                    // 确保传送门周围至少有一个空格
                    if (hasAdjacentEmpty(x, z)) {
                        validPositions.push({ x, z });
                    }
                }
            }
        }
        
        // 随机打乱位置
        for (let i = validPositions.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [validPositions[i], validPositions[j]] = [validPositions[j], validPositions[i]];
        }
        
        // 选择4个位置放置传送门（2红2蓝）
        const portalColors = [
            { color: 0xff4444, emissive: 0xff0000, name: 'red' },
            { color: 0xff4444, emissive: 0xff0000, name: 'red' },
            { color: 0x4444ff, emissive: 0x0000ff, name: 'blue' },
            { color: 0x4444ff, emissive: 0x0000ff, name: 'blue' }
        ];
        
        for (let i = 0; i < 4 && i < validPositions.length; i++) {
            const pos = validPositions[i];
            const colorInfo = portalColors[i];
            
            const portal = createPortalMesh(colorInfo.color, colorInfo.emissive);
            const worldPos = gridToWorld(pos.x, pos.z);
            portal.position.set(worldPos.x, 0, worldPos.z);
            portal.userData = {
                gridX: pos.x,
                gridZ: pos.z,
                color: colorInfo.name,
                type: 'portal'
            };
            
            scene.add(portal);
            mapMeshes.push(portal);
            portals.push(portal);
        }
    }
    
    // 创建传送门网格
    function createPortalMesh(color, emissiveColor) {
        const group = new THREE.Group();
        
        // 传送门环
        const ringMat = new THREE.MeshStandardMaterial({ 
            color: color, 
            emissive: emissiveColor, 
            emissiveIntensity: 0.5,
            roughness: 0.3,
            metalness: 0.7
        });
        
        const ring = new THREE.Mesh(
            new THREE.TorusGeometry(1.2, 0.2, 16, 32),
            ringMat
        );
        ring.rotation.x = -Math.PI / 2;
        ring.position.y = 0.3;
        group.add(ring);
        
        // 传送门内部漩涡效果
        const vortexMat = new THREE.MeshStandardMaterial({ 
            color: color, 
            emissive: emissiveColor, 
            emissiveIntensity: 0.8,
            transparent: true,
            opacity: 0.6,
            roughness: 0.1
        });
        
        const vortex = new THREE.Mesh(
            GeoCache.getCylinder(1.0, 1.0, 0.1, 32),
            vortexMat
        );
        vortex.position.y = 0.3;
        vortex.userData = { isVortex: true };
        group.add(vortex);
        
        // 粒子效果（上升的光点）
        for (let i = 0; i < 8; i++) {
            const particleMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                emissive: emissiveColor, 
                emissiveIntensity: 1.0,
                transparent: true,
                opacity: 0.8
            });
            const particle = new THREE.Mesh(GeoCache.getSphere(0.1, 6), particleMat);
            const angle = (i / 8) * Math.PI * 2;
            particle.position.set(Math.cos(angle) * 0.8, 0.5, Math.sin(angle) * 0.8);
            particle.userData = { floatOffset: i * 0.8, isPortalParticle: true };
            group.add(particle);
        }
        
        return group;
    }
    
    // 检查玩家是否进入传送门
    function checkPortalTeleport(player) {
        if (!portals || portals.length < 4) return;
        
        // 如果玩家还在上次传送到达的格子上，不触发传送
        if (player.lastPortalGrid && 
            player.gridX === player.lastPortalGrid.x && 
            player.gridZ === player.lastPortalGrid.z) {
            return;
        }
        
        const playerPortal = portals.find(p => 
            p.userData.gridX === player.gridX && p.userData.gridZ === player.gridZ
        );
        
        if (playerPortal) {
            // 找到同色的另一个传送门
            const targetPortal = portals.find(p => 
                p.userData.color === playerPortal.userData.color && p !== playerPortal
            );
            
            if (targetPortal) {
                // 传送玩家
                const targetPos = gridToWorld(targetPortal.userData.gridX, targetPortal.userData.gridZ);
                player.mesh.position.set(targetPos.x, player.mesh.position.y, targetPos.z);
                player.gridX = targetPortal.userData.gridX;
                player.gridZ = targetPortal.userData.gridZ;
                
                // 记录传送到达的格子位置，防止立即再次传送
                player.lastPortalGrid = { x: targetPortal.userData.gridX, z: targetPortal.userData.gridZ };
                
                // 播放传送音效
                soundManager.playPowerup();
                
                // 传送特效
                createTeleportEffect(targetPos.x, targetPos.z, playerPortal.userData.color);
            }
        }
    }
    
    // 传送特效
    function createTeleportEffect(x, z, color) {
        const effectColor = color === 'red' ? 0xff4444 : 0x4444ff;
        
        for (let i = 0; i < 10; i++) {
            const particleMat = new THREE.MeshStandardMaterial({ 
                color: effectColor, 
                emissive: effectColor, 
                emissiveIntensity: 1.0,
                transparent: true,
                opacity: 1.0
            });
            const particle = new THREE.Mesh(GeoCache.getSphere(0.15, 6), particleMat);
            const angle = (i / 10) * Math.PI * 2;
            particle.position.set(x + Math.cos(angle) * 0.5, 1 + Math.random(), z + Math.sin(angle) * 0.5);
            scene.add(particle);
            
            // 添加到爆炸效果列表以便自动清理
            const effect = {
                mesh: particle,
                life: 0.5,
                velocity: { x: Math.cos(angle) * 2, y: 3, z: Math.sin(angle) * 2 }
            };
            explosions.push(effect);
        }
    }
    
    // ==================== 海洋主题装饰物 ====================
    function createCoralWall() {
        const group = new THREE.Group();
        const coralColors = [0xff6b6b, 0xff9f43, 0xf368e0, 0x00d2d3];
        const coralMat = new THREE.MeshStandardMaterial({ color: coralColors[Math.floor(Math.random() * coralColors.length)], roughness: 0.6 });
        
        const base = new THREE.Mesh(GeoCache.getBox(2.5, 1.5, 2.5), coralMat);
        base.position.y = 0.75;
        base.castShadow = true;
        group.add(base);
        
        for (let i = 0; i < 4; i++) {
            const branch = new THREE.Mesh(GeoCache.getCylinder(0.2, 0.1, 1.5, 6), coralMat);
            branch.position.set((Math.random() - 0.5) * 1.5, 2.0, (Math.random() - 0.5) * 1.5);
            branch.rotation.x = (Math.random() - 0.5) * 0.5;
            branch.rotation.z = (Math.random() - 0.5) * 0.5;
            group.add(branch);
        }
        
        return group;
    }
    
    function createSeaRock() {
        const group = new THREE.Group();
        const rockMat = new THREE.MeshStandardMaterial({ color: 0x607d8b, roughness: 0.9 });
        const shellMat = new THREE.MeshStandardMaterial({ color: 0xffccbc, roughness: 0.4, metalness: 0.3 });
        
        const rock = new THREE.Mesh(GeoCache.getSphere(1.5, 8), rockMat);
        rock.position.y = 1.2;
        rock.scale.set(1.2, 0.8, 1.0);
        rock.castShadow = true;
        group.add(rock);
        
        const shell = new THREE.Mesh(GeoCache.getSphere(0.4, 6), shellMat);
        shell.position.set(0.8, 0.8, 0.6);
        shell.scale.set(1, 0.3, 1);
        group.add(shell);
        
        return group;
    }
    
    function createSeaweed() {
        const group = new THREE.Group();
        const seaweedMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32, roughness: 0.7 });
        
        for (let i = 0; i < 5; i++) {
            const strand = new THREE.Mesh(GeoCache.getCylinder(0.15, 0.1, 2.0, 6), seaweedMat);
            strand.position.set((Math.random() - 0.5) * 1.5, 1.0, (Math.random() - 0.5) * 1.5);
            strand.rotation.x = (Math.random() - 0.5) * 0.3;
            strand.rotation.z = (Math.random() - 0.5) * 0.3;
            group.add(strand);
        }
        
        return group;
    }
    
    function createWhirlpool() {
        const group = new THREE.Group();
        const centerX = Math.floor(CONFIG.GRID_WIDTH / 2);
        const centerZ = Math.floor(CONFIG.GRID_HEIGHT / 2);
        const pos = gridToWorld(centerX, centerZ);
        
        const waterMat = new THREE.MeshStandardMaterial({ color: 0x0077be, roughness: 0.0, metalness: 0.3, transparent: true, opacity: 0.8 });
        const foamMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5, transparent: true, opacity: 0.7 });
        
        const water = new THREE.Mesh(GeoCache.getCylinder(4, 4, 0.3, 16), waterMat);
        water.position.y = 0.15;
        group.add(water);
        
        for (let i = 0; i < 3; i++) {
            const ring = new THREE.Mesh(GeoCache.getCylinder(3 - i * 0.8, 3 - i * 0.8, 0.1, 16), foamMat);
            ring.position.y = 0.3 + i * 0.1;
            ring.userData = { rotSpeed: 1 + i * 0.5 };
            group.add(ring);
        }
        
        const bubbleMat = new THREE.MeshStandardMaterial({ color: 0xaaddff, transparent: true, opacity: 0.6 });
        for (let i = 0; i < 10; i++) {
            const bubble = new THREE.Mesh(GeoCache.getSphere(0.2 + Math.random() * 0.2, 6), bubbleMat);
            const angle = (i / 10) * Math.PI * 2;
            bubble.position.set(Math.cos(angle) * 2, 0.5 + Math.random(), Math.sin(angle) * 2);
            bubble.userData = { floatOffset: Math.random() * Math.PI * 2 };
            group.add(bubble);
        }
        
        group.position.set(pos.x, 0, pos.z);
        group.scale.set(1.3, 1.3, 1.3);
        scene.add(group);
        mapMeshes.push(group);
        waterTrap = group;
    }
    
    // ==================== 海洋关卡专属装饰物 ====================
    
    // 珊瑚丛 - 不可破坏障碍物
    function createCoralCluster() {
        const group = new THREE.Group();
        const coralColors = [0xff6b6b, 0xff9f43, 0xf368e0, 0x00d2d3, 0xff7675, 0xfdcb6e];
        
        // 主珊瑚
        for (let i = 0; i < 4; i++) {
            const coralMat = new THREE.MeshStandardMaterial({ 
                color: coralColors[Math.floor(Math.random() * coralColors.length)], 
                roughness: 0.6 
            });
            const coral = new THREE.Mesh(GeoCache.getCylinder(0.3, 0.15, 1.5 + Math.random() * 0.8, 8), coralMat);
            const angle = (i / 4) * Math.PI * 2 + Math.random() * 0.5;
            coral.position.set(Math.cos(angle) * 0.5, 0.8, Math.sin(angle) * 0.5);
            coral.rotation.x = (Math.random() - 0.5) * 0.3;
            coral.rotation.z = (Math.random() - 0.5) * 0.3;
            coral.castShadow = true;
            group.add(coral);
        }
        
        // 珊瑚底座
        const baseMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63, roughness: 0.9 });
        const base = new THREE.Mesh(GeoCache.getCylinder(1.0, 1.2, 0.5, 12), baseMat);
        base.position.y = 0.25;
        group.add(base);
        
        // 小珊瑚分支
        for (let i = 0; i < 6; i++) {
            const branchMat = new THREE.MeshStandardMaterial({ 
                color: coralColors[Math.floor(Math.random() * coralColors.length)], 
                roughness: 0.5 
            });
            const branch = new THREE.Mesh(GeoCache.getSphere(0.2, 6), branchMat);
            const angle = Math.random() * Math.PI * 2;
            branch.position.set(
                Math.cos(angle) * (0.3 + Math.random() * 0.4), 
                1.5 + Math.random() * 0.5, 
                Math.sin(angle) * (0.3 + Math.random() * 0.4)
            );
            group.add(branch);
        }
        
        return group;
    }
    
    // 海绵或海星 - 可破坏物
    function createSpongeOrStarfish() {
        const group = new THREE.Group();
        
        if (Math.random() > 0.5) {
            // 海绵 - 放大尺寸
            const spongeColors = [0xffd93d, 0xff9f43, 0xf8b500, 0xffeaa7];
            const spongeMat = new THREE.MeshStandardMaterial({ 
                color: spongeColors[Math.floor(Math.random() * spongeColors.length)], 
                roughness: 0.9 
            });
            
            // 主体海绵 - 放大
            const sponge = new THREE.Mesh(GeoCache.getCylinder(1.3, 1.0, 2.0, 8), spongeMat);
            sponge.position.y = 1.0;
            sponge.castShadow = true;
            group.add(sponge);
            
            // 海绵孔洞效果（用深色球体表示）- 放大
            const holeMat = new THREE.MeshStandardMaterial({ color: 0x8b7355, roughness: 0.9 });
            for (let i = 0; i < 10; i++) {
                const hole = new THREE.Mesh(GeoCache.getSphere(0.15, 6), holeMat);
                const angle = Math.random() * Math.PI * 2;
                const height = 0.4 + Math.random() * 1.4;
                hole.position.set(Math.cos(angle) * 1.0, height, Math.sin(angle) * 1.0);
                group.add(hole);
            }
        } else {
            // 海星 - 放大尺寸
            const starColors = [0xff6b6b, 0xff9f43, 0xf368e0, 0x00d2d3, 0xff4757];
            const starMat = new THREE.MeshStandardMaterial({ 
                color: starColors[Math.floor(Math.random() * starColors.length)], 
                roughness: 0.5 
            });
            
            // 海星中心 - 放大
            const center = new THREE.Mesh(GeoCache.getCylinder(0.8, 0.8, 0.4, 12), starMat);
            center.position.y = 0.2;
            group.add(center);
            
            // 海星五个触角 - 放大
            for (let i = 0; i < 5; i++) {
                const arm = new THREE.Mesh(GeoCache.getBox(0.5, 0.3, 1.5), starMat);
                const angle = (i / 5) * Math.PI * 2;
                arm.position.set(Math.cos(angle) * 1.0, 0.2, Math.sin(angle) * 1.0);
                arm.rotation.y = -angle;
                arm.castShadow = true;
                group.add(arm);
            }
            
            // 海星斑点 - 放大
            const spotMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
            for (let i = 0; i < 5; i++) {
                const spot = new THREE.Mesh(GeoCache.getSphere(0.12, 6), spotMat);
                const angle = (i / 5) * Math.PI * 2 + 0.3;
                spot.position.set(Math.cos(angle) * 0.6, 0.4, Math.sin(angle) * 0.6);
                group.add(spot);
            }
        }
        
        return group;
    }
    
    // 海底火山 - 中央装饰
    function createUnderwaterVolcano() {
        const group = new THREE.Group();
        const centerX = Math.floor(CONFIG.GRID_WIDTH / 2);
        const centerZ = Math.floor(CONFIG.GRID_HEIGHT / 2);
        const pos = gridToWorld(centerX, centerZ);
        
        // 火山底座
        const baseMat = new THREE.MeshStandardMaterial({ color: 0x3d3d3d, roughness: 0.9 });
        const base = new THREE.Mesh(GeoCache.getCylinder(4.5, 5.0, 1.0, 16), baseMat);
        base.position.y = 0.5;
        group.add(base);
        
        // 火山主体
        const volcanoMat = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.85 });
        const volcano = new THREE.Mesh(GeoCache.getCylinder(2.0, 4.0, 4.0, 16), volcanoMat);
        volcano.position.y = 3.0;
        volcano.castShadow = true;
        group.add(volcano);
        
        // 火山口
        const craterMat = new THREE.MeshStandardMaterial({ 
            color: 0xff4500, 
            emissive: 0xff2200, 
            emissiveIntensity: 0.5,
            roughness: 0.3
        });
        const crater = new THREE.Mesh(GeoCache.getCylinder(1.8, 1.5, 0.5, 16), craterMat);
        crater.position.y = 5.0;
        group.add(crater);
        
        // 岩浆池
        const lavaMat = new THREE.MeshStandardMaterial({ 
            color: 0xff6600, 
            emissive: 0xff3300, 
            emissiveIntensity: 0.8,
            roughness: 0.1
        });
        const lavaPool = new THREE.Mesh(GeoCache.getCylinder(1.3, 1.3, 0.3, 16), lavaMat);
        lavaPool.position.y = 5.1;
        lavaPool.userData = { isLavaPool: true };
        group.add(lavaPool);
        
        // 岩石装饰
        const rockMat = new THREE.MeshStandardMaterial({ color: 0x5a5a5a, roughness: 0.95 });
        for (let i = 0; i < 8; i++) {
            const rock = new THREE.Mesh(GeoCache.getSphere(0.4 + Math.random() * 0.3, 6), rockMat);
            const angle = (i / 8) * Math.PI * 2;
            rock.position.set(Math.cos(angle) * 3.5, 0.5 + Math.random() * 0.5, Math.sin(angle) * 3.5);
            rock.scale.set(1, 0.6, 1);
            group.add(rock);
        }
        
        // 气泡效果
        const bubbleMat = new THREE.MeshStandardMaterial({ 
            color: 0xaaddff, 
            transparent: true, 
            opacity: 0.5 
        });
        for (let i = 0; i < 6; i++) {
            const bubble = new THREE.Mesh(GeoCache.getSphere(0.15 + Math.random() * 0.1, 6), bubbleMat);
            const angle = Math.random() * Math.PI * 2;
            bubble.position.set(Math.cos(angle) * 1.0, 5.5 + Math.random() * 2, Math.sin(angle) * 1.0);
            bubble.userData = { floatOffset: Math.random() * Math.PI * 2, isVolcanoBubble: true };
            group.add(bubble);
        }
        
        group.position.set(pos.x, 0, pos.z);
        scene.add(group);
        mapMeshes.push(group);
        waterTrap = group;
    }
    
    // 火山爆发 - 选择随机空格并显示预警
    function startVolcanoEruption() {
        if (lavaActive) return;
        
        // 找到所有空格
        const emptySpots = [];
        for (let z = 1; z < CONFIG.GRID_HEIGHT - 1; z++) {
            for (let x = 1; x < CONFIG.GRID_WIDTH - 1; x++) {
                if (grid[z][x] === TILE.EMPTY && !isWaterTrapArea(x, z) && !isSpawnArea(x, z)) {
                    emptySpots.push({ x, z });
                }
            }
        }
        
        // 随机打乱并选择10个
        for (let i = emptySpots.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [emptySpots[i], emptySpots[j]] = [emptySpots[j], emptySpots[i]];
        }
        
        const targetSpots = emptySpots.slice(0, Math.min(10, emptySpots.length));
        
        // 创建预警效果
        lavaWarnings = [];
        targetSpots.forEach(spot => {
            const warning = createLavaWarning(spot.x, spot.z);
            lavaWarnings.push({
                mesh: warning,
                gridX: spot.x,
                gridZ: spot.z,
                timer: 3.0 // 3秒预警
            });
        });
        
        lavaActive = true;
    }
    
    // 创建岩浆预警效果 - 放大尺寸
    function createLavaWarning(gx, gz) {
        const group = new THREE.Group();
        const pos = gridToWorld(gx, gz);
        
        // 预警圆圈 - 放大
        const warningMat = new THREE.MeshStandardMaterial({ 
            color: 0xff4500, 
            emissive: 0xff2200, 
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.6
        });
        
        const ring = new THREE.Mesh(
            new THREE.RingGeometry(1.5, 1.9, 16),
            warningMat
        );
        ring.rotation.x = -Math.PI / 2;
        ring.position.y = 0.1;
        group.add(ring);
        
        // 内圈闪烁 - 放大
        const innerMat = new THREE.MeshStandardMaterial({ 
            color: 0xff6600, 
            emissive: 0xff3300, 
            emissiveIntensity: 0.8,
            transparent: true,
            opacity: 0.4
        });
        const inner = new THREE.Mesh(GeoCache.getCylinder(1.4, 1.4, 0.15, 16), innerMat);
        inner.position.y = 0.1;
        inner.userData = { isWarningInner: true };
        group.add(inner);
        
        group.position.set(pos.x, 0, pos.z);
        scene.add(group);
        
        return group;
    }
    
    // 岩浆喷发
    function triggerLavaEruption(warning) {
        const pos = gridToWorld(warning.gridX, warning.gridZ);
        
        // 移除预警效果
        scene.remove(warning.mesh);
        
        // 创建岩浆喷发效果 - 放大尺寸
        const lavaMat = new THREE.MeshStandardMaterial({ 
            color: 0xff4500, 
            emissive: 0xff2200, 
            emissiveIntensity: 1.0,
            transparent: true,
            opacity: 0.9
        });
        
        const lava = new THREE.Mesh(GeoCache.getCylinder(1.8, 1.2, 2.5, 12), lavaMat);
        lava.position.set(pos.x, 1.25, pos.z);
        scene.add(lava);
        
        // 检查玩家是否在该格子上
        players.forEach(p => {
            if (!p.isDead && p.gridX === warning.gridX && p.gridZ === warning.gridZ) {
                p.die();
            }
        });
        
        // 播放音效
        soundManager.playExplosion();
        
        // 添加到爆炸效果列表以便清理
        explosions.push({
            mesh: lava,
            life: 0.8,
            isLava: true
        });
        
        // 喷射粒子 - 放大
        for (let i = 0; i < 10; i++) {
            const particleMat = new THREE.MeshStandardMaterial({ 
                color: 0xff6600, 
                emissive: 0xff3300, 
                emissiveIntensity: 1.0,
                transparent: true,
                opacity: 0.8
            });
            const particle = new THREE.Mesh(GeoCache.getSphere(0.35, 6), particleMat);
            const angle = (i / 10) * Math.PI * 2;
            particle.position.set(pos.x + Math.cos(angle) * 0.5, 1.8, pos.z + Math.sin(angle) * 0.5);
            scene.add(particle);
            
            explosions.push({
                mesh: particle,
                life: 0.6,
                velocity: { x: Math.cos(angle) * 3, y: 5, z: Math.sin(angle) * 3 }
            });
        }
    }
    
    // ==================== 城市主题装饰物 ====================
    function createBuildingWall() {
        const group = new THREE.Group();
        const brickMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63, roughness: 0.8 });
        const windowMat = new THREE.MeshStandardMaterial({ color: 0x90caf9, roughness: 0.2, metalness: 0.5 });
        
        const wall = new THREE.Mesh(GeoCache.getBox(3, 3, 3), brickMat);
        wall.position.y = 1.5;
        wall.castShadow = true;
        group.add(wall);
        
        const window1 = new THREE.Mesh(GeoCache.getBox(0.8, 0.8, 0.1), windowMat);
        window1.position.set(0.6, 2.0, 1.51);
        group.add(window1);
        
        const window2 = new THREE.Mesh(GeoCache.getBox(0.8, 0.8, 0.1), windowMat);
        window2.position.set(-0.6, 2.0, 1.51);
        group.add(window2);
        
        return group;
    }
    
    function createMailbox() {
        const group = new THREE.Group();
        const metalMat = new THREE.MeshStandardMaterial({ color: 0x1565c0, roughness: 0.3, metalness: 0.7 });
        const postMat = new THREE.MeshStandardMaterial({ color: 0x424242, roughness: 0.6 });
        
        const post = new THREE.Mesh(GeoCache.getCylinder(0.15, 0.15, 2.5, 8), postMat);
        post.position.y = 1.25;
        group.add(post);
        
        const box = new THREE.Mesh(GeoCache.getBox(1.2, 1.0, 0.8), metalMat);
        box.position.y = 2.8;
        box.castShadow = true;
        group.add(box);
        
        const top = new THREE.Mesh(GeoCache.getCylinder(0.6, 0.6, 0.2, 8), metalMat);
        top.position.y = 3.4;
        top.rotation.x = Math.PI / 2;
        group.add(top);
        
        return group;
    }
    
    function createTrashCan() {
        const group = new THREE.Group();
        const canMat = new THREE.MeshStandardMaterial({ color: 0x37474f, roughness: 0.5, metalness: 0.6 });
        const lidMat = new THREE.MeshStandardMaterial({ color: 0x455a64, roughness: 0.4, metalness: 0.5 });
        
        const can = new THREE.Mesh(GeoCache.getCylinder(0.8, 0.7, 1.8, 12), canMat);
        can.position.y = 0.9;
        can.castShadow = true;
        group.add(can);
        
        const lid = new THREE.Mesh(GeoCache.getCylinder(0.85, 0.85, 0.15, 12), lidMat);
        lid.position.y = 1.85;
        group.add(lid);
        
        return group;
    }
    
    // 办公楼（城市边缘墙）
    function createOfficeBuilding() {
        const group = new THREE.Group();
        
        // 随机选择楼层高度
        const floors = 2 + Math.floor(Math.random() * 2);
        const buildingHeight = floors * 1.5;
        
        // 建筑主体
        const buildingColors = [0x607d8b, 0x78909c, 0x546e7a, 0x455a64];
        const buildingMat = new THREE.MeshStandardMaterial({ 
            color: buildingColors[Math.floor(Math.random() * buildingColors.length)], 
            roughness: 0.4,
            metalness: 0.3
        });
        
        const building = new THREE.Mesh(GeoCache.getBox(3.2, buildingHeight, 3.2), buildingMat);
        building.position.y = buildingHeight / 2;
        building.castShadow = true;
        group.add(building);
        
        // 玻璃窗户
        const windowMat = new THREE.MeshStandardMaterial({ 
            color: 0x81d4fa, 
            roughness: 0.1, 
            metalness: 0.8,
            transparent: true,
            opacity: 0.9
        });
        
        // 每层添加窗户
        for (let f = 0; f < floors; f++) {
            const floorY = 0.8 + f * 1.5;
            // 前后两面
            for (let side = -1; side <= 1; side += 2) {
                for (let wx = -0.8; wx <= 0.8; wx += 0.8) {
                    const window = new THREE.Mesh(GeoCache.getBox(0.5, 0.7, 0.1), windowMat);
                    window.position.set(wx, floorY, side * 1.61);
                    group.add(window);
                }
            }
            // 左右两面
            for (let side = -1; side <= 1; side += 2) {
                for (let wz = -0.8; wz <= 0.8; wz += 0.8) {
                    const window = new THREE.Mesh(GeoCache.getBox(0.1, 0.7, 0.5), windowMat);
                    window.position.set(side * 1.61, floorY, wz);
                    group.add(window);
                }
            }
        }
        
        // 屋顶
        const roofMat = new THREE.MeshStandardMaterial({ color: 0x37474f, roughness: 0.6 });
        const roof = new THREE.Mesh(GeoCache.getBox(3.4, 0.2, 3.4), roofMat);
        roof.position.y = buildingHeight + 0.1;
        group.add(roof);
        
        return group;
    }
    
    // 便利店（不可破坏障碍物）
    function createConvenienceStore() {
        const group = new THREE.Group();
        
        // 店铺主体
        const storeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
        const store = new THREE.Mesh(GeoCache.getBox(2.8, 2.5, 2.8), storeMat);
        store.position.y = 1.25;
        store.castShadow = true;
        group.add(store);
        
        // 招牌（随机颜色）
        const signColors = [0xff5722, 0x2196f3, 0x4caf50, 0xffc107];
        const signMat = new THREE.MeshStandardMaterial({ 
            color: signColors[Math.floor(Math.random() * signColors.length)],
            emissive: signColors[Math.floor(Math.random() * signColors.length)],
            emissiveIntensity: 0.3
        });
        const sign = new THREE.Mesh(GeoCache.getBox(2.6, 0.5, 0.2), signMat);
        sign.position.set(0, 2.3, 1.41);
        group.add(sign);
        
        // 店门
        const doorMat = new THREE.MeshStandardMaterial({ color: 0x90caf9, roughness: 0.1, metalness: 0.5 });
        const door = new THREE.Mesh(GeoCache.getBox(1.0, 1.8, 0.1), doorMat);
        door.position.set(0, 0.9, 1.41);
        group.add(door);
        
        // 侧面窗户
        const windowMat = new THREE.MeshStandardMaterial({ color: 0xb3e5fc, roughness: 0.1, metalness: 0.3 });
        const window1 = new THREE.Mesh(GeoCache.getBox(0.1, 1.2, 1.5), windowMat);
        window1.position.set(1.41, 1.2, 0);
        group.add(window1);
        const window2 = new THREE.Mesh(GeoCache.getBox(0.1, 1.2, 1.5), windowMat);
        window2.position.set(-1.41, 1.2, 0);
        group.add(window2);
        
        // 屋顶
        const roofMat = new THREE.MeshStandardMaterial({ color: 0x424242, roughness: 0.7 });
        const roof = new THREE.Mesh(GeoCache.getBox(3.0, 0.3, 3.0), roofMat);
        roof.position.y = 2.65;
        group.add(roof);
        
        return group;
    }
    
    // 圆锥筒路障或垃圾箱（可破坏物）
    function createConeOrTrashBin() {
        const group = new THREE.Group();
        
        if (Math.random() > 0.5) {
            // 圆锥筒路障
            const coneMat = new THREE.MeshStandardMaterial({ color: 0xff6600, roughness: 0.6 });
            const cone = new THREE.Mesh(GeoCache.getCone(0.7, 1.8, 8), coneMat);
            cone.position.y = 0.9;
            cone.castShadow = true;
            group.add(cone);
            
            // 白色条纹
            const stripeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
            const stripe1 = new THREE.Mesh(GeoCache.getCylinder(0.55, 0.5, 0.15, 8), stripeMat);
            stripe1.position.y = 0.6;
            group.add(stripe1);
            const stripe2 = new THREE.Mesh(GeoCache.getCylinder(0.4, 0.35, 0.15, 8), stripeMat);
            stripe2.position.y = 1.1;
            group.add(stripe2);
            
            // 底座
            const baseMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 });
            const base = new THREE.Mesh(GeoCache.getBox(1.2, 0.15, 1.2), baseMat);
            base.position.y = 0.075;
            group.add(base);
        } else {
            // 方形垃圾箱
            const binColors = [0x388e3c, 0x1976d2, 0x7b1fa2];
            const binMat = new THREE.MeshStandardMaterial({ 
                color: binColors[Math.floor(Math.random() * binColors.length)], 
                roughness: 0.5 
            });
            
            const bin = new THREE.Mesh(GeoCache.getBox(1.4, 1.6, 1.4), binMat);
            bin.position.y = 0.8;
            bin.castShadow = true;
            group.add(bin);
            
            // 盖子
            const lidMat = new THREE.MeshStandardMaterial({ color: 0x212121, roughness: 0.4 });
            const lid = new THREE.Mesh(GeoCache.getBox(1.5, 0.15, 1.5), lidMat);
            lid.position.y = 1.65;
            group.add(lid);
            
            // 回收标志（简化为圆形）
            const symbolMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
            const symbol = new THREE.Mesh(GeoCache.getCylinder(0.3, 0.3, 0.05, 12), symbolMat);
            symbol.rotation.x = Math.PI / 2;
            symbol.position.set(0, 1.0, 0.71);
            group.add(symbol);
        }
        
        return group;
    }
    
    // 创建城市小汽车
    function createCityCars() {
        cityCars = [];
        
        // 环形路线的路径点（顺时针方向）
        // 路线是一个矩形环：上边(从左到右) -> 右边(从上到下) -> 下边(从右到左) -> 左边(从下到上)
        const innerLeft = 3;
        const innerRight = CONFIG.GRID_WIDTH - 4;
        const innerTop = 3;
        const innerBottom = CONFIG.GRID_HEIGHT - 4;
        
        // 环形路线的四个边
        const carRoute = {
            segments: [
                { type: 'horizontal', z: innerTop, startX: innerLeft, endX: innerRight, direction: 1 },      // 上边，从左到右
                { type: 'vertical', x: innerRight, startZ: innerTop, endZ: innerBottom, direction: 1 },     // 右边，从上到下
                { type: 'horizontal', z: innerBottom, startX: innerRight, endX: innerLeft, direction: -1 }, // 下边，从右到左
                { type: 'vertical', x: innerLeft, startZ: innerBottom, endZ: innerTop, direction: -1 }      // 左边，从下到上
            ],
            totalLength: 2 * (innerRight - innerLeft) + 2 * (innerBottom - innerTop)
        };
        
        // 创建两辆车，起始位置相隔半圈
        const carColors = [0xe53935, 0x1e88e5]; // 红色和蓝色
        
        carColors.forEach((color, index) => {
            const car = createCarMesh(color);
            scene.add(car);
            mapMeshes.push(car);
            
            cityCars.push({
                mesh: car,
                route: carRoute,
                progress: index * 0.5, // 两车相隔半圈
                speed: 0.06 // 降低速度
            });
        });
        
        // 初始化车辆位置
        cityCars.forEach(car => updateCarPosition(car));
    }
    
    // 获取环形路线上某点的位置和朝向
    function getCarPositionOnRoute(route, progress) {
        // progress是0-1的值，表示在整个环形路线上的位置
        const totalLength = route.totalLength;
        let currentDistance = progress * totalLength;
        
        for (const segment of route.segments) {
            let segmentLength;
            if (segment.type === 'horizontal') {
                segmentLength = Math.abs(segment.endX - segment.startX);
            } else {
                segmentLength = Math.abs(segment.endZ - segment.startZ);
            }
            
            if (currentDistance <= segmentLength) {
                // 在这个段内
                const t = currentDistance / segmentLength;
                let x, z, rotation;
                
                if (segment.type === 'horizontal') {
                    x = segment.startX + (segment.endX - segment.startX) * t;
                    z = segment.z;
                    rotation = segment.direction === 1 ? 0 : Math.PI; // 朝右或朝左
                } else {
                    x = segment.x;
                    z = segment.startZ + (segment.endZ - segment.startZ) * t;
                    rotation = segment.direction === 1 ? -Math.PI / 2 : Math.PI / 2; // 朝下或朝上
                }
                
                return { x, z, rotation };
            }
            
            currentDistance -= segmentLength;
        }
        
        // 默认返回起点
        return { x: route.segments[0].startX, z: route.segments[0].z, rotation: 0 };
    }
    
    // 更新单辆车的位置
    function updateCarPosition(car) {
        const posInfo = getCarPositionOnRoute(car.route, car.progress);
        const worldPos = gridToWorld(posInfo.x, posInfo.z);
        car.mesh.position.set(worldPos.x, 0, worldPos.z);
        car.mesh.rotation.y = posInfo.rotation;
    }
    
    // 判断是否在汽车道路上
    function isCarRoadArea(x, z) {
        const innerLeft = 3;
        const innerRight = CONFIG.GRID_WIDTH - 4;
        const innerTop = 3;
        const innerBottom = CONFIG.GRID_HEIGHT - 4;
        
        // 上边道路
        if (z === innerTop && x >= innerLeft && x <= innerRight) return true;
        // 下边道路
        if (z === innerBottom && x >= innerLeft && x <= innerRight) return true;
        // 左边道路
        if (x === innerLeft && z >= innerTop && z <= innerBottom) return true;
        // 右边道路
        if (x === innerRight && z >= innerTop && z <= innerBottom) return true;
        
        return false;
    }
    
    // 创建城市道路标识
    function createCityRoads() {
        const innerLeft = 3;
        const innerRight = CONFIG.GRID_WIDTH - 4;
        const innerTop = 3;
        const innerBottom = CONFIG.GRID_HEIGHT - 4;
        
        // 道路材质
        const roadMat = new THREE.MeshStandardMaterial({ color: 0x37474f, roughness: 0.9 });
        const lineMat = new THREE.MeshStandardMaterial({ color: 0xffeb3b, roughness: 0.5 });
        const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
        
        // 创建道路格子
        const roadPositions = [];
        
        // 收集所有道路位置
        for (let x = innerLeft; x <= innerRight; x++) {
            roadPositions.push({ x, z: innerTop });
            roadPositions.push({ x, z: innerBottom });
        }
        for (let z = innerTop + 1; z < innerBottom; z++) {
            roadPositions.push({ x: innerLeft, z });
            roadPositions.push({ x: innerRight, z });
        }
        
        // 为每个道路位置创建道路地面
        roadPositions.forEach(rp => {
            const pos = gridToWorld(rp.x, rp.z);
            
            // 道路底色
            const road = new THREE.Mesh(
                GeoCache.getBox(CONFIG.TILE_SIZE * 0.98, 0.12, CONFIG.TILE_SIZE * 0.98),
                roadMat
            );
            road.position.set(pos.x, 0.06, pos.z);
            road.receiveShadow = true;
            scene.add(road);
            mapMeshes.push(road);
            
            // 判断是水平还是垂直道路来添加标线
            const isHorizontal = (rp.z === innerTop || rp.z === innerBottom);
            const isVertical = (rp.x === innerLeft || rp.x === innerRight);
            const isCorner = isHorizontal && isVertical;
            
            if (!isCorner) {
                if (isHorizontal) {
                    // 水平道路 - 添加虚线
                    const line = new THREE.Mesh(
                        GeoCache.getBox(CONFIG.TILE_SIZE * 0.4, 0.02, 0.15),
                        lineMat
                    );
                    line.position.set(pos.x, 0.13, pos.z);
                    scene.add(line);
                    mapMeshes.push(line);
                } else if (isVertical) {
                    // 垂直道路 - 添加虚线
                    const line = new THREE.Mesh(
                        GeoCache.getBox(0.15, 0.02, CONFIG.TILE_SIZE * 0.4),
                        lineMat
                    );
                    line.position.set(pos.x, 0.13, pos.z);
                    scene.add(line);
                    mapMeshes.push(line);
                }
            }
            
            // 道路边缘白线
            if (isHorizontal && !isCorner) {
                // 上下边缘
                const edge1 = new THREE.Mesh(GeoCache.getBox(CONFIG.TILE_SIZE * 0.95, 0.02, 0.1), whiteMat);
                edge1.position.set(pos.x, 0.13, pos.z - CONFIG.TILE_SIZE * 0.4);
                scene.add(edge1);
                mapMeshes.push(edge1);
                
                const edge2 = new THREE.Mesh(GeoCache.getBox(CONFIG.TILE_SIZE * 0.95, 0.02, 0.1), whiteMat);
                edge2.position.set(pos.x, 0.13, pos.z + CONFIG.TILE_SIZE * 0.4);
                scene.add(edge2);
                mapMeshes.push(edge2);
            } else if (isVertical && !isCorner) {
                // 左右边缘
                const edge1 = new THREE.Mesh(GeoCache.getBox(0.1, 0.02, CONFIG.TILE_SIZE * 0.95), whiteMat);
                edge1.position.set(pos.x - CONFIG.TILE_SIZE * 0.4, 0.13, pos.z);
                scene.add(edge1);
                mapMeshes.push(edge1);
                
                const edge2 = new THREE.Mesh(GeoCache.getBox(0.1, 0.02, CONFIG.TILE_SIZE * 0.95), whiteMat);
                edge2.position.set(pos.x + CONFIG.TILE_SIZE * 0.4, 0.13, pos.z);
                scene.add(edge2);
                mapMeshes.push(edge2);
            }
        });
    }
    
    // 创建小汽车模型
    function createCarMesh(color) {
        const group = new THREE.Group();
        
        // 车身
        const bodyMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0.6 });
        const body = new THREE.Mesh(GeoCache.getBox(2.4, 0.8, 1.4), bodyMat);
        body.position.y = 0.6;
        body.castShadow = true;
        group.add(body);
        
        // 车顶
        const roofMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0.6 });
        const roof = new THREE.Mesh(GeoCache.getBox(1.4, 0.6, 1.2), roofMat);
        roof.position.set(-0.2, 1.3, 0);
        roof.castShadow = true;
        group.add(roof);
        
        // 车窗
        const windowMat = new THREE.MeshStandardMaterial({ color: 0x81d4fa, roughness: 0.1, metalness: 0.8 });
        // 前挡风玻璃
        const frontWindow = new THREE.Mesh(GeoCache.getBox(0.1, 0.5, 1.0), windowMat);
        frontWindow.position.set(0.55, 1.25, 0);
        group.add(frontWindow);
        // 后挡风玻璃
        const backWindow = new THREE.Mesh(GeoCache.getBox(0.1, 0.5, 1.0), windowMat);
        backWindow.position.set(-0.95, 1.25, 0);
        group.add(backWindow);
        // 侧窗
        const sideWindow1 = new THREE.Mesh(GeoCache.getBox(1.0, 0.4, 0.1), windowMat);
        sideWindow1.position.set(-0.2, 1.3, 0.61);
        group.add(sideWindow1);
        const sideWindow2 = new THREE.Mesh(GeoCache.getBox(1.0, 0.4, 0.1), windowMat);
        sideWindow2.position.set(-0.2, 1.3, -0.61);
        group.add(sideWindow2);
        
        // 车轮
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x212121, roughness: 0.8 });
        const wheelPositions = [
            { x: 0.8, z: 0.7 },
            { x: 0.8, z: -0.7 },
            { x: -0.8, z: 0.7 },
            { x: -0.8, z: -0.7 }
        ];
        wheelPositions.forEach(pos => {
            const wheel = new THREE.Mesh(GeoCache.getCylinder(0.3, 0.3, 0.2, 12), wheelMat);
            wheel.rotation.x = Math.PI / 2;
            wheel.position.set(pos.x, 0.3, pos.z);
            group.add(wheel);
        });
        
        // 车灯
        const lightMat = new THREE.MeshStandardMaterial({ 
            color: 0xffeb3b, 
            emissive: 0xffeb3b, 
            emissiveIntensity: 0.5 
        });
        const headlight1 = new THREE.Mesh(GeoCache.getSphere(0.15, 8), lightMat);
        headlight1.position.set(1.21, 0.6, 0.4);
        group.add(headlight1);
        const headlight2 = new THREE.Mesh(GeoCache.getSphere(0.15, 8), lightMat);
        headlight2.position.set(1.21, 0.6, -0.4);
        group.add(headlight2);
        
        // 尾灯
        const tailMat = new THREE.MeshStandardMaterial({ 
            color: 0xf44336, 
            emissive: 0xf44336, 
            emissiveIntensity: 0.5 
        });
        const taillight1 = new THREE.Mesh(GeoCache.getSphere(0.12, 8), tailMat);
        taillight1.position.set(-1.21, 0.6, 0.4);
        group.add(taillight1);
        const taillight2 = new THREE.Mesh(GeoCache.getSphere(0.12, 8), tailMat);
        taillight2.position.set(-1.21, 0.6, -0.4);
        group.add(taillight2);
        
        return group;
    }
    
    // 更新城市小汽车位置
    function updateCityCars(dt) {
        cityCars.forEach(car => {
            // 更新进度
            car.progress += car.speed * dt;
            
            // 循环路线
            if (car.progress >= 1) {
                car.progress -= 1;
            }
            
            // 更新位置和朝向
            updateCarPosition(car);
            
            // 获取当前位置用于碰撞检测
            const posInfo = getCarPositionOnRoute(car.route, car.progress);
            const carGridX = Math.round(posInfo.x);
            const carGridZ = Math.round(posInfo.z);
            
            // 检查是否撞到玩家
            players.forEach(p => {
                if (!p.isDead) {
                    // 检查玩家是否在道路上且靠近汽车
                    const playerWorldPos = gridToWorld(p.gridX, p.gridZ);
                    const carWorldPos = car.mesh.position;
                    const dx = carWorldPos.x - playerWorldPos.x;
                    const dz = carWorldPos.z - playerWorldPos.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance < CONFIG.TILE_SIZE * 0.7) {
                        p.die();
                        soundManager.playExplosion();
                    }
                }
            });
        });
    }

    function createFountainCity() {
        const group = new THREE.Group();
        const centerX = Math.floor(CONFIG.GRID_WIDTH / 2);
        const centerZ = Math.floor(CONFIG.GRID_HEIGHT / 2);
        const pos = gridToWorld(centerX, centerZ);
        
        const stoneMat = new THREE.MeshStandardMaterial({ color: 0x9e9e9e, roughness: 0.6 });
        const waterMat = new THREE.MeshStandardMaterial({ color: 0x64b5f6, roughness: 0.0, metalness: 0.2, transparent: true, opacity: 0.8 });
        
        const base = new THREE.Mesh(GeoCache.getCylinder(4, 4.5, 0.6, 16), stoneMat);
        base.position.y = 0.3;
        group.add(base);
        
        const pool = new THREE.Mesh(GeoCache.getCylinder(3.5, 3.5, 0.8, 16), stoneMat);
        pool.position.y = 0.9;
        group.add(pool);
        
        const water = new THREE.Mesh(GeoCache.getCylinder(3.2, 3.2, 0.2, 16), waterMat);
        water.position.y = 0.8;
        group.add(water);
        
        const pillar = new THREE.Mesh(GeoCache.getCylinder(0.5, 0.6, 3, 12), stoneMat);
        pillar.position.y = 2.3;
        group.add(pillar);
        
        const top = new THREE.Mesh(GeoCache.getSphere(0.8, 12), stoneMat);
        top.position.y = 4;
        group.add(top);
        
        group.position.set(pos.x, 0, pos.z);
        group.scale.set(1.3, 1.3, 1.3);
        scene.add(group);
        mapMeshes.push(group);
        waterTrap = group;
    }
    
    // ==================== 公园主题装饰物 ====================
    function createFenceWall() {
        const group = new THREE.Group();
        const woodMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6 });
        
        for (let i = -1; i <= 1; i++) {
            const post = new THREE.Mesh(GeoCache.getBox(0.3, 2.5, 0.3), woodMat);
            post.position.set(i * 1.2, 1.25, 0);
            post.castShadow = true;
            group.add(post);
            
            const top = new THREE.Mesh(GeoCache.getCone(0.25, 0.4, 4), woodMat);
            top.position.set(i * 1.2, 2.7, 0);
            group.add(top);
        }
        
        const rail1 = new THREE.Mesh(GeoCache.getBox(3, 0.15, 0.15), woodMat);
        rail1.position.y = 1.8;
        group.add(rail1);
        
        const rail2 = new THREE.Mesh(GeoCache.getBox(3, 0.15, 0.15), woodMat);
        rail2.position.y = 0.8;
        group.add(rail2);
        
        return group;
    }
    
    function createCarousel() {
        const group = new THREE.Group();
        const baseMat = new THREE.MeshStandardMaterial({ color: 0xffd54f, roughness: 0.4, metalness: 0.3 });
        const poleMat = new THREE.MeshStandardMaterial({ color: 0xef5350, roughness: 0.3, metalness: 0.5 });
        const topMat = new THREE.MeshStandardMaterial({ color: 0x42a5f5, roughness: 0.4 });
        
        const base = new THREE.Mesh(GeoCache.getCylinder(1.5, 1.5, 0.3, 12), baseMat);
        base.position.y = 0.15;
        group.add(base);
        
        const pole = new THREE.Mesh(GeoCache.getCylinder(0.2, 0.2, 3, 8), poleMat);
        pole.position.y = 1.65;
        group.add(pole);
        
        const top = new THREE.Mesh(GeoCache.getCone(1.8, 1.2, 12), topMat);
        top.position.y = 3.5;
        group.add(top);
        
        return group;
    }
    
    function createBalloonCrate() {
        const group = new THREE.Group();
        const colors = [0xef5350, 0x42a5f5, 0xffee58, 0x66bb6a, 0xab47bc];
        const balloonMat = new THREE.MeshStandardMaterial({ color: colors[Math.floor(Math.random() * colors.length)], roughness: 0.3 });
        const stringMat = new THREE.MeshBasicMaterial({ color: 0x888888 });
        
        const balloon = new THREE.Mesh(GeoCache.getSphere(1.0, 12), balloonMat);
        balloon.position.y = 2.0;
        balloon.scale.set(0.8, 1.0, 0.8);
        group.add(balloon);
        
        const string = new THREE.Mesh(GeoCache.getCylinder(0.02, 0.02, 1.5, 4), stringMat);
        string.position.y = 0.75;
        group.add(string);
        
        const weight = new THREE.Mesh(GeoCache.getBox(0.3, 0.3, 0.3), new THREE.MeshStandardMaterial({ color: 0x795548 }));
        weight.position.y = 0.15;
        group.add(weight);
        
        return group;
    }
    
    function createFerrisWheel() {
        const group = new THREE.Group();
        const centerX = Math.floor(CONFIG.GRID_WIDTH / 2);
        const centerZ = Math.floor(CONFIG.GRID_HEIGHT / 2);
        const pos = gridToWorld(centerX, centerZ);
        
        const frameMat = new THREE.MeshStandardMaterial({ color: 0xef5350, roughness: 0.3, metalness: 0.6 });
        const cabinColors = [0x42a5f5, 0xffee58, 0x66bb6a, 0xab47bc, 0xff7043, 0x26c6da];
        
        const base = new THREE.Mesh(GeoCache.getBox(2, 0.5, 4), frameMat);
        base.position.y = 0.25;
        group.add(base);
        
        const support1 = new THREE.Mesh(GeoCache.getBox(0.3, 5, 0.3), frameMat);
        support1.position.set(0, 2.5, 1.5);
        support1.rotation.x = 0.2;
        group.add(support1);
        
        const support2 = new THREE.Mesh(GeoCache.getBox(0.3, 5, 0.3), frameMat);
        support2.position.set(0, 2.5, -1.5);
        support2.rotation.x = -0.2;
        group.add(support2);
        
        const wheel = new THREE.Mesh(GeoCache.getCylinder(3, 3, 0.2, 24), frameMat);
        wheel.position.y = 5;
        wheel.rotation.x = Math.PI / 2;
        group.add(wheel);
        
        for (let i = 0; i < 6; i++) {
            const cabinMat = new THREE.MeshStandardMaterial({ color: cabinColors[i], roughness: 0.4 });
            const cabin = new THREE.Mesh(GeoCache.getBox(0.6, 0.8, 0.6), cabinMat);
            const angle = (i / 6) * Math.PI * 2;
            cabin.position.set(0, 5 + Math.sin(angle) * 2.5, Math.cos(angle) * 2.5);
            group.add(cabin);
        }
        
        group.position.set(pos.x, 0, pos.z);
        group.scale.set(1.2, 1.2, 1.2);
        scene.add(group);
        mapMeshes.push(group);
        waterTrap = group;
    }
    
    // 热气球边缘墙
    function createHotAirBalloon() {
        const group = new THREE.Group();
        const colors = [0xef5350, 0x42a5f5, 0xffee58, 0x66bb6a, 0xab47bc, 0xff7043];
        const balloonColor = colors[Math.floor(Math.random() * colors.length)];
        
        // 气球主体
        const balloonMat = new THREE.MeshStandardMaterial({ 
            color: balloonColor, 
            roughness: 0.4,
            metalness: 0.1
        });
        const balloon = new THREE.Mesh(GeoCache.getSphere(1.8, 16), balloonMat);
        balloon.position.y = 4.0;
        balloon.scale.set(1, 1.2, 1);
        balloon.castShadow = true;
        group.add(balloon);
        
        // 气球条纹装饰
        const stripeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
        for (let i = 0; i < 4; i++) {
            const stripe = new THREE.Mesh(GeoCache.getBox(0.1, 2.5, 1.6), stripeMat);
            stripe.position.y = 4.0;
            stripe.rotation.y = (i / 4) * Math.PI;
            group.add(stripe);
        }
        
        // 吊篮绳索
        const ropeMat = new THREE.MeshBasicMaterial({ color: 0x8d6e63 });
        for (let i = 0; i < 4; i++) {
            const rope = new THREE.Mesh(GeoCache.getCylinder(0.03, 0.03, 2.0, 4), ropeMat);
            const angle = (i / 4) * Math.PI * 2 + Math.PI / 4;
            rope.position.set(Math.cos(angle) * 0.6, 1.8, Math.sin(angle) * 0.6);
            group.add(rope);
        }
        
        // 吊篮
        const basketMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63, roughness: 0.8 });
        const basket = new THREE.Mesh(GeoCache.getCylinder(0.7, 0.8, 0.8, 8), basketMat);
        basket.position.y = 0.6;
        basket.castShadow = true;
        group.add(basket);
        
        // 吊篮底部
        const basketBottom = new THREE.Mesh(GeoCache.getCylinder(0.75, 0.75, 0.1, 8), basketMat);
        basketBottom.position.y = 0.2;
        group.add(basketBottom);
        
        return group;
    }
    
    // 售票亭（不可破坏）
    function createTicketBooth() {
        const group = new THREE.Group();
        
        // 主体
        const boothMat = new THREE.MeshStandardMaterial({ color: 0xffcc80, roughness: 0.6 });
        const booth = new THREE.Mesh(GeoCache.getBox(2.5, 2.5, 2.5), boothMat);
        booth.position.y = 1.25;
        booth.castShadow = true;
        group.add(booth);
        
        // 屋顶
        const roofMat = new THREE.MeshStandardMaterial({ color: 0xef5350, roughness: 0.5 });
        const roof = new THREE.Mesh(GeoCache.getCone(2.0, 1.2, 4), roofMat);
        roof.position.y = 3.1;
        roof.rotation.y = Math.PI / 4;
        roof.castShadow = true;
        group.add(roof);
        
        // 窗口
        const windowMat = new THREE.MeshStandardMaterial({ color: 0x42a5f5, roughness: 0.2, metalness: 0.3 });
        const window1 = new THREE.Mesh(GeoCache.getBox(1.2, 0.8, 0.1), windowMat);
        window1.position.set(0, 1.5, 1.26);
        group.add(window1);
        
        // 售票标志
        const signMat = new THREE.MeshStandardMaterial({ color: 0xffeb3b, roughness: 0.4, emissive: 0xffeb3b, emissiveIntensity: 0.2 });
        const sign = new THREE.Mesh(GeoCache.getBox(1.5, 0.4, 0.1), signMat);
        sign.position.set(0, 2.3, 1.26);
        group.add(sign);
        
        return group;
    }
    
    // 棉花糖或扭蛋机（可破坏）
    function createCottonCandyOrGachapon() {
        const group = new THREE.Group();
        
        if (Math.random() < 0.5) {
            // 棉花糖
            const colors = [0xffb6c1, 0x87ceeb, 0x98fb98, 0xdda0dd, 0xfffacd];
            const cottonColor = colors[Math.floor(Math.random() * colors.length)];
            
            // 棉花糖主体
            const cottonMat = new THREE.MeshStandardMaterial({ 
                color: cottonColor, 
                roughness: 0.9,
                transparent: true,
                opacity: 0.9
            });
            const cotton = new THREE.Mesh(GeoCache.getSphere(1.0, 12), cottonMat);
            cotton.position.y = 2.2;
            cotton.scale.set(1, 1.3, 1);
            cotton.castShadow = true;
            group.add(cotton);
            
            // 棉花糖蓬松效果
            for (let i = 0; i < 5; i++) {
                const puff = new THREE.Mesh(GeoCache.getSphere(0.4, 8), cottonMat);
                const angle = (i / 5) * Math.PI * 2;
                puff.position.set(Math.cos(angle) * 0.6, 2.0 + Math.random() * 0.5, Math.sin(angle) * 0.6);
                group.add(puff);
            }
            
            // 木棍
            const stickMat = new THREE.MeshStandardMaterial({ color: 0xd4a574, roughness: 0.7 });
            const stick = new THREE.Mesh(GeoCache.getCylinder(0.1, 0.1, 2.0, 6), stickMat);
            stick.position.y = 1.0;
            group.add(stick);
        } else {
            // 扭蛋机
            // 底座
            const baseMat = new THREE.MeshStandardMaterial({ color: 0xef5350, roughness: 0.4, metalness: 0.3 });
            const base = new THREE.Mesh(GeoCache.getCylinder(0.8, 0.9, 0.5, 12), baseMat);
            base.position.y = 0.25;
            base.castShadow = true;
            group.add(base);
            
            // 主体
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xef5350, roughness: 0.4 });
            const body = new THREE.Mesh(GeoCache.getCylinder(0.7, 0.8, 1.0, 12), bodyMat);
            body.position.y = 1.0;
            body.castShadow = true;
            group.add(body);
            
            // 透明球体（装扭蛋的部分）
            const globeMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                roughness: 0.1, 
                metalness: 0.1,
                transparent: true,
                opacity: 0.6
            });
            const globe = new THREE.Mesh(GeoCache.getSphere(0.9, 16), globeMat);
            globe.position.y = 2.2;
            group.add(globe);
            
            // 里面的小扭蛋
            const eggColors = [0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3, 0xf38181];
            for (let i = 0; i < 6; i++) {
                const eggMat = new THREE.MeshStandardMaterial({ color: eggColors[i % eggColors.length], roughness: 0.3 });
                const egg = new THREE.Mesh(GeoCache.getSphere(0.2, 8), eggMat);
                egg.position.set(
                    (Math.random() - 0.5) * 0.8,
                    2.0 + Math.random() * 0.4,
                    (Math.random() - 0.5) * 0.8
                );
                group.add(egg);
            }
            
            // 顶盖
            const topMat = new THREE.MeshStandardMaterial({ color: 0xef5350, roughness: 0.4 });
            const top = new THREE.Mesh(GeoCache.getCylinder(0.5, 0.7, 0.3, 12), topMat);
            top.position.y = 3.0;
            group.add(top);
        }
        
        return group;
    }
    
    // 中央旋转木马
    function createCenterCarousel() {
        const group = new THREE.Group();
        const centerX = Math.floor(CONFIG.GRID_WIDTH / 2);
        const centerZ = Math.floor(CONFIG.GRID_HEIGHT / 2);
        const pos = gridToWorld(centerX, centerZ);
        
        // 底座
        const baseMat = new THREE.MeshStandardMaterial({ color: 0xffd54f, roughness: 0.3, metalness: 0.4 });
        const base = new THREE.Mesh(GeoCache.getCylinder(4.5, 5.0, 0.6, 24), baseMat);
        base.position.y = 0.3;
        base.receiveShadow = true;
        base.castShadow = true;
        group.add(base);
        
        // 装饰边缘
        const edgeMat = new THREE.MeshStandardMaterial({ color: 0xef5350, roughness: 0.4, metalness: 0.3 });
        const edge = new THREE.Mesh(GeoCache.getCylinder(5.0, 5.2, 0.3, 24), edgeMat);
        edge.position.y = 0.15;
        group.add(edge);
        
        // 中央柱子
        const poleMat = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.2, metalness: 0.7 });
        const centerPole = new THREE.Mesh(GeoCache.getCylinder(0.5, 0.6, 5, 12), poleMat);
        centerPole.position.y = 3.0;
        centerPole.castShadow = true;
        group.add(centerPole);
        
        // 顶棚
        const roofMat = new THREE.MeshStandardMaterial({ color: 0xef5350, roughness: 0.4 });
        const roof = new THREE.Mesh(GeoCache.getCone(5.5, 2.5, 24), roofMat);
        roof.position.y = 6.5;
        roof.castShadow = true;
        group.add(roof);
        
        // 顶棚装饰条纹
        const stripeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
        for (let i = 0; i < 8; i++) {
            const stripe = new THREE.Mesh(GeoCache.getBox(0.15, 2.6, 4.5), stripeMat);
            stripe.position.y = 6.5;
            stripe.rotation.y = (i / 8) * Math.PI * 2;
            stripe.rotation.x = 0.45;
            group.add(stripe);
        }
        
        // 顶部装饰球
        const topBallMat = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.2, metalness: 0.8, emissive: 0xffd700, emissiveIntensity: 0.3 });
        const topBall = new THREE.Mesh(GeoCache.getSphere(0.5, 12), topBallMat);
        topBall.position.y = 8.0;
        group.add(topBall);
        
        // 旋转木马的马匹
        const horseColors = [0xffffff, 0xffcc80, 0xce93d8, 0x81d4fa, 0xa5d6a7, 0xffab91];
        for (let i = 0; i < 6; i++) {
            const horseGroup = new THREE.Group();
            const horseMat = new THREE.MeshStandardMaterial({ color: horseColors[i], roughness: 0.5 });
            
            // 马身体
            const body = new THREE.Mesh(GeoCache.getBox(0.8, 0.6, 1.5), horseMat);
            body.position.y = 0;
            horseGroup.add(body);
            
            // 马头
            const head = new THREE.Mesh(GeoCache.getBox(0.4, 0.5, 0.6), horseMat);
            head.position.set(0, 0.3, 0.8);
            head.rotation.x = 0.3;
            horseGroup.add(head);
            
            // 马腿
            const legMat = new THREE.MeshStandardMaterial({ color: horseColors[i], roughness: 0.5 });
            const legPositions = [[-0.25, -0.6, 0.4], [0.25, -0.6, 0.4], [-0.25, -0.6, -0.4], [0.25, -0.6, -0.4]];
            legPositions.forEach(lp => {
                const leg = new THREE.Mesh(GeoCache.getCylinder(0.1, 0.1, 0.6, 6), legMat);
                leg.position.set(lp[0], lp[1], lp[2]);
                horseGroup.add(leg);
            });
            
            // 支撑杆
            const supportPole = new THREE.Mesh(GeoCache.getCylinder(0.08, 0.08, 3, 8), poleMat);
            supportPole.position.y = 1.5;
            horseGroup.add(supportPole);
            
            // 放置马匹
            const angle = (i / 6) * Math.PI * 2;
            horseGroup.position.set(Math.cos(angle) * 3.2, 2.0 + Math.sin(i * 0.5) * 0.3, Math.sin(angle) * 3.2);
            horseGroup.rotation.y = -angle + Math.PI / 2;
            group.add(horseGroup);
        }
        
        group.position.set(pos.x, 0, pos.z);
        scene.add(group);
        mapMeshes.push(group);
        waterTrap = group;
        centerCarouselGroup = group; // 保存引用用于旋转动画
    }
    
    // ==================== 沙漠主题装饰物 ====================
    function createSandstoneWall() {
        const group = new THREE.Group();
        const sandMat = new THREE.MeshStandardMaterial({ color: 0xd4a574, roughness: 0.9 });
        const darkMat = new THREE.MeshStandardMaterial({ color: 0xb8956e, roughness: 0.9 });
        
        const block1 = new THREE.Mesh(GeoCache.getBox(2.8, 2.0, 2.8), sandMat);
        block1.position.y = 1.0;
        block1.castShadow = true;
        group.add(block1);
        
        const block2 = new THREE.Mesh(GeoCache.getBox(2.0, 1.0, 2.0), darkMat);
        block2.position.y = 2.5;
        block2.castShadow = true;
        group.add(block2);
        
        return group;
    }
    
    function createCactus() {
        const group = new THREE.Group();
        const cactusMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32, roughness: 0.7 });
        const flowerMat = new THREE.MeshStandardMaterial({ color: 0xf06292, roughness: 0.5 });
        
        const body = new THREE.Mesh(GeoCache.getCylinder(0.6, 0.5, 2.5, 8), cactusMat);
        body.position.y = 1.25;
        body.castShadow = true;
        group.add(body);
        
        const arm1 = new THREE.Mesh(GeoCache.getCylinder(0.3, 0.25, 1.2, 8), cactusMat);
        arm1.position.set(0.8, 1.8, 0);
        arm1.rotation.z = -0.8;
        group.add(arm1);
        
        const arm2 = new THREE.Mesh(GeoCache.getCylinder(0.25, 0.2, 1.0, 8), cactusMat);
        arm2.position.set(-0.7, 1.5, 0);
        arm2.rotation.z = 0.9;
        group.add(arm2);
        
        if (Math.random() > 0.5) {
            const flower = new THREE.Mesh(GeoCache.getSphere(0.25, 6), flowerMat);
            flower.position.y = 2.7;
            group.add(flower);
        }
        
        return group;
    }
    
    function createPottery() {
        const group = new THREE.Group();
        const potMat = new THREE.MeshStandardMaterial({ color: 0xd84315, roughness: 0.7 });
        const sandMat = new THREE.MeshStandardMaterial({ color: 0xe0c9a6, roughness: 0.9 });
        
        const pot = new THREE.Mesh(GeoCache.getCylinder(0.8, 0.5, 1.5, 12), potMat);
        pot.position.y = 0.75;
        pot.castShadow = true;
        group.add(pot);
        
        const rim = new THREE.Mesh(GeoCache.getCylinder(0.9, 0.85, 0.2, 12), potMat);
        rim.position.y = 1.6;
        group.add(rim);
        
        const sand = new THREE.Mesh(GeoCache.getCylinder(0.7, 0.7, 0.1, 12), sandMat);
        sand.position.y = 1.45;
        group.add(sand);
        
        return group;
    }
    
    // 沙漠关卡 - 随机生成陶罐或木箱
    function createPotteryOrWoodCrate() {
        return Math.random() < 0.5 ? createPottery() : createWoodCrate();
    }
    
    // 沙漠关卡 - 木箱
    function createWoodCrate() {
        const group = new THREE.Group();
        const woodMat = new THREE.MeshStandardMaterial({ color: 0x8b5a2b, roughness: 0.8 });
        const darkWoodMat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.7 });
        
        // 木箱主体
        const box = new THREE.Mesh(GeoCache.getBox(1.8, 1.8, 1.8), woodMat);
        box.position.y = 0.9;
        box.castShadow = true;
        group.add(box);
        
        // 横向木条装饰
        for (let i = 0; i < 3; i++) {
            const plank = new THREE.Mesh(GeoCache.getBox(2.0, 0.15, 0.1), darkWoodMat);
            plank.position.set(0, 0.4 + i * 0.6, 0.95);
            group.add(plank);
            
            const plankBack = new THREE.Mesh(GeoCache.getBox(2.0, 0.15, 0.1), darkWoodMat);
            plankBack.position.set(0, 0.4 + i * 0.6, -0.95);
            group.add(plankBack);
        }
        
        // 竖向木条
        for (let i = -1; i <= 1; i++) {
            const vertPlank = new THREE.Mesh(GeoCache.getBox(0.1, 1.9, 0.1), darkWoodMat);
            vertPlank.position.set(i * 0.7, 0.95, 0.95);
            group.add(vertPlank);
        }
        
        return group;
    }
    
    // ==================== 沙漠关卡 - 沙尘龙卷风系统 ====================
    
    // 创建4个固定位置的沙尘龙卷风
    function createSandstorms() {
        // 清理旧的龙卷风
        sandstorms.forEach(s => scene.remove(s.mesh));
        sandstorms = [];
        flyingPlayers = [];
        
        // 4个固定位置（地图四个象限）
        const positions = [
            { gx: 3, gz: 3 },   // 左上
            { gx: CONFIG.GRID_WIDTH - 4, gz: 3 },  // 右上
            { gx: 3, gz: CONFIG.GRID_HEIGHT - 4 }, // 左下
            { gx: CONFIG.GRID_WIDTH - 4, gz: CONFIG.GRID_HEIGHT - 4 }  // 右下
        ];
        
        positions.forEach((pos, index) => {
            const worldPos = gridToWorld(pos.gx, pos.gz);
            const mesh = createSandstormMesh();
            mesh.position.set(worldPos.x, 0, worldPos.z);
            scene.add(mesh);
            
            sandstorms.push({
                mesh: mesh,
                gx: pos.gx,
                gz: pos.gz,
                x: worldPos.x,
                z: worldPos.z,
                rotationSpeed: 2 + Math.random() * 1,
                phase: index * Math.PI / 2
            });
        });
    }
    
    // 创建龙卷风3D模型
    function createSandstormMesh() {
        const group = new THREE.Group();
        const sandColor = 0xd4a574;
        const darkSandColor = 0xb8956a;
        
        // 多层锥形构成龙卷风
        for (let i = 0; i < 5; i++) {
            const bottomRadius = 0.3 + i * 0.4;
            const topRadius = 0.5 + i * 0.5;
            const height = 1.2;
            const yPos = i * 1.0;
            
            const mat = new THREE.MeshStandardMaterial({
                color: i % 2 === 0 ? sandColor : darkSandColor,
                transparent: true,
                opacity: 0.7 - i * 0.08,
                roughness: 0.9
            });
            
            const cone = new THREE.Mesh(
                GeoCache.getCylinder(topRadius, bottomRadius, height, 12),
                mat
            );
            cone.position.y = yPos + height / 2;
            cone.userData.layerIndex = i;
            group.add(cone);
        }
        
        // 添加旋转的沙粒效果
        const particleMat = new THREE.MeshBasicMaterial({
            color: 0xe0c9a6,
            transparent: true,
            opacity: 0.6
        });
        
        for (let i = 0; i < 20; i++) {
            const particle = new THREE.Mesh(
                GeoCache.getSphere(0.1, 6, 4),
                particleMat
            );
            const angle = (i / 20) * Math.PI * 2;
            const radius = 0.5 + Math.random() * 1.5;
            const height = Math.random() * 4;
            particle.position.set(
                Math.cos(angle) * radius,
                height,
                Math.sin(angle) * radius
            );
            particle.userData.particleAngle = angle;
            particle.userData.particleRadius = radius;
            particle.userData.particleHeight = height;
            group.add(particle);
        }
        
        return group;
    }
    
    // 更新沙尘龙卷风
    function updateSandstorms(dt, elapsed) {
        sandstorms.forEach(storm => {
            // 旋转动画
            storm.mesh.rotation.y += storm.rotationSpeed * dt;
            
            // 更新各层的轻微摆动
            storm.mesh.children.forEach((child, i) => {
                if (child.userData.layerIndex !== undefined) {
                    const sway = Math.sin(elapsed * 2 + storm.phase + i * 0.5) * 0.1;
                    child.position.x = sway;
                    child.position.z = Math.cos(elapsed * 2 + storm.phase + i * 0.3) * 0.1;
                }
                
                // 更新沙粒旋转
                if (child.userData.particleAngle !== undefined) {
                    const newAngle = child.userData.particleAngle + elapsed * 3;
                    const radius = child.userData.particleRadius;
                    child.position.x = Math.cos(newAngle) * radius;
                    child.position.z = Math.sin(newAngle) * radius;
                    child.position.y = child.userData.particleHeight + Math.sin(elapsed * 5 + child.userData.particleAngle) * 0.3;
                }
            });
            
            // 检测玩家碰撞
            checkSandstormCollision(storm);
        });
        
        // 更新被抛飞的玩家
        updateFlyingPlayersFromSandstorm(dt);
    }
    
    // 检测龙卷风与玩家碰撞
    function checkSandstormCollision(storm) {
        players.forEach(player => {
            if (player.isDead || player.isFlying) return;
            
            const dx = player.mesh.position.x - storm.x;
            const dz = player.mesh.position.z - storm.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            
            // 碰撞半径约1.5个单位
            if (dist < 1.5) {
                launchPlayerBySandstorm(player, storm);
            }
        });
    }
    
    // 被龙卷风抛飞
    function launchPlayerBySandstorm(player, storm) {
        player.isFlying = true;
        
        // 播放音效
        soundManager.playExplosion();
        
        // 检查某个位置周围是否至少有一个空格
        function hasAdjacentEmpty(x, z) {
            const dirs = [
                { dx: 1, dz: 0 }, { dx: -1, dz: 0 },
                { dx: 0, dz: 1 }, { dx: 0, dz: -1 }
            ];
            for (const dir of dirs) {
                const nx = x + dir.dx;
                const nz = z + dir.dz;
                if (nx >= 1 && nx < CONFIG.GRID_WIDTH - 1 && 
                    nz >= 1 && nz < CONFIG.GRID_HEIGHT - 1 &&
                    grid[nz][nx] === TILE.EMPTY) {
                    return true;
                }
            }
            return false;
        }
        
        // 找一个随机空地作为落点
        const emptySpots = [];
        for (let z = 1; z < CONFIG.GRID_HEIGHT - 1; z++) {
            for (let x = 1; x < CONFIG.GRID_WIDTH - 1; x++) {
                if (grid[z][x] === TILE.EMPTY && !isSpawnArea(x, z)) {
                    // 确保不落在龙卷风位置
                    let isSafe = true;
                    sandstorms.forEach(s => {
                        if (Math.abs(s.gx - x) < 2 && Math.abs(s.gz - z) < 2) {
                            isSafe = false;
                        }
                    });
                    // 确保落点周围至少有一个空格
                    if (isSafe && hasAdjacentEmpty(x, z)) {
                        emptySpots.push({ x, z });
                    }
                }
            }
        }
        
        if (emptySpots.length === 0) {
            player.isFlying = false;
            return;
        }
        
        const target = emptySpots[Math.floor(Math.random() * emptySpots.length)];
        const targetPos = gridToWorld(target.x, target.z);
        
        flyingPlayers.push({
            player: player,
            startX: player.mesh.position.x,
            startZ: player.mesh.position.z,
            targetX: targetPos.x,
            targetZ: targetPos.z,
            progress: 0,
            duration: 1.2,
            maxHeight: 8
        });
    }
    
    // 更新飞行中的玩家
    function updateFlyingPlayersFromSandstorm(dt) {
        for (let i = flyingPlayers.length - 1; i >= 0; i--) {
            const fp = flyingPlayers[i];
            fp.progress += dt / fp.duration;
            
            if (fp.progress >= 1) {
                // 落地
                fp.player.mesh.position.x = fp.targetX;
                fp.player.mesh.position.z = fp.targetZ;
                fp.player.mesh.position.y = 0;
                fp.player.mesh.rotation.set(0, 0, 0);
                fp.player.isFlying = false;
                
                // 落地尘土特效
                createLandingEffect(fp.targetX, fp.targetZ);
                
                flyingPlayers.splice(i, 1);
            } else {
                // 抛物线运动
                const t = fp.progress;
                fp.player.mesh.position.x = fp.startX + (fp.targetX - fp.startX) * t;
                fp.player.mesh.position.z = fp.startZ + (fp.targetZ - fp.startZ) * t;
                // 抛物线高度
                fp.player.mesh.position.y = fp.maxHeight * 4 * t * (1 - t);
                // 旋转效果
                fp.player.mesh.rotation.y += dt * 10;
                fp.player.mesh.rotation.x = Math.sin(t * Math.PI) * 0.5;
            }
        }
    }
    
    // 落地尘土特效
    function createLandingEffect(x, z) {
        const dustMat = new THREE.MeshBasicMaterial({
            color: 0xd4a574,
            transparent: true,
            opacity: 0.6
        });
        
        for (let i = 0; i < 8; i++) {
            const dust = new THREE.Mesh(GeoCache.getSphere(0.2, 6, 4), dustMat.clone());
            const angle = (i / 8) * Math.PI * 2;
            dust.position.set(x, 0.3, z);
            scene.add(dust);
            
            // 简单的扩散动画
            const targetX = x + Math.cos(angle) * 1.5;
            const targetZ = z + Math.sin(angle) * 1.5;
            
            const startTime = performance.now();
            const animateDust = () => {
                const elapsed = (performance.now() - startTime) / 500;
                if (elapsed >= 1) {
                    scene.remove(dust);
                    return;
                }
                dust.position.x = x + (targetX - x) * elapsed;
                dust.position.z = z + (targetZ - z) * elapsed;
                dust.position.y = 0.3 + elapsed * 0.5;
                dust.material.opacity = 0.6 * (1 - elapsed);
                dust.scale.setScalar(1 + elapsed);
                requestAnimationFrame(animateDust);
            };
            animateDust();
        }
    }
    
    function createOasis() {
        const group = new THREE.Group();
        const centerX = Math.floor(CONFIG.GRID_WIDTH / 2);
        const centerZ = Math.floor(CONFIG.GRID_HEIGHT / 2);
        const pos = gridToWorld(centerX, centerZ);
        
        const waterMat = new THREE.MeshStandardMaterial({ color: 0x4fc3f7, roughness: 0.0, metalness: 0.2, transparent: true, opacity: 0.85 });
        const sandMat = new THREE.MeshStandardMaterial({ color: 0xe0c9a6, roughness: 0.9 });
        const palmTrunkMat = new THREE.MeshStandardMaterial({ color: 0x6d4c41, roughness: 0.8 });
        const palmLeafMat = new THREE.MeshStandardMaterial({ color: 0x4caf50, roughness: 0.6 });
        
        const sandRing = new THREE.Mesh(GeoCache.getCylinder(4.5, 5, 0.3, 16), sandMat);
        sandRing.position.y = 0.15;
        group.add(sandRing);
        
        const water = new THREE.Mesh(GeoCache.getCylinder(3.5, 3.5, 0.25, 16), waterMat);
        water.position.y = 0.2;
        group.add(water);
        
        // 棕榈树
        const trunk = new THREE.Mesh(GeoCache.getCylinder(0.3, 0.4, 4, 8), palmTrunkMat);
        trunk.position.set(0, 2, 0);
        trunk.rotation.x = 0.1;
        group.add(trunk);
        
        for (let i = 0; i < 6; i++) {
            const leaf = new THREE.Mesh(GeoCache.getBox(0.3, 0.1, 2.5), palmLeafMat);
            const angle = (i / 6) * Math.PI * 2;
            leaf.position.set(Math.cos(angle) * 0.8, 4.2, Math.sin(angle) * 0.8);
            leaf.rotation.x = 0.5;
            leaf.rotation.y = angle;
            group.add(leaf);
        }
        
        group.position.set(pos.x, 0, pos.z);
        group.scale.set(1.3, 1.3, 1.3);
        scene.add(group);
        mapMeshes.push(group);
        waterTrap = group;
    }
    
    // 宝箱 - 特殊可破坏方块（童话风格）
    function createTreasureChest() {
        const group = new THREE.Group();
        
        const woodMat = new THREE.MeshStandardMaterial({ 
            color: 0x8b4513, 
            roughness: 0.7 
        });
        const goldMat = new THREE.MeshStandardMaterial({ 
            color: 0xffd700, 
            roughness: 0.2, 
            metalness: 0.9,
            emissive: 0xffd700,
            emissiveIntensity: 0.15
        });
        const gemMat = new THREE.MeshStandardMaterial({ 
            color: 0xff69b4, 
            roughness: 0.1, 
            metalness: 0.3, 
            emissive: 0xff69b4, 
            emissiveIntensity: 0.4 
        });
        
        // 箱体底部 - 更圆润
        const base = new THREE.Mesh(GeoCache.getBox(2.2, 1.2, 1.6), woodMat);
        base.position.y = 0.6;
        base.castShadow = true;
        group.add(base);
        
        // 箱盖（弧形）
        const lidGeo = GeoCache.getCylinder(0.8, 0.8, 2.2, 12, 1, false, 0, Math.PI);
        const lid = new THREE.Mesh(lidGeo, woodMat);
        lid.position.y = 1.2;
        lid.rotation.z = Math.PI / 2;
        lid.rotation.y = Math.PI / 2;
        lid.castShadow = true;
        group.add(lid);
        
        // 金色边框
        const trimBot = new THREE.Mesh(GeoCache.getBox(2.3, 0.12, 1.7), goldMat);
        trimBot.position.y = 0.06;
        group.add(trimBot);
        
        const trimMid = new THREE.Mesh(GeoCache.getBox(2.3, 0.08, 1.7), goldMat);
        trimMid.position.y = 1.2;
        group.add(trimMid);
        
        // 心形锁扣（用球体组合）
        const lockBase = new THREE.Mesh(GeoCache.getSphere(0.25, 8), goldMat);
        lockBase.position.set(0, 0.9, 0.85);
        lockBase.scale.set(1, 1.2, 0.5);
        group.add(lockBase);
        
        // 宝石装饰 - 粉色心形
        const gem = new THREE.Mesh(GeoCache.getSphere(0.18, 8), gemMat);
        gem.position.set(0, 0.9, 0.95);
        group.add(gem);
        
        // 闪光星星装饰
        const starMat = new THREE.MeshBasicMaterial({ 
            color: 0xffff88, 
            transparent: true, 
            opacity: 0.8 
        });
        for (let i = 0; i < 3; i++) {
            const star = new THREE.Mesh(GeoCache.getSphere(0.08, 4), starMat);
            star.position.set(
                -0.8 + i * 0.8,
                1.6 + Math.random() * 0.3,
                0.5
            );
            group.add(star);
        }
        
        return group;
    }

    // ==================== 工具函数 ====================
    function gridToWorld(gx, gz) {
        return {
            x: (gx - Math.floor(CONFIG.GRID_WIDTH / 2)) * CONFIG.TILE_SIZE,
            z: (gz - Math.floor(CONFIG.GRID_HEIGHT / 2)) * CONFIG.TILE_SIZE
        };
    }

    function worldToGrid(wx, wz) {
        return {
            x: Math.round(wx / CONFIG.TILE_SIZE + Math.floor(CONFIG.GRID_WIDTH / 2)),
            z: Math.round(wz / CONFIG.TILE_SIZE + Math.floor(CONFIG.GRID_HEIGHT / 2))
        };
    }

    function canBombMoveTo(gx, gz) {
        if (gx < 0 || gx >= CONFIG.GRID_WIDTH || gz < 0 || gz >= CONFIG.GRID_HEIGHT) return false;
        if (grid[gz][gx] !== TILE.EMPTY) return false;
        if (bombs.some(b => b.gridX === gx && b.gridZ === gz)) return false;
        if (players.some(p => !p.isDead && p.gridX === gx && p.gridZ === gz)) return false;
        return true;
    }

    // ==================== 游戏流程 ====================
    let currentLevel = 'fairy'; // 当前选择的关卡
    
    function selectMode(mode) {
        gameMode = mode;
        showLevelSelect();
    }
    
    function showLevelSelect() {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('level-select-screen').classList.remove('hidden');
    }
    
    function backToStart() {
        document.getElementById('level-select-screen').classList.add('hidden');
        document.getElementById('start-screen').classList.remove('hidden');
    }
    
    function selectLevel(level) {
        currentLevel = level;
        document.getElementById('level-select-screen').classList.add('hidden');
        soundManager.playGameStart();
        beginMatch();
    }
    
    function startGame() {
        document.getElementById('start-screen').classList.add('hidden');
        // 直接开始游戏，跳过颜色选择
        soundManager.playGameStart();
        beginMatch();
    }

    function updateReadyStatus() {
        const panel1 = document.getElementById('panel-p1');
        const panel2 = document.getElementById('panel-p2');
        const status1 = document.getElementById('status-p1');
        const status2 = document.getElementById('status-p2');
        
        panel1.classList.toggle('ready', p1Selection.ready);
        panel2.classList.toggle('ready', p2Selection.ready);
        status1.textContent = p1Selection.ready ? 'READY!' : '等待中...';
        status2.textContent = p2Selection.ready ? 'READY!' : '等待中...';
        
        // 检查是否都准备好了
        if (p1Selection.ready && p2Selection.ready) {
            if (!countdownInterval) startCountdown();
        } else {
            if (countdownInterval) stopCountdown();
        }
    }

    function startCountdown() {
        let count = 3;
        const countdownEl = document.getElementById('countdown');
        countdownEl.style.display = 'block';
        countdownEl.textContent = count;
        soundManager.playCountdown();
        
        countdownInterval = setInterval(() => {
            count--;
            if (count > 0) {
                countdownEl.textContent = count;
                soundManager.playCountdown();
            } else {
                clearInterval(countdownInterval);
                countdownInterval = null;
                countdownEl.style.display = 'none';
                soundManager.playGameStart();
                beginMatch();
            }
        }, 1000);
    }

    function stopCountdown() {
        if (countdownInterval) {
            clearInterval(countdownInterval);
            countdownInterval = null;
        }
        document.getElementById('countdown').style.display = 'none';
    }

    function beginMatch() {
        document.getElementById('game-ui').style.display = 'block';
        document.getElementById('sound-btn').style.display = 'none'; // 隐藏主界面音量按钮
        gameState = 'playing';
        
        // 播放游戏背景音乐
        soundManager.playGameBgm();
        
        gameTime = CONFIG.GAME_TIME;
        bombs = [];
        explosions = [];
        powerups = [];
        kickGlovesDropped = 0; // 重置手套计数
        
        // 重置爆炸对象池
        explosionPool.releaseAll();
        
        players.forEach(p => scene.remove(p.mesh));
        players = [];
        
        createMap();
        
        // 根据游戏模式创建玩家
        if (gameMode === 'single') {
            // 单人模式：玩家1在左上角（粉色），其他3个为AI
            players.push(new Player(1, null, 1, 1, false));  // 玩家控制
            players.push(new Player(2, null, CONFIG.GRID_WIDTH - 2, CONFIG.GRID_HEIGHT - 2, true));  // AI
            players.push(new Player(3, null, CONFIG.GRID_WIDTH - 2, 1, true));  // AI
            players.push(new Player(4, null, 1, CONFIG.GRID_HEIGHT - 2, true));  // AI
        } else {
            // 双人模式：玩家1和玩家2，2个AI
            players.push(new Player(1, null, 1, 1, false));
            players.push(new Player(2, null, CONFIG.GRID_WIDTH - 2, CONFIG.GRID_HEIGHT - 2, false));
            players.push(new Player(3, null, CONFIG.GRID_WIDTH - 2, 1, true));
            players.push(new Player(4, null, 1, CONFIG.GRID_HEIGHT - 2, true));
        }
        
        // 更新HUD标签（单人模式下玩家2显示为AI 1）
        const hudP2Name = document.querySelector('#hud-p2 .hud-avatar-name');
        const hudP2Label = document.querySelector('#hud-p2 .hud-player-label');
        if (hudP2Name) {
            hudP2Name.textContent = gameMode === 'single' ? 'AI 1' : '玩家 2';
        }
        if (hudP2Label) {
            hudP2Label.textContent = gameMode === 'single' ? 'AI' : 'P2';
        }
        const hudAi1Name = document.querySelector('#hud-ai1 .hud-avatar-name');
        if (hudAi1Name) {
            hudAi1Name.textContent = gameMode === 'single' ? 'AI 2' : 'AI 1';
        }
        const hudAi2Name = document.querySelector('#hud-ai2 .hud-avatar-name');
        if (hudAi2Name) {
            hudAi2Name.textContent = gameMode === 'single' ? 'AI 3' : 'AI 2';
        }
        
        // 设置相机
        camera.position.set(0, 45, 30);
        camera.lookAt(0, 0, 0);
        
        // 生成玩家头像
        generatePlayerAvatars();
        
        updateHUD();
    }
    
    // 生成玩家头像（从角色模型截图）
    function generatePlayerAvatars() {
        const avatarIds = ['avatar-p1', 'avatar-p2', 'avatar-ai1', 'avatar-ai2'];
        const modelIndices = [0, 1, 2, 3]; // 对应粉、蓝、绿、黄酷比
        
        // 保存当前渲染器状态
        const originalClearColor = renderer.getClearColor(new THREE.Color());
        const originalClearAlpha = renderer.getClearAlpha();
        const originalSize = new THREE.Vector2();
        renderer.getSize(originalSize);
        
        // 创建一个离屏canvas用于生成头像
        const avatarCanvas = document.createElement('canvas');
        avatarCanvas.width = 128;
        avatarCanvas.height = 128;
        const avatarCtx = avatarCanvas.getContext('2d');
        
        avatarIds.forEach((avatarId, index) => {
            const avatarEl = document.getElementById(avatarId);
            if (!avatarEl) return;
            
            const template = gltfModelTemplates[modelIndices[index]];
            if (!template) {
                // 如果模型未加载，使用默认颜色
                const defaultColors = ['#ff6b9d', '#00aaff', '#44ff44', '#ffaa00'];
                avatarEl.style.background = defaultColors[index];
                return;
            }
            
            // 创建临时场景和相机来渲染头像
            const avatarScene = new THREE.Scene();
            
            // 根据角色设置不同的渐变背景色
            const bgColors = [
                [0xffd6e0, 0xffb3c6], // 粉色渐变 - 粉酷比
                [0xd6eaff, 0xb3d4ff], // 蓝色渐变 - 蓝酷比
                [0xd6ffd6, 0xb3ffb3], // 绿色渐变 - 绿酷比
                [0xfff0d6, 0xffe0b3]  // 黄色渐变 - 黄酷比
            ];
            avatarScene.background = new THREE.Color(bgColors[index][0]);
            
            // 添加光源
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
            avatarScene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(0, 1, 2);
            avatarScene.add(directionalLight);
            // 添加背光让角色更立体
            const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
            backLight.position.set(0, 0, -2);
            avatarScene.add(backLight);
            
            // 克隆模型
            const model = template.clone(true);
            model.position.set(-1, 0, 0);
            model.rotation.set(0, 0, 0); // 正面朝向
            avatarScene.add(model);
            
            // 创建正交相机（正面视角，拉远以显示完整角色）
            const avatarCamera = new THREE.OrthographicCamera(-3, 3, 3, -3, 0.1, 100);
            avatarCamera.position.set(0, 0.5, 5);
            avatarCamera.lookAt(0, 0.5, 0);
            
            // 使用主渲染器渲染头像（复用上下文，避免黑屏问题）
            renderer.setSize(128, 128);
            renderer.setClearColor(bgColors[index][0], 1);
            renderer.render(avatarScene, avatarCamera);
            
            // 将渲染结果复制到离屏canvas
            avatarCtx.clearRect(0, 0, 128, 128);
            avatarCtx.drawImage(renderer.domElement, 0, 0);
            const dataURL = avatarCanvas.toDataURL('image/png');
            
            // 设置头像背景
            avatarEl.style.backgroundImage = `url(${dataURL})`;
            
            // 清理临时场景
            avatarScene.remove(model);
            avatarScene.remove(ambientLight);
            avatarScene.remove(directionalLight);
            avatarScene.remove(backLight);
        });
        
        // 恢复渲染器状态
        renderer.setSize(originalSize.x, originalSize.y);
        renderer.setClearColor(originalClearColor, originalClearAlpha);
    }

    function updateHUD() {
        const ids = ['p1', 'p2', 'ai1', 'ai2'];
        players.forEach((p, i) => {
            const id = ids[i];
            const speedEl = document.getElementById(`stat-${id}-speed`);
            const rangeEl = document.getElementById(`stat-${id}-range`);
            const bombEl = document.getElementById(`stat-${id}-bomb`);
            const kickEl = document.getElementById(`stat-${id}-kick`);
            const weaponEl = document.getElementById(`stat-${id}-weapon`);
            const weaponValEl = document.getElementById(`stat-${id}-weapon-val`);
            
            if (speedEl) {
                speedEl.textContent = p.speedLevel >= p.maxSpeed ? 'MAX' : (p.speedLevel + 1);
                const speedRow = document.getElementById(`stat-${id}-speed-row`);
                if (speedRow) speedRow.classList.toggle('stat-max', p.speedLevel >= p.maxSpeed);
            }
            if (rangeEl) {
                rangeEl.textContent = p.rangeLevel >= p.maxRange ? 'MAX' : (p.rangeLevel + 1);
                const rangeRow = document.getElementById(`stat-${id}-range-row`);
                if (rangeRow) rangeRow.classList.toggle('stat-max', p.rangeLevel >= p.maxRange);
            }
            if (bombEl) {
                bombEl.textContent = p.bombLevel >= p.maxBombLevel ? 'MAX' : (p.bombLevel + 1);
                const bombRow = document.getElementById(`stat-${id}-bomb-row`);
                if (bombRow) bombRow.classList.toggle('stat-max', p.bombLevel >= p.maxBombLevel);
            }
            if (kickEl) {
                kickEl.classList.toggle('stat-inactive', !p.canKick);
            }
            if (weaponEl) {
                const hasWeapon = p.weapon && p.weaponAmmo > 0;
                weaponEl.classList.toggle('stat-inactive', !hasWeapon);
                // 更新武器图标和数量
                const weaponIconEl = weaponEl.querySelector('.stat-icon');
                if (weaponIconEl) {
                    if (hasWeapon) {
                        const weaponImages = {
                            [WEAPON.LASER]: 'images/激光枪.png',
                            [WEAPON.FLAMETHROWER]: 'images/喷火器.png',
                            [WEAPON.ROCKET]: 'images/火箭筒.png'
                        };
                        weaponIconEl.innerHTML = `<img src="${weaponImages[p.weapon] || 'images/激光枪.png'}" alt="武器">`;
                    } else {
                        weaponIconEl.innerHTML = '';
                    }
                }
                if (weaponValEl) {
                    weaponValEl.textContent = hasWeapon ? p.weaponAmmo : '';
                }
            }
        });
    }

    // ==================== 亮度调节 ====================
    function updateBrightness(multiplier) {
        if (ambientLight) ambientLight.intensity = baseBrightness.ambient * multiplier;
        if (dirLight) dirLight.intensity = baseBrightness.dir * multiplier;
        if (fillLight) fillLight.intensity = baseBrightness.fill * multiplier;
        if (bottomLight) bottomLight.intensity = baseBrightness.bottom * multiplier;
    }

    function checkGameOver() {
        const alive = players.filter(p => !p.isDead);
        const aliveHumans = alive.filter(p => !p.isAI);
        const aliveAIs = alive.filter(p => p.isAI);
        
        // 检查是否所有真人玩家都死亡（游戏结束条件）
        const allHumansDead = aliveHumans.length === 0 && aliveAIs.length > 0;
        
        if (alive.length <= 1 || allHumansDead) {
            gameState = 'gameover';
            
            // 停止背景音乐
            soundManager.stopAllBgm();
            
            let winnerText = '平局!';
            let hasHumanWinner = false;
            
            if (allHumansDead) {
                // 所有真人玩家死亡，AI获胜
                winnerText = 'AI 获胜!';
                hasHumanWinner = false;
            } else if (alive.length === 1) {
                const winner = alive[0];
                // 根据游戏模式显示正确的名称
                let names;
                if (gameMode === 'single') {
                    names = ['玩家 1', 'AI 1', 'AI 2', 'AI 3'];
                } else {
                    names = ['玩家 1', '玩家 2', 'AI 1', 'AI 2'];
                }
                winnerText = names[winner.id - 1] + ' 获胜!';
                hasHumanWinner = !winner.isAI;
            }
            
            // 播放游戏结束音效
            soundManager.playGameOver(hasHumanWinner);
            
            // 延迟1秒后显示结算界面
            setTimeout(() => {
                document.getElementById('winner-text').textContent = winnerText;
                document.getElementById('gameover-screen').classList.remove('hidden');
            }, 1000);
        }
    }

    function restartGame() {
        document.getElementById('gameover-screen').classList.add('hidden');
        document.getElementById('game-ui').style.display = 'none';
        document.getElementById('level-select-screen').classList.remove('hidden');
        document.getElementById('sound-btn').style.display = 'flex'; // 显示主界面音量按钮
        
        // 播放开始界面音乐
        soundManager.playStartBgm();
        
        players.forEach(p => scene.remove(p.mesh));
        bombs.forEach(b => scene.remove(b.mesh));
        explosions.forEach(e => {
            scene.remove(e.mesh);
            explosionPool.release(e);
        });
        powerups.forEach(p => scene.remove(p.mesh));
        projectiles.forEach(p => scene.remove(p.mesh));
        mapMeshes.forEach(m => scene.remove(m));
        
        // 清理沙尘龙卷风
        sandstorms.forEach(s => scene.remove(s.mesh));
        sandstorms = [];
        flyingPlayers = [];
        
        players = [];
        bombs = [];
        explosions = [];
        powerups = [];
        kickGlovesDropped = 0; // 重置手套计数
        projectiles = [];
        mapMeshes = [];
        portals = [];
        volcanoTimer = 0;
        lavaWarnings.forEach(w => scene.remove(w.mesh));
        lavaWarnings = [];
        lavaActive = false;
        cityCars = [];
        grid = [];
        
        gameState = 'start';
        
        ['p1', 'p2', 'ai1', 'ai2'].forEach(id => {
            document.getElementById(`hud-${id}`).classList.remove('hud-dead');
        });
    }

    function backToMainMenu() {
        // 隐藏游戏UI
        document.getElementById('game-ui').style.display = 'none';
        document.getElementById('gameover-screen').classList.add('hidden');
        
        // 显示开始界面和主界面音量按钮
        document.getElementById('start-screen').classList.remove('hidden');
        document.getElementById('sound-btn').style.display = 'flex';
        
        // 播放开始界面音乐
        soundManager.stopAllBgm();
        soundManager.playStartBgm();
        
        // 清理游戏对象
        players.forEach(p => scene.remove(p.mesh));
        bombs.forEach(b => scene.remove(b.mesh));
        explosions.forEach(e => {
            scene.remove(e.mesh);
            explosionPool.release(e);
        });
        powerups.forEach(p => scene.remove(p.mesh));
        projectiles.forEach(p => scene.remove(p.mesh));
        mapMeshes.forEach(m => scene.remove(m));
        lavaWarnings.forEach(w => scene.remove(w.mesh));
        sandstorms.forEach(s => scene.remove(s.mesh));
        
        // 重置游戏状态
        players = [];
        bombs = [];
        explosions = [];
        powerups = [];
        kickGlovesDropped = 0; // 重置手套计数
        projectiles = [];
        mapMeshes = [];
        portals = [];
        volcanoTimer = 0;
        lavaWarnings = [];
        lavaActive = false;
        cityCars = [];
        sandstorms = [];
        flyingPlayers = [];
        grid = [];
        
        gameState = 'start';
        
        // 重置HUD状态
        ['p1', 'p2', 'ai1', 'ai2'].forEach(id => {
            document.getElementById(`hud-${id}`).classList.remove('hud-dead');
        });
    }

    // ==================== 输入处理 ====================
    function onKeyDown(e) {
        keys[e.code] = true;
        
        // 记录玩家1方向键按下顺序
        const p1DirKeys = ['KeyW', 'KeyS', 'KeyA', 'KeyD'];
        if (p1DirKeys.includes(e.code) && !p1DirectionStack.includes(e.code)) {
            p1DirectionStack.push(e.code);
        }
        
        // 记录玩家2方向键按下顺序
        const p2DirKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
        if (p2DirKeys.includes(e.code) && !p2DirectionStack.includes(e.code)) {
            p2DirectionStack.push(e.code);
        }
        
        // 初始化音效
        soundManager.init();
        soundManager.resume();
        
        if (gameState === 'select') {
            // P1控制
            if (e.code === 'KeyA' && !p1Selection.ready) {
                p1Selection.colorIndex = (p1Selection.colorIndex - 1 + KUIKLY_COLORS.length) % KUIKLY_COLORS.length;
                updateColorSelection();
                soundManager.playMenuSelect();
            }
            if (e.code === 'KeyD' && !p1Selection.ready) {
                p1Selection.colorIndex = (p1Selection.colorIndex + 1) % KUIKLY_COLORS.length;
                updateColorSelection();
                soundManager.playMenuSelect();
            }
            if (e.code === 'Space') {
                e.preventDefault();
                p1Selection.ready = !p1Selection.ready;
                soundManager.playReady();
                updateReadyStatus();
            }
            
            // P2控制
            if (e.code === 'ArrowLeft' && !p2Selection.ready) {
                p2Selection.colorIndex = (p2Selection.colorIndex - 1 + KUIKLY_COLORS.length) % KUIKLY_COLORS.length;
                updateColorSelection();
                soundManager.playMenuSelect();
            }
            if (e.code === 'ArrowRight' && !p2Selection.ready) {
                p2Selection.colorIndex = (p2Selection.colorIndex + 1) % KUIKLY_COLORS.length;
                updateColorSelection();
                soundManager.playMenuSelect();
            }
            if (e.code === 'Enter' || e.code === 'NumpadEnter') {
                p2Selection.ready = !p2Selection.ready;
                soundManager.playReady();
                updateReadyStatus();
            }
        }
        
        if (gameState === 'playing') {
            if (e.code === 'Space' && players[0] && !players[0].isDead && !players[0].isFlying) {
                e.preventDefault();
                players[0].input.bomb = true;
            }
            // 只在双人模式下处理玩家2的炸弹输入
            if (gameMode === 'double' && (e.code === 'Enter' || e.code === 'NumpadEnter') && players[1] && !players[1].isDead && !players[1].isFlying) {
                players[1].input.bomb = true;
            }
        }
    }

    function onKeyUp(e) {
        keys[e.code] = false;
        
        // 从玩家1方向栈中移除
        const p1Idx = p1DirectionStack.indexOf(e.code);
        if (p1Idx !== -1) {
            p1DirectionStack.splice(p1Idx, 1);
        }
        
        // 从玩家2方向栈中移除
        const p2Idx = p2DirectionStack.indexOf(e.code);
        if (p2Idx !== -1) {
            p2DirectionStack.splice(p2Idx, 1);
        }
    }

    function handleInput() {
        if (gameState !== 'playing') return;
        
        // P1 - 使用最后按下的方向键
        if (players[0] && !players[0].isDead && !players[0].isFlying) {
            players[0].input.x = 0;
            players[0].input.z = 0;
            
            // 获取最后按下的方向
            if (p1DirectionStack.length > 0) {
                const lastDir = p1DirectionStack[p1DirectionStack.length - 1];
                switch (lastDir) {
                    case 'KeyW': players[0].input.z = -1; break;
                    case 'KeyS': players[0].input.z = 1; break;
                    case 'KeyA': players[0].input.x = -1; break;
                    case 'KeyD': players[0].input.x = 1; break;
                }
            }
        }
        
        // P2 - 只在双人模式下处理，使用最后按下的方向键
        if (gameMode === 'double' && players[1] && !players[1].isDead && !players[1].isFlying) {
            players[1].input.x = 0;
            players[1].input.z = 0;
            
            // 获取最后按下的方向
            if (p2DirectionStack.length > 0) {
                const lastDir = p2DirectionStack[p2DirectionStack.length - 1];
                switch (lastDir) {
                    case 'ArrowUp': players[1].input.z = -1; break;
                    case 'ArrowDown': players[1].input.z = 1; break;
                    case 'ArrowLeft': players[1].input.x = -1; break;
                    case 'ArrowRight': players[1].input.x = 1; break;
                }
            }
        }
    }

    // ==================== 主循环 - 优化版 ====================
    function animate() {
        requestAnimationFrame(animate);
        
        const dt = Math.min(clock.getDelta(), 0.1); // 限制最大delta防止跳帧
        
        if (gameState === 'playing') {
            handleInput();
            
            // 批量更新玩家
            for (let i = 0; i < players.length; i++) {
                players[i].update(dt);
            }
            
            // 批量更新炸弹
            for (let i = 0; i < bombs.length; i++) {
                bombs[i].update(dt);
            }
            
            // 更新投射物（火箭等）
            updateProjectiles(dt);
            
            // 更新爆炸效果 - 使用对象池
            for (let i = explosions.length - 1; i >= 0; i--) {
                const exp = explosions[i];
                exp.life -= dt;
                exp.mesh.material.opacity = exp.life * 2;
                exp.mesh.scale.multiplyScalar(0.95);
                
                if (exp.life <= 0) {
                    scene.remove(exp.mesh);
                    explosionPool.release(exp);
                    explosions.splice(i, 1);
                }
            }
            
            // 更新道具 - 泡泡浮动效果
            const elapsed = clock.elapsedTime;
            for (let i = 0; i < powerups.length; i++) {
                const p = powerups[i];
                p.mesh.rotation.y += p.rotSpeed * dt;
                // 每个泡泡有不同的浮动相位
                const phase = p.bobPhase || 0;
                p.mesh.position.y = 1.8 + Math.sin(elapsed * 2 + phase) * 0.25;
                // 泡泡轻微缩放呼吸效果
                const scale = 1 + Math.sin(elapsed * 3 + phase) * 0.05;
                p.mesh.scale.set(scale, scale, scale);
            }
            
            // 更新水泡陷阱 - 每10秒投掷一个炸弹（森林关卡、海洋关卡、城市关卡、游乐园关卡和沙漠关卡不使用此机制）
            const theme = LEVEL_THEMES[currentLevel] || LEVEL_THEMES.fairy;
            if (!theme.hasPortals && !theme.hasVolcano && !theme.hasCars && !theme.hasCarousel && !theme.hasSandstorm) {
                waterTrapTimer += dt;
                if (waterTrapTimer >= 10) {
                    waterTrapTimer = 0;
                    launchWaterTrapBomb();
                }
            }
            
            // 游乐园关卡旋转木马机制 - 每6秒抛出3个道具
            if (theme.hasCarousel) {
                carouselTimer += dt;
                if (carouselTimer >= 6) {
                    carouselTimer = 0;
                    launchCarouselPowerups();
                }
                
                // 旋转木马旋转动画
                if (centerCarouselGroup) {
                    centerCarouselGroup.rotation.y += dt * 0.5;
                }
                
                // 更新飞行中的道具
                if (flyingPowerups.length > 0) {
                    updateFlyingPowerups(dt);
                }
            }
            
            // 海洋关卡火山爆发机制 - 每8秒爆发一次
            if (theme.hasVolcano) {
                volcanoTimer += dt;
                if (volcanoTimer >= 8 && !lavaActive) {
                    volcanoTimer = 0;
                    startVolcanoEruption();
                }
                
                // 更新岩浆预警
                if (lavaWarnings.length > 0) {
                    let allTriggered = true;
                    lavaWarnings.forEach(warning => {
                        if (warning.timer > 0) {
                            warning.timer -= dt;
                            allTriggered = false;
                            
                            // 预警闪烁效果
                            warning.mesh.children.forEach(child => {
                                if (child.userData && child.userData.isWarningInner) {
                                    child.material.opacity = 0.3 + Math.sin(elapsed * 10) * 0.3;
                                }
                            });
                            
                            // 预警时间到，触发岩浆喷发
                            if (warning.timer <= 0) {
                                triggerLavaEruption(warning);
                            }
                        }
                    });
                    
                    // 所有岩浆都喷发完毕
                    if (allTriggered) {
                        lavaWarnings = [];
                        lavaActive = false;
                    }
                }
            }
            
            // 城市关卡小汽车机制
            if (theme.hasCars && cityCars.length > 0) {
                updateCityCars(dt);
            }
            
            // 沙漠关卡沙尘龙卷风机制
            if (theme.hasSandstorm && sandstorms.length > 0) {
                updateSandstorms(dt, elapsed);
            }
            
            // 更新水泡陷阱动画
            if (waterTrap) {
                waterTrap.children.forEach((child, i) => {
                    if (child.userData && child.userData.floatOffset !== undefined) {
                        child.position.y = 0.5 + Math.sin(elapsed * 2 + child.userData.floatOffset) * 0.2;
                    }
                    // 蝴蝶飞舞动画
                    if (child.userData && child.userData.isButterfly) {
                        const offset = child.userData.floatOffset;
                        child.position.y = 2.5 + Math.sin(elapsed * 2 + offset) * 0.5;
                        child.position.x += Math.sin(elapsed * 3 + offset) * 0.01;
                        child.position.z += Math.cos(elapsed * 3 + offset) * 0.01;
                    }
                    // 火山气泡动画
                    if (child.userData && child.userData.isVolcanoBubble) {
                        const offset = child.userData.floatOffset;
                        child.position.y = 5.5 + Math.sin(elapsed * 2 + offset) * 1.0;
                    }
                    // 岩浆池动画
                    if (child.userData && child.userData.isLavaPool) {
                        child.material.emissiveIntensity = 0.5 + Math.sin(elapsed * 3) * 0.3;
                    }
                });
            }
            
            // 更新传送门动画
            if (portals && portals.length > 0) {
                portals.forEach(portal => {
                    portal.children.forEach(child => {
                        if (child.userData && child.userData.isVortex) {
                            child.rotation.y += dt * 2;
                        }
                        if (child.userData && child.userData.isPortalParticle) {
                            const offset = child.userData.floatOffset;
                            child.position.y = 0.5 + Math.sin(elapsed * 3 + offset) * 0.8;
                        }
                    });
                });
            }
            
            // 更新计时器
            gameTime -= dt;
            if (gameTime <= 0) {
                gameTime = 0;
                gameState = 'gameover';
                document.getElementById('winner-text').textContent = '时间到!';
                document.getElementById('gameover-screen').classList.remove('hidden');
            }
            
            const mins = Math.floor(gameTime / 60);
            const secs = Math.floor(gameTime % 60);
            document.getElementById('timer').textContent = 
                `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        
        renderer.render(scene, camera);
        FPS.update();
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // 启动游戏
    init();
    </script>
</body>
</html>
